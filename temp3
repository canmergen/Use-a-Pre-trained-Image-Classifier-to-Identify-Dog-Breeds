# doc_to_images.py
# -*- coding: utf-8 -*-

from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import numpy as np
import cv2
import fitz  # PyMuPDF
from PIL import Image
Image.MAX_IMAGE_PIXELS = None

try:
    import tifffile as tiff
    _HAS_TIFFFILE = True
except Exception:
    _HAS_TIFFFILE = False


def convert_document_to_images(
    path: Union[str, Path],
    *,
    pdf_dpi: int = 600,
    apply_orientation: bool = True,

    # Meta & kalite
    return_bgr: bool = True,
    debug: bool = False,

    # OSD rotasyonu (opsiyonel)
    osd_tc: Any = None,
    osd_conf: float = 0.0,

    # Skew kestirimi + otomatik deskew
    estimate_skew: bool = True,
    skew_max_angle: float = 8.0,         # |açı| > bu değer ise skew örneklemesinde dışla
    do_deskew: bool = True,              # otomatik deskew uygula
    deskew_abs_limit: float = 8.0,       # |skew| bu limiti aşarsa güvenmeyip deskew uygulama
    deskew_min_abs: float = 0.15,        # |skew| bu değerin altındaysa deskew yapma (gürültü)
    deskew_border: str = "white",        # "white" | "replicate" | "black"
) -> Dict[str, Any]:
    """
    PDF/TIFF'i tam sayfa rasterlayıp BGR (veya RGB) imaj + meta döndürür.
    - OSD varsa önce yönü düzeltir (rotation_deg).
    - estimate_skew=True ise residual skew (skew_deg) hesaplar.
    - do_deskew=True ise skew_deg'e göre kırpmasız deskew uygular (deskew_applied_deg).
    - Hem PDF hem TIFF için sayfa bazında, hatasız çalışmak üzere tasarlandı.

    Dönen:
    {
      "doc_str": "pdf_doc"|"tiff_doc",
      "path": "...",
      "page_count": N,
      "pages": [
        {
          "index": i,
          "dpi": (xdpi, ydpi) | (pdf_dpi, pdf_dpi),
          "shape": (H, W, 3),
          "dtype": "uint8",
          "mode": "BGR"|"RGB",
          "source": "pdf_raster"|"tifffile"|"pillow",
          "rotation_deg": float,          # OSD dönüşü
          "osd_confidence": float|None,
          "skew_deg": float|None,         # deskew öncesi ölçülen residual skew
          "deskew_applied_deg": float,    # uygulanan deskew açısı (0 olabilir)
          "rotation_total_deg": float,    # rotation_deg + deskew_applied_deg
          "shape_before_deskew": (H, W, 3),
          "shape_after_deskew": (H2, W2, 3),
          "image": np.ndarray             # BGR (varsayılan)
        }, ...
      ],
      "metas": [ ... ]                   # sayfa metasının hafif kopyası
    }
    """

    # ---------- yardımcılar ----------

    def _imshow(img: np.ndarray, title: str):
        if not debug:
            return
        import matplotlib.pyplot as plt
        plt.figure(figsize=(10, 10))
        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        plt.title(title)
        plt.axis("off")
        plt.show()

    def _apply_exif_orientation(arr: np.ndarray, orient: Optional[int]) -> np.ndarray:
        if orient is None:
            return arr
        if orient == 3:  # 180
            return np.rot90(arr, 2)
        if orient == 6:  # 270 CW
            return np.rot90(arr, 3)
        if orient == 8:  # 90 CW
            return np.rot90(arr, 1)
        return arr

    def _normalize_dpi_tuple(dpi_xy) -> Optional[Tuple[int, int]]:
        if dpi_xy is None:
            return None
        try:
            x, y = int(dpi_xy[0]), int(dpi_xy[1])
            if x <= 1 and y <= 1:
                return None
            return (x, y)
        except Exception:
            return None

    def _ensure_bgr(arr: np.ndarray) -> np.ndarray:
        if arr.ndim == 2:
            return cv2.cvtColor(arr, cv2.COLOR_GRAY2BGR)
        if arr.ndim == 3 and arr.shape[2] == 3:
            # Kaynak genelde RGB -> BGR
            return cv2.cvtColor(arr, cv2.COLOR_RGB2BGR)
        if arr.ndim == 3 and arr.shape[2] == 4:
            rgb = cv2.cvtColor(arr, cv2.COLOR_RGBA2RGB)
            return cv2.cvtColor(rgb, cv2.COLOR_RGB2BGR)
        # Fallback
        g = cv2.cvtColor(arr, cv2.COLOR_BGR2GRAY) if arr.ndim == 3 else arr
        return cv2.cvtColor(g, cv2.COLOR_GRAY2BGR)

    def _border_mode_and_value(kind: str):
        k = (kind or "white").lower()
        if k == "replicate":
            return cv2.BORDER_REPLICATE, None
        if k == "black":
            return cv2.BORDER_CONSTANT, (0, 0, 0)
        # default white
        return cv2.BORDER_CONSTANT, (255, 255, 255)

    def _rotate_keep_bounds(bgr: np.ndarray, angle_deg: float, border_kind: str = "white") -> np.ndarray:
        """
        Kırpmasız rotasyon: tuvali büyütür, tüm içerik görünür kalır.
        Pozitif açı: saat yönünün tersi.
        """
        if abs(angle_deg) < 1e-6:
            return bgr.copy()
        h, w = bgr.shape[:2]
        center = (w / 2.0, h / 2.0)
        M = cv2.getRotationMatrix2D(center, angle_deg, 1.0)
        # yeni tuval boyutunu hesapla (köşe koordinatları üzerinden)
        cos = abs(M[0, 0]); sin = abs(M[0, 1])
        new_w = int(h * sin + w * cos)
        new_h = int(h * cos + w * sin)
        # merkez kaydırması
        M[0, 2] += (new_w / 2) - center[0]
        M[1, 2] += (new_h / 2) - center[1]
        bmode, bval = _border_mode_and_value(border_kind)
        if bmode == cv2.BORDER_CONSTANT:
            return cv2.warpAffine(bgr, M, (new_w, new_h), flags=cv2.INTER_LINEAR,
                                  borderMode=bmode, borderValue=bval)
        else:
            return cv2.warpAffine(bgr, M, (new_w, new_h), flags=cv2.INTER_LINEAR,
                                  borderMode=bmode)

    def _osd_rotate_if_needed(bgr: np.ndarray) -> Tuple[np.ndarray, float, Optional[float]]:
        """
        Kullanıcının rotate_img_using_osd(...) fonksiyonunu çağırırsa OSD uygular.
        """
        if osd_tc is None:
            return bgr, 0.0, None
        # Dışarıda tanımlı fonksiyonu bulmaya çalış
        try:
            from rotate_utils import rotate_img_using_osd
        except Exception:
            try:
                rotate_img_using_osd  # type: ignore
            except NameError:
                return bgr, 0.0, None
        try:
            after_bgr, deg, conf = rotate_img_using_osd(bgr, osd_tc=osd_tc, osd_conf=osd_conf)  # type: ignore
            return after_bgr, float(deg or 0.0), (None if conf is None else float(conf))
        except Exception:
            return bgr, 0.0, None

    def _robust_skew_deg(bgr: np.ndarray, max_angle: float = 8.0) -> Optional[float]:
        """
        Hough + minAreaRect fallback ile residual skew tahmini (derece).
        """
        try:
            gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
            g = cv2.GaussianBlur(gray, (3, 3), 0)
            v = cv2.Canny(g, 50, 150)
            v = cv2.dilate(v, np.ones((3, 3), np.uint8), iterations=1)
            lines = cv2.HoughLinesP(v, 1, np.pi/1800, 120,
                                    minLineLength=max(30, min(bgr.shape[:2]) // 15),
                                    maxLineGap=10)
            angles: List[float] = []
            if lines is not None:
                arr = lines.squeeze(axis=1) if lines.ndim == 3 else lines
                for x1, y1, x2, y2, *_ in arr:
                    dx, dy = (x2 - x1), (y2 - y1)
                    ang = 90.0 if dx == 0 else float(np.degrees(np.arctan2(dy, dx)))
                    while ang <= -90: ang += 180
                    while ang >  90: ang -= 180
                    if abs(ang) <= max_angle:
                        angles.append(ang)

            if angles:
                a = np.array(angles, dtype=np.float32)
                med = float(np.median(a))
                mad = float(np.median(np.abs(a - med)) + 1e-6)
                keep = np.abs(a - med) <= (3.5 * mad)
                a2 = a[keep] if keep.any() else a
                return float(np.median(a2))

            # Fallback
            _, bw = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
            bw = cv2.morphologyEx(bw, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8), iterations=1)
            cnts, _ = cv2.findContours(bw, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
            if not cnts:
                return None
            areas = [cv2.contourArea(c) for c in cnts]
            if not areas:
                return None
            thr = max(50.0, np.percentile(areas, 60))
            angles2: List[float] = []
            for c in cnts:
                if cv2.contourArea(c) < thr:
                    continue
                rect = cv2.minAreaRect(c)  # angle in [-90, 0)
                ang = rect[-1]
                if ang < -45:  # normalize to [-45, 45]
                    ang = 90 + ang
                if abs(ang) <= max_angle:
                    angles2.append(float(ang))
            return float(np.median(np.array(angles2, dtype=np.float32))) if angles2 else None
        except Exception:
            return None

    # ---------- ana akış ----------

    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    out: Dict[str, Any] = {"doc_str": None, "path": str(p), "page_count": 0, "pages": [], "metas": []}

    def _postprocess_and_pack(arr_rgb_or_gray: np.ndarray, i: int, source: str, dpi_xy) -> None:
        # Görüntüyü BGR'e al
        bgr = _ensure_bgr(arr_rgb_or_gray) if return_bgr else arr_rgb_or_gray
        # 1) OSD rotasyonu
        bgr_rot, rot_deg, conf = _osd_rotate_if_needed(bgr)

        # 2) Skew tahmini
        skew_deg = _robust_skew_deg(bgr_rot, max_angle=skew_max_angle) if estimate_skew else None

        # 3) Deskew (şartlı)
        shape_before = tuple(bgr_rot.shape)
        deskew_deg = 0.0
        if do_deskew and (skew_deg is not None):
            if (abs(skew_deg) >= deskew_min_abs) and (abs(skew_deg) <= deskew_abs_limit):
                # Not: skew_deg pozitif ise saat yönünün tersine döndürme gerekir.
                # _rotate_keep_bounds da pozitif açıyı CCW uygular.
                bgr_rot = _rotate_keep_bounds(bgr_rot, -skew_deg, border_kind=deskew_border)
                deskew_deg = float(-skew_deg)

        shape_after = tuple(bgr_rot.shape)

        page_meta = {
            "index": i,
            "dpi": dpi_xy,
            "shape": shape_after,
            "dtype": str(bgr_rot.dtype),
            "mode": "BGR" if return_bgr else "RGB",
            "colorspace": "BGR" if return_bgr else "RGB",
            "source": source,
            "rotation_deg": float(rot_deg),
            "osd_confidence": conf,
            "skew_deg": (None if not estimate_skew else (None if skew_deg is None else float(skew_deg))),
            "deskew_applied_deg": deskew_deg,
            "rotation_total_deg": float(rot_deg + deskew_deg),
            "shape_before_deskew": shape_before,
            "shape_after_deskew": shape_after,
        }
        out["pages"].append({**page_meta, "image": bgr_rot})
        out["metas"].append({
            "page_index": i,
            "dpi": dpi_xy,
            "rotation_deg": page_meta["rotation_deg"],
            "osd_confidence": page_meta["osd_confidence"],
            "skew_deg": page_meta["skew_deg"],
            "deskew_applied_deg": page_meta["deskew_applied_deg"],
            "rotation_total_deg": page_meta["rotation_total_deg"],
            "shape_before_deskew": page_meta["shape_before_deskew"],
            "shape_after_deskew": page_meta["shape_after_deskew"],
        })

        if debug:
            _imshow(out["pages"][-1]["image"],
                    f"p{i} | rot={rot_deg:.2f}°, skew={skew_deg if skew_deg is not None else 'NA'}°, "
                    f"deskew={deskew_deg:.2f}° | {shape_after}")

    # ---- PDF ----
    if ext == ".pdf":
        out["doc_str"] = "pdf_doc"
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                scale = pdf_dpi / 72.0
                pix = page.get_pixmap(matrix=fitz.Matrix(scale, scale), alpha=True, colorspace=fitz.csRGB)
                buf = np.frombuffer(pix.samples, dtype=np.uint8)
                if pix.n == 1:
                    arr = buf.reshape(pix.h, pix.w).copy()
                    arr = cv2.cvtColor(arr, cv2.COLOR_GRAY2RGB)
                elif pix.n == 3:
                    arr = buf.reshape(pix.h, pix.w, 3).copy()   # RGB
                else:
                    arr = buf.reshape(pix.h, pix.w, pix.n)[:, :, :4].copy()  # RGBA
                    arr = cv2.cvtColor(arr, cv2.COLOR_RGBA2RGB)

                _postprocess_and_pack(arr, i, source="pdf_raster", dpi_xy=(pdf_dpi, pdf_dpi))
        finally:
            doc.close()
        out["page_count"] = len(out["pages"])

    # ---- TIFF ----
    elif ext in (".tif", ".tiff"):
        out["doc_str"] = "tiff_doc"

        def _tiff_with_tifffile(pth: Path):
            with tiff.TiffFile(pth.as_posix()) as tf:
                for i, pg in enumerate(tf.pages):
                    arr = pg.asarray()
                    orient = None
                    if apply_orientation:
                        try:
                            ori_tag = pg.tags.get("Orientation")
                            if ori_tag is not None:
                                orient = int(ori_tag.value)
                        except Exception:
                            orient = None
                    if apply_orientation and orient in (3, 6, 8):
                        arr = _apply_exif_orientation(arr, orient)

                    dpi_xy = None
                    xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
                    if xr and yr and ru:
                        def _rat(tag):
                            num, den = tag.value
                            return float(num) / float(den)
                        x, y = _rat(xr), _rat(yr)
                        if getattr(ru, "value", ru) == 3:  # 2: inch, 3: cm
                            x *= 2.54; y *= 2.54
                        dpi_xy = _normalize_dpi_tuple((int(round(x)), int(round(y))))

                    _postprocess_and_pack(arr, i, source="tifffile", dpi_xy=dpi_xy)

        def _tiff_with_pillow(pth: Path):
            with Image.open(pth.as_posix()) as im:
                n = getattr(im, "n_frames", 1)
                for i in range(n):
                    im.seek(i)
                    frame = im.copy()
                    orient = None
                    if apply_orientation:
                        try:
                            exif = frame.getexif()
                            orient = int(exif.get(274) or 1) if exif else 1
                        except Exception:
                            orient = 1
                    arr = np.array(frame)
                    if apply_orientation and orient in (3, 6, 8):
                        arr = _apply_exif_orientation(arr, orient)

                    dpi_xy = frame.info.get("dpi")
                    dpi_xy = _normalize_dpi_tuple(dpi_xy if isinstance(dpi_xy, (tuple, list)) else None)

                    _postprocess_and_pack(arr, i, source="pillow", dpi_xy=dpi_xy)

        try:
            if _HAS_TIFFFILE:
                _tiff_with_tifffile(p)
            else:
                _tiff_with_pillow(p)
        except Exception:
            _tiff_with_pillow(p)

        out["page_count"] = len(out["pages"])

    else:
        raise ValueError(f"Unsupported extension: {ext}")

    return out