# -*- coding: utf-8 -*-
import os, base64, cv2, numpy as np, requests

BASE = "https://internalgw/neomediaoperationsinternal/api/clear-ocr"
URLS = [f"{BASE}/post/v1", f"{BASE}/execute/v1", f"{BASE}/get/v1"]
TOKEN_ENV = "INTGW_ACCESS_KEY"

def _ensure_uint8(x): return np.clip(x, 0, 255).astype(np.uint8) if x.dtype != np.uint8 else x
def _to_bgr(img):
    img = _ensure_uint8(img)
    if img.ndim == 2:  return cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
    if img.ndim == 3 and img.shape[2] == 3: return img
    if img.ndim == 3 and img.shape[2] == 4: return cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
    raise ValueError(f"Unsupported shape {img.shape}")

def _b64_png(img_bgr):
    ok, buf = cv2.imencode(".png", img_bgr)
    if not ok: raise RuntimeError("PNG encode failed")
    return base64.b64encode(buf).decode("utf-8")

def _autoshrink(img, max_mb=4.5, min_side=600, debug=False):
    bgr = _to_bgr(img)
    b64 = _b64_png(bgr); mb = len(b64)/1_000_000
    if debug: print(f"[OCR] size={mb:.2f}MB, shape={bgr.shape[:2]}")
    while mb > max_mb and min(bgr.shape[:2]) > min_side:
        h, w = bgr.shape[:2]; bgr = cv2.resize(bgr, (int(w*0.9), int(h*0.9)), cv2.INTER_AREA)
        b64 = _b64_png(bgr); mb = len(b64)/1_000_000
        if debug: print(f"[OCR] shrink -> {mb:.2f}MB, shape={bgr.shape[:2]}")
    return bgr, b64

def _base_payload(image_b64):
    return {
        "requestHeader": {
            "info": {"correlationPair": [{"key":"AppName","value":"Postman"}]}
        },
        "customerNo": "10651337",
        "branchCode": "936",
        "channelInfo": "Branch",
        "language": "tr-TR",
        "transactionCode": "",
        "clientIP": "1.1.1.1",
        "clientPort": "0",
        "registrationNo": "49001",
        "userInfo": {
            "userID": "153", "userCode": "49001", "userBranchCode": "936",
            "roles": [{"roleID": "1501"}]
        },
        "performerUserInfo": {
            "userID": "153", "userCode": "49001", "userBranchCode": "936",
            "roles": [{"roleID": "1501"}]
        },
        "includeBbox": False,
        "fileName": "image.png",
        "fileType": "png",
        "contentType": "image/png",
        "content": image_b64
    }

def _auth_headers(token, mode):
    # mode: "access", "bearer", "both"
    base = {
        "Accept": "application/json",
        "User-Agent": "athena-ocr-client/1.0",
        "Content-Type": "application/json",
    }
    if mode in ("access", "both"):
        base["Access-Token"] = token
    if mode in ("bearer", "both"):
        base["Authorization"] = f"Bearer {token}"
    return base

def call_ocr_numpy(img, debug=False):
    token = os.environ[TOKEN_ENV]
    bgr, image_b64 = _autoshrink(img, debug=debug)
    payload = _base_payload(image_b64)

    for url in URLS:
        for mode in ("access", "bearer", "both"):
            try:
                hdr = _auth_headers(token, mode)
                resp = requests.post(url, headers=hdr, json=payload, verify=False, timeout=45)
                if debug:
                    print(f"TRY {url} auth={mode} -> HTTP {resp.status_code}")
                    if resp.status_code != 200:
                        t = resp.text
                        print(t[:400] if t else "(no body)")
                if resp.status_code == 403:
                    continue  # authorization mismatch
                if resp.status_code != 200:
                    continue  # try next combo
                data = resp.json()
                pages = (data.get("ocrPageResultList")
                         or data.get("OcrPageResultList")
                         or data.get("result", {}).get("ocrPageResultList")
                         or [])
                print(f"[OK] url={url} auth={mode}")
                return "\n".join([(p.get("extractedText") or "") for p in pages]).strip()
            except requests.RequestException as e:
                if debug: print("network error:", e)
                continue
    raise RuntimeError("All endpoint/auth combinations returned non-200 (likely ACL on POST).")

def call_ocr_batch(imgs, debug_each=False):
    out = []
    for i, im in enumerate(imgs):
        if im is None: out.append(None); continue
        print(f"\n[OCR] page {i}")
        try:
            txt = call_ocr_numpy(im, debug=debug_each)
            out.append(txt if txt else None)
        except Exception as e:
            print(f"[{i}] failed:", e); out.append(None)
    return out

texts = call_ocr_batch(final_lower_imgs, debug_each=True)
for i, t in enumerate(texts):
   