# paddleocr_usage.py
import os
import json
import base64
import requests
from io import BytesIO
from typing import Optional, Union

from PIL import Image
import numpy as np

TARGET_URL = "https://internalgw/neo/mediaoperationsinternal/api/clear-ocr/get/v1"
ENV_KEY = "INGAI_ACCESS_KEY"  # adjust if your env var name differs

def _encode_image_to_b64(img: Image.Image) -> str:
    buf = BytesIO()
    fmt = "PNG"
    img.save(buf, format=fmt)
    img_bytes = buf.getvalue()
    return base64.b64encode(img_bytes).decode("utf-8")

def _post_ocr(image_b64: str) -> str:
    token = os.environ.get(ENV_KEY)
    if not token:
        raise EnvironmentError(f"Missing {ENV_KEY} environment variable")

    headers = {
        "Access-Token": token,
        "Content-Type": "application/json",
    }

    # NOTE: keep only fields your service truly requires.
    payload = {
        "requestHeader": {
            "info": {"correlationPair": [{"key": "AppName", "value": "Postman"}]}
        },
        "includeBbox": False,
        "content": image_b64,
    }

    resp = requests.post(
        TARGET_URL,
        headers=headers,           # ← fixed
        json=payload,
        verify=False,              # if your internal CA isn’t trusted
        timeout=30,
    )
    resp.raise_for_status()
    data = resp.json()

    # Defensive extraction
    ocr_pages = data.get("ocrPageResultList") or []
    text_parts = []
    for page in ocr_pages:
        t = page.get("extractedText") or ""
        if isinstance(t, str):
            text_parts.append(t)
    return "\n".join(text_parts).strip()

def call_paddle_ocr_text_only_path(image_path: str) -> str:
    """OCR for an image on disk."""
    img = Image.open(image_path).convert("RGB")
    image_b64 = _encode_image_to_b64(img)
    return _post_ocr(image_b64)

def call_paddle_ocr_text_only_array(img: Union[np.ndarray, Image.Image]) -> str:
    """OCR for an in-memory image (NumPy array or PIL Image)."""
    if isinstance(img, np.ndarray):
        if img.ndim == 2:
            pil = Image.fromarray(img).convert("RGB")
        elif img.ndim == 3:
            # assume BGR from OpenCV; convert to RGB
            if img.shape[2] == 3:
                pil = Image.fromarray(img[:, :, ::-1]).convert("RGB")
            elif img.shape[2] == 4:
                pil = Image.fromarray(img[:, :, [2,1,0,3]]).convert("RGB")
            else:
                raise ValueError("Unsupported channel count in NumPy array")
        else:
            raise ValueError("Unsupported ndarray shape for image")
    elif isinstance(img, Image.Image):
        pil = img.convert("RGB")
    else:
        raise TypeError("img must be a NumPy array or PIL.Image.Image")

    image_b64 = _encode_image_to_b64(pil)
    return _post_ocr(image_b64)

from importlib import reload
import paddleocr_usage
reload(paddleocr_usage)  # ensure latest code

from paddleocr_usage import call_paddle_ocr_text_only_array

ocr_results = []
for i, img in enumerate(final_lower_imgs):
    if img is None:
        ocr_results.append(None)
        continue
    try:
        print(f"[Page {i}] Sending image to OCR API…")
        text = call_paddle_ocr_text_only_array(img)
        print(f"[Page {i}] OCR done.")
        ocr_results.append(text if text else None)
    except Exception as e:
        print(f"[Page {i}] OCR failed: {e}")
        ocr_results.append(None)

for i, text in enumerate(ocr_results):
    print(f"\n=== PAGE {i} : OCR RESULT ===")
    print(text or "(No text detected / OCR failed)")