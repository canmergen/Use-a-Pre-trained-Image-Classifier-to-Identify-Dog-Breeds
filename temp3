# -*- coding: utf-8 -*-
from __future__ import annotations
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import re, difflib
import numpy as np
import cv2, fitz
from PIL import Image
Image.MAX_IMAGE_PIXELS = None

try:
    import tifffile as tiff
    _HAS_TIFF = True
except Exception:
    _HAS_TIFF = False


def convert_document_with_rotation_and_keywords(
    path: Union[str, Path],
    *,
    pdf_dpi: int = 600,
    osd_tc: Any = None,                # get_osd_ocr(PIL, output_type='dict') beklenir
    tc_new: Any = None,                # ocr / run_ocr / predict / infer / get_text / __call__
    keywords: Optional[List[str]] = None,
    enable_keyword_rotation: bool = True,
    keyword_rotation_mode: str = "after_osd",   # 'after_osd' | 'raw'
    tc_new_lang: str = "tur",
    tc_new_psm: Optional[int] = None,
    tc_new_oem: Optional[int] = None,
    tc_new_config: Optional[str] = None,
    keyword_exceptions_prefix: Optional[List[str]] = None,  # örn: ['paylaş']
    fuzzy_min_ratio: float = 0.86,
    deskew: bool = True,
    deskew_method: str = "projection", # 'projection' | 'hough' | 'auto'
    deskew_max_abs: float = 15.0,
    deskew_step: float = 0.5,
    deskew_min_gain: float = 1.03,
    deskew_min_abs: float = 0.3,
    angle_estimation_max_side: int = 1600,
    return_bgr: bool = True,
    debug: bool = False,
    ocr_debug: bool = False,           # konsola print + metaya OCR önizleme
) -> Dict[str, Any]:

    # ------------ image helpers ------------
    def _ensure_bgr(arr: np.ndarray) -> np.ndarray:
        if arr.ndim == 2:
            return cv2.cvtColor(arr.astype(np.uint8, copy=False), cv2.COLOR_GRAY2BGR)
        if arr.ndim == 3 and arr.shape[2] >= 3:
            return arr[:, :, :3].astype(np.uint8, copy=False)
        s = np.squeeze(arr)
        if s.ndim == 2:
            return cv2.cvtColor(s.astype(np.uint8, copy=False), cv2.COLOR_GRAY2BGR)
        if s.ndim == 3 and s.shape[2] >= 3:
            return s[:, :, :3].astype(np.uint8, copy=False)
        raise ValueError(f"Unsupported array shape: {arr.shape}")

    def _rgba_to_bgr_on_white(rgba: np.ndarray) -> np.ndarray:
        rgb = rgba[..., :3].astype(np.float32)
        alpha = rgba[..., 3:4].astype(np.float32)/255.0
        out = rgb*alpha + 255.0*(1.0-alpha)
        return cv2.cvtColor(np.clip(out,0,255).astype(np.uint8), cv2.COLOR_RGB2BGR)

    def _apply_exif_orientation(bgr: np.ndarray, orient: Optional[int]) -> Tuple[np.ndarray,int]:
        # 1: normal, 3: 180, 6: 270 CW (= +90 CCW), 8: 90 CW (= -90 CCW)
        if orient == 3:  return np.rot90(bgr,2).copy(), 180
        if orient == 6:  return np.rot90(bgr,1).copy(),  90
        if orient == 8:  return np.rot90(bgr,3).copy(), -90
        return bgr, 0

    def _rotate_full_canvas(bgr: np.ndarray, angle_ccw: float) -> np.ndarray:
        if abs(angle_ccw) < 1e-6: return bgr
        (h,w) = bgr.shape[:2]
        c = (w/2.0, h/2.0)
        M = cv2.getRotationMatrix2D(c, angle_ccw, 1.0)  # CCW +
        cos, sin = abs(M[0,0]), abs(M[0,1])
        nW = int(h*sin + w*cos); nH = int(h*cos + w*sin)
        M[0,2] += (nW/2.0) - c[0]; M[1,2] += (nH/2.0) - c[1]
        return cv2.warpAffine(bgr, M, (nW,nH), flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REPLICATE)

    def _apply_right_angle_ccw(bgr: np.ndarray, ra: int) -> np.ndarray:
        if ra == 0:   return bgr
        if ra == 90:  return np.rot90(bgr,1).copy()
        if ra == 180: return np.rot90(bgr,2).copy()
        if ra == -90: return np.rot90(bgr,3).copy()
        return _rotate_full_canvas(bgr, float(ra))

    def _make_small(bgr: np.ndarray) -> np.ndarray:
        h,w = bgr.shape[:2]
        m = max(h,w)
        if m <= angle_estimation_max_side: return bgr
        s = angle_estimation_max_side/float(m)
        return cv2.resize(bgr, (int(w*s), int(h*s)), interpolation=cv2.INTER_AREA)

    # ------------ OCR helpers ------------
    def _osd_detect_deg_cw(bgr_small: np.ndarray) -> Tuple[Optional[int], Optional[float]]:
        if osd_tc is None: return None, None
        try:
            pil = Image.fromarray(cv2.cvtColor(bgr_small, cv2.COLOR_BGR2RGB))
            raw = osd_tc.get_osd_ocr(pil, config='', model='best', output_type='dict')
            if not isinstance(raw, dict): return None, None
            d = raw.get('dict', raw)
            deg = int(d.get('rotate', d.get('rotation', d.get('rot', 0)) ) or 0) % 360
            conf = float(d.get('orientation_conf', d.get('conf', d.get('confidence', 0.0)) ) or 0.0)
            return deg, conf
        except Exception:
            return None, None

    def _tc_new_text(bgr_small: np.ndarray) -> str:
        if tc_new is None: return ""
        pil = Image.fromarray(cv2.cvtColor(bgr_small, cv2.COLOR_BGR2RGB))
        kwargs: Dict[str,Any] = {}
        if tc_new_config:
            kwargs["config"] = tc_new_config
        else:
            cfg=[]
            if tc_new_psm is not None: cfg.append(f"--psm {int(tc_new_psm)}")
            if tc_new_oem is not None: cfg.append(f"--oem {int(tc_new_oem)}")
            if cfg: kwargs["config"] = " ".join(cfg)
        if tc_new_lang: kwargs["lang"] = tc_new_lang

        for name in ("ocr","run_ocr","predict","infer","get_text","__call__"):
            fn = getattr(tc_new, name, None)
            if callable(fn):
                try:
                    txt = fn(pil, **kwargs)
                    if isinstance(txt, dict): txt = txt.get("text","")
                    return txt if isinstance(txt,str) else str(txt)
                except TypeError:
                    try:
                        txt = fn(pil, output_type="text", **kwargs)
                        if isinstance(txt, dict): txt = txt.get("text","")
                        return txt if isinstance(txt,str) else str(txt)
                    except Exception:
                        pass
                except Exception:
                    pass
        return ""

    # ------------ fuzzy keyword match ------------
    _TR_WORD = re.compile(r"[a-zçğıöşü]+", re.IGNORECASE)
    def _tr_lower(s: str) -> str:
        return (s.replace("I","ı").replace("İ","i")).lower()
    def _tokenize(s: str) -> List[str]:
        return [ _tr_lower(m.group(0)) for m in _TR_WORD.finditer(s) ]
    def _keyword_score_fuzzy(text: str, kws: List[str],
                             exceptions_prefix: Optional[List[str]]=None,
                             min_ratio: float = 0.86) -> int:
        tks = _tokenize(text)
        if not tks: return 0
        tset = set(tks)
        ex = set(_tr_lower(x) for x in (exceptions_prefix or []))
        score = 0
        for kw in kws:
            kw0 = _tr_lower(kw.strip())
            if not kw0: continue
            if kw0 in tset:
                score += 1; continue
            # kök+ek (başlangıç) – ama istisna köklerle başlamasın
            starts = [tok for tok in tks if tok.startswith(kw0)]
            if starts:
                if not any(tok.startswith(tuple(ex)) for tok in starts) if ex else True:
                    score += 1; continue
            # fuzzy
            best = 0.0
            for tok in tset:
                r = difflib.SequenceMatcher(None, kw0, tok).ratio()
                if r > best: best = r
            if best >= min_ratio: score += 1
        return score

    # ------------ skew ------------
    def _deskew_projection_angle(bgr_small: np.ndarray,
                                 max_abs: float, step: float) -> Tuple[float, float, float]:
        gray = cv2.cvtColor(bgr_small, cv2.COLOR_BGR2GRAY)
        g = cv2.GaussianBlur(gray,(3,3),0)
        _, bw = cv2.threshold(g, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)
        if np.mean(bw) > 127: bw = 255 - bw
        ink = float(np.count_nonzero(bw))/bw.size
        if ink < 0.004: return 0.0, 0.0, 0.0

        def _score(arr: np.ndarray) -> float:
            proj = arr.sum(axis=1).astype(np.float32)/255.0
            return float(np.var(proj) + np.var(np.diff(proj)))

        base = _score(bw)
        best, best_sc = 0.0, -1e18

        h,w = bw.shape
        c = (w/2.0, h/2.0)
        for a in np.arange(-max_abs, max_abs+1e-6, step, dtype=np.float32):
            M = cv2.getRotationMatrix2D(c, float(a), 1.0)
            cos, sin = abs(M[0,0]), abs(M[0,1])
            nW = int(h*sin + w*cos); nH = int(h*cos + w*sin)
            Mt = M.copy(); Mt[0,2] += (nW/2.0)-c[0]; Mt[1,2] += (nH/2.0)-c[1]
            rot = cv2.warpAffine(bw, Mt, (nW,nH), flags=cv2.INTER_NEAREST, borderValue=0)
            sc = _score(rot)
            if sc > best_sc: best_sc, best = sc, float(a)
        return best, best_sc, base

    def _deskew_hough_angle(bgr_small: np.ndarray, cap: float=10.0) -> Tuple[float,int]:
        try:
            gray = cv2.cvtColor(bgr_small, cv2.COLOR_BGR2GRAY)
            g = cv2.GaussianBlur(gray,(3,3),0)
            edges = cv2.Canny(g,50,150)
            edges = cv2.dilate(edges, np.ones((3,3),np.uint8), 1)
            lines = cv2.HoughLinesP(edges,1,np.pi/1800,120,
                                    minLineLength=max(30, min(bgr_small.shape[:2])//15),
                                    maxLineGap=10)
            if lines is None: return 0.0, 0
            angs=[]
            L = lines.squeeze(axis=1) if lines.ndim==3 else lines
            for x1,y1,x2,y2 in L:
                dx,dy = x2-x1, y2-y1
                ang = 90.0 if dx==0 else np.degrees(np.arctan2(dy,dx))
                while ang <= -90: ang += 180
                while ang >   90: ang -= 180
                if abs(ang) <= cap: angs.append(float(ang))
            if not angs: return 0.0,0
            a = np.array(angs, np.float32)
            med = float(np.median(a)); mad = float(np.median(np.abs(a-med))+1e-6)
            keep = np.abs(a-med) <= 3.5*mad
            a2 = a[keep] if keep.any() else a
            return float(np.median(a2)), int(len(a2))
        except Exception:
            return 0.0, 0

    # ------------ angles ------------
    def _osd_cw_to_ccw_deg(dcw: Optional[int]) -> int:
        if dcw is None: return 0
        d = int(dcw) % 360
        # OSD rotate (CW) -> uygulanacak CCW:
        if d == 0:   return 0
        if d == 90:  return 90      # sağa yatık (CW)  -> +90 CCW
        if d == 180: return 180
        if d == 270: return -90     # sola yatık (CCW) -> -90 CCW
        return 0

    def _imshow_before_after(before: np.ndarray, after: np.ndarray, title: str):
        if not debug: return
        try:
            import matplotlib.pyplot as plt
            plt.figure(figsize=(12,6))
            ax1 = plt.subplot(1,2,1); ax1.imshow(cv2.cvtColor(before, cv2.COLOR_BGR2RGB)); ax1.set_title("Before"); ax1.axis("off")
            ax2 = plt.subplot(1,2,2); ax2.imshow(cv2.cvtColor(after,  cv2.COLOR_BGR2RGB)); ax2.set_title("After");  ax2.axis("off")
            plt.suptitle(title); plt.tight_layout(); plt.show()
        except Exception:
            pass  # headless ortamda sorun çıkmasın

    def _normalize_dpi_tuple(dpi_xy) -> Optional[Tuple[int,int]]:
        if dpi_xy is None: return None
        try:
            x,y = int(dpi_xy[0]), int(dpi_xy[1])
            if x<=1 and y<=1: return None
            return (x,y)
        except Exception:
            return None

    # ------------ raster: PDF / TIFF ------------
    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    pages_raw: List[Tuple[int,np.ndarray,Optional[Tuple[int,int]],str,Optional[int]]] = []

    if ext == ".pdf":
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                scale = pdf_dpi/72.0
                pix = page.get_pixmap(matrix=fitz.Matrix(scale,scale), alpha=False, colorspace=fitz.csRGB)
                buf = np.frombuffer(pix.samples, dtype=np.uint8)
                if pix.n == 3:
                    arr = buf.reshape(pix.h, pix.w, 3).copy()
                elif pix.n == 1:
                    arr = cv2.cvtColor(buf.reshape(pix.h, pix.w), cv2.COLOR_GRAY2RGB)
                else:
                    rgba = buf.reshape(pix.h, pix.w, pix.n)[:, :, :4].copy()
                    bgr = _rgba_to_bgr_on_white(rgba)
                    pages_raw.append((i, bgr, (pdf_dpi,pdf_dpi), "pdf_raster", None))
                    continue
                bgr = cv2.cvtColor(arr, cv2.COLOR_RGB2BGR) if return_bgr else arr
                pages_raw.append((i, bgr, (pdf_dpi,pdf_dpi), "pdf_raster", None))
        finally:
            doc.close()
        doc_str = "pdf_doc"

    elif ext in (".tif", ".tiff"):
        doc_str = "tiff_doc"
        if _HAS_TIFF:
            with tiff.TiffFile(p.as_posix()) as tf:
                for i, pg in enumerate(tf.pages):
                    try:
                        comp = getattr(pg, "compression", None)
                        if comp is not None and "CCITT" in str(comp):
                            raise NotImplementedError("CCITT -> Pillow fallback")
                        arr = pg.asarray()
                        bgr = _ensure_bgr(arr)
                        dpi_xy = None
                        try:
                            xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
                            if xr and yr and ru:
                                def _rat(tag): num, den = tag.value; return float(num)/float(den)
                                x,y = _rat(xr), _rat(yr)
                                if getattr(ru,"value",ru) == 3: x*=2.54; y*=2.54
                                dpi_xy = _normalize_dpi_tuple((int(round(x)), int(round(y))))
                        except Exception: dpi_xy = None
                        orient = None
                        try: orient = (pg.tags.get("Orientation") or {}).value
                        except Exception: pass
                        pages_raw.append((i, bgr, dpi_xy, "tifffile", orient))
                    except Exception:
                        # Pillow fallback (CCITT vb.)
                        with Image.open(p.as_posix()) as im:
                            im.seek(i)
                            pil = im.convert("RGB")
                            arr = np.array(pil)
                            bgr = cv2.cvtColor(arr, cv2.COLOR_RGB2BGR)
                            dpi_xy = _normalize_dpi_tuple(pil.info.get("dpi")) if isinstance(pil.info.get("dpi"),(tuple,list)) else None
                            pages_raw.append((i, bgr, dpi_xy, "pillow", None))
        else:
            with Image.open(p.as_posix()) as im:
                n = getattr(im, "n_frames", 1)
                for i in range(n):
                    im.seek(i)
                    pil = im.convert("RGB")
                    arr = np.array(pil)
                    bgr = cv2.cvtColor(arr, cv2.COLOR_RGB2BGR)
                    dpi_xy = _normalize_dpi_tuple(pil.info.get("dpi")) if isinstance(pil.info.get("dpi"),(tuple,list)) else None
                    pages_raw.append((i, bgr, dpi_xy, "pillow", None))
    else:
        raise ValueError(f"Unsupported extension: {ext}")

    # ------------ process: EXIF -> OSD -> (optional) keywords -> DESKEW ------------
    images: List[np.ndarray] = []
    metas: List[Dict[str,Any]] = []

    kw_enabled = (
        enable_keyword_rotation and
        tc_new is not None and
        isinstance(keywords, list) and
        any(isinstance(k,str) and k.strip() for k in keywords)
    )
    kw_list = [k for k in (keywords or []) if isinstance(k,str) and k.strip()]
    kw_ex = list(keyword_exceptions_prefix or [])

    for (i, bgr0, dpi_xy, source, orient_tag) in pages_raw:
        # EXIF (TIFF)
        exif_deg = 0
        if orient_tag is not None:
            bgr1, exif_deg = _apply_exif_orientation(bgr0, orient_tag)
        else:
            bgr1 = bgr0

        # OSD ve mapping
        small1 = _make_small(bgr1)
        osd_deg_cw, osd_conf = _osd_detect_deg_cw(small1)
        osd_to_ccw = _osd_cw_to_ccw_deg(osd_deg_cw)

        # OSD right-angle uygula (kayıpsız)
        bgr_osd = _apply_right_angle_ccw(bgr1, osd_to_ccw)

        # Keyword döngüsü
        best_ra = 0
        best_score = 0
        best_img = bgr_osd
        ocr_dbg: Dict[str,Any] = {}

        if kw_enabled:
            # hangi baz üzerinde döneceğiz?
            base_img = bgr_osd if keyword_rotation_mode == "after_osd" else bgr1
            base_ra_offset = osd_to_ccw if keyword_rotation_mode == "raw" else 0

            candidate_ras = [0, 90, 180, -90]
            best_score = -1
            for ra in candidate_ras:
                prev = _apply_right_angle_ccw(base_img, ra) if ra != 0 else base_img
                prev_small = _make_small(prev)
                txt = _tc_new_text(prev_small)
                sc = _keyword_score_fuzzy(txt, kw_list, exceptions_prefix=kw_ex, min_ratio=fuzzy_min_ratio)
                if sc > best_score:
                    best_score = sc
                    best_ra = ra
                    best_img = prev
                if ocr_debug:
                    preview = (txt or "")[:400].replace("\n\n","\n")
                    lines = "\n".join(preview.splitlines()[:3])
                    print(f"[OCR p{i:02d} RA={ra:+}] score={sc} | preview:\n{lines}\n{'-'*60}")
                    ocr_dbg[str(ra)] = {"score": int(sc), "preview": lines}
            # keyword_rotation_mode = 'raw' ise, toplam açıya OSD offsetini ekleyeceğiz:
            if keyword_rotation_mode == "raw":
                best_ra += base_ra_offset  # toplam CCW RA

        # DESKEW (güvence ile)
        small2 = _make_small(best_img)
        deskew_deg = 0.0
        proj_best = proj_base = 0.0
        hough_deg, hough_n = 0.0, 0

        if deskew:
            if deskew_method == "projection":
                a, s_best, s_base = _deskew_projection_angle(small2, deskew_max_abs, deskew_step)
                gain = (s_best / max(s_base,1e-6)) if s_best>0 else 1.0
                if abs(a) >= deskew_min_abs and gain >= deskew_min_gain:
                    deskew_deg, proj_best, proj_base = float(a), float(s_best), float(s_base)
            elif deskew_method == "hough":
                a, n = _deskew_hough_angle(small2, cap=min(deskew_max_abs,15.0))
                if abs(a) >= deskew_min_abs:
                    deskew_deg, hough_deg, hough_n = float(a), float(a), int(n)
            else:  # auto
                a1,s1,b0 = _deskew_projection_angle(small2, deskew_max_abs, deskew_step)
                a2,n2     = _deskew_hough_angle(small2, cap=min(deskew_max_abs,15.0))
                gain1 = (s1/max(b0,1e-6)) if s1>0 else 1.0
                if abs(a1)>=deskew_min_abs and gain1>=deskew_min_gain:
                    deskew_deg, proj_best, proj_base = float(a1), float(s1), float(b0)
                elif abs(a2)>=deskew_min_abs:
                    deskew_deg, hough_deg, hough_n = float(a2), float(a2), int(n2)

        bgr_final = _rotate_full_canvas(best_img, float(deskew_deg))
        total_deg = float(exif_deg + osd_to_ccw + best_ra + deskew_deg)

        if debug:
            _imshow_before_after(bgr0, bgr_final, f"Page {i} | total={total_deg:.2f}°")

        meta: Dict[str,Any] = {
            "page_index": i,
            "dpi": dpi_xy,
            "shape": tuple(bgr_final.shape),
            "source": source,
            "exif_orientation_applied_deg": int(exif_deg),
            "osd_raw_deg_cw": (None if osd_deg_cw is None else int(osd_deg_cw)),
            "osd_confidence": (None if osd_conf is None else float(osd_conf)),
            "osd_to_ccw_deg": int(osd_to_ccw),
            "keyword_rotation_enabled": bool(kw_enabled),
            "keyword_rotation_mode": keyword_rotation_mode,
            "keyword_best_ccw_deg": int(best_ra if kw_enabled else 0),
            "keyword_match_score": int(best_score if kw_enabled else 0),
            "deskew_method": deskew_method,
            "deskew_deg": float(deskew_deg),
            "deskew_projection_best": float(proj_best),
            "deskew_projection_base": float(proj_base),
            "deskew_hough_deg": float(hough_deg),
            "deskew_hough_votes": int(hough_n),
            "total_rotation_applied_deg": total_deg
        }
        if ocr_debug and kw_enabled:
            meta["ocr_debug"] = ocr_dbg

        images.append(bgr_final)
        metas.append(meta)

    return {
        "path": str(p),
        "doc_str": "pdf_doc" if ext == ".pdf" else "tiff_doc",
        "page_count": len(images),
        "images": images,   # sayfa sayfa BGR
        "metas": metas
    }