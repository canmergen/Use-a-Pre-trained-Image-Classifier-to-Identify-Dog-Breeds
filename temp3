# -*- coding: utf-8 -*-
from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import numpy as np
import cv2
import fitz  # PyMuPDF
from PIL import Image
Image.MAX_IMAGE_PIXELS = None

try:
    import tifffile as tiff
    _HAS_TIFFFILE = True
except Exception:
    _HAS_TIFFFILE = False


def doc_to_images_autorotate_deskew(
    path: Union[str, Path],
    *,
    pdf_dpi: int = 600,
    apply_orientation: bool = True,
    osd_tc: Any = None,          # TesseractClient benzeri: .get_osd_ocr(PIL, ...) -> dict
    osd_conf: float = 0.0,       # OSD güven eşiği
    estimate_skew: bool = True,  # residual skew tahmini
    skew_max_angle: float = 8.0, # |açı| > bu değer outlier sayılır
    return_bgr: bool = True,     # BGR döndür (OCR için uygundur)
    debug: bool = False
) -> Dict[str, Any]:
    """
    Tek fonksiyonla:
      1) PDF/TIFF lossless raster
      2) EXIF/TIFF orientation uygula (varsa)
      3) OSD ile en yakın 0/90/180/270° (kayıpsız)
      4) Skew (küçük açı) tahmini ve kırpmasız deskew

    Dönüş:
    {
      "path": str,
      "doc_str": "pdf_doc"|"tiff_doc",
      "page_count": int,
      "images": List[np.ndarray],  # BGR veya RGB, sayfa sırasıyla
      "metas": [
        {
          "page_index": int,
          "dpi": (x_dpi, y_dpi) | (pdf_dpi, pdf_dpi) | None,
          "shape": (H, W, C),
          "mode": "BGR"|"RGB",
          "source": "pdf_raster"|"tifffile"|"pillow",
          "exif_orientation_applied_deg": int,   # 0/±90/180
          "osd_raw_deg": float|None,
          "osd_confidence": float|None,
          "right_angle_applied_deg": int,        # 0/±90/180
          "skew_deg": float|None,                # ölçülen
          "deskew_applied_deg": float,           # uygulanan
          "total_rotation_applied_deg": float
        }, ...
      ]
    }
    """

    # ---- yardımcılar ----
    def _imshow(bgr: np.ndarray, title: str):
        if not debug:
            return
        import matplotlib.pyplot as plt
        plt.figure(figsize=(8, 8))
        plt.imshow(cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB))
        plt.title(title)
        plt.axis("off")
        plt.show()

    def _normalize_dpi_tuple(dpi_xy) -> Optional[Tuple[int, int]]:
        if dpi_xy is None:
            return None
        try:
            x, y = int(dpi_xy[0]), int(dpi_xy[1])
            if x <= 1 and y <= 1:
                return None
            return (x, y)
        except Exception:
            return None

    def _rgba_to_bgr_on_white(rgba: np.ndarray) -> np.ndarray:
        rgb = rgba[..., :3].astype(np.float32)
        alpha = rgba[..., 3:4].astype(np.float32) / 255.0
        out = rgb * alpha + 255.0 * (1.0 - alpha)
        out = np.clip(out, 0, 255).astype(np.uint8)
        return cv2.cvtColor(out, cv2.COLOR_RGB2BGR)

    def _to_uint8_gray(arr: np.ndarray) -> np.ndarray:
        if arr.dtype == np.bool_:
            return (arr.astype(np.uint8) * 255)
        if arr.dtype == np.uint16:
            return cv2.convertScaleAbs(arr, alpha=255.0 / 65535.0)
        return arr.astype(np.uint8, copy=False)

    def _ensure_bgr_safe(arr: np.ndarray, *, photometric: Optional[str] = None) -> np.ndarray:
        # L/1/bool/uint16/RGB/RGBA -> BGR
        if arr.ndim == 2:
            g = _to_uint8_gray(arr)
            # TIFF photometric MINISWHITE ise invert et
            if (photometric or "").upper() == "MINISWHITE":
                g = 255 - g
            return cv2.cvtColor(g, cv2.COLOR_GRAY2BGR)
        if arr.ndim == 3:
            c = arr.shape[2]
            if c == 3:
                return cv2.cvtColor(arr.astype(np.uint8, copy=False), cv2.COLOR_RGB2BGR)
            if c == 4:
                return _rgba_to_bgr_on_white(arr.astype(np.uint8, copy=False))
            if c > 4:
                return cv2.cvtColor(arr[..., :3].astype(np.uint8, copy=False), cv2.COLOR_RGB2BGR)
        arr = np.squeeze(arr)
        if arr.ndim == 2:
            return cv2.cvtColor(_to_uint8_gray(arr), cv2.COLOR_GRAY2BGR)
        raise ValueError(f"Unsupported array shape: {arr.shape}, dtype={arr.dtype}")

    def _apply_exif_orientation(bgr: np.ndarray, orient: Optional[int]) -> Tuple[np.ndarray, int]:
        # 1: normal, 3: 180, 6: 270 CW (== 90 CCW), 8: 90 CW (== -90 CCW)
        deg = 0
        if orient is None:
            return bgr, 0
        if orient == 3:
            bgr = np.rot90(bgr, 2); deg = 180
        elif orient == 6:
            bgr = np.rot90(bgr, 1); deg = 90
        elif orient == 8:
            bgr = np.rot90(bgr, 3); deg = -90
        return bgr.copy(), deg

    def _osd_estimate_angle(bgr: np.ndarray) -> Tuple[Optional[float], Optional[float]]:
        if osd_tc is None:
            return None, None
        try:
            from PIL import Image as _PILImage
            pil = _PILImage.fromarray(cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB))
            raw = osd_tc.get_osd_ocr(pil, config='', model='best', output_type='dict')
        except Exception:
            return None, None
        if not isinstance(raw, dict) or 'error' in raw:
            return None, None
        d = raw.get('dict', raw)
        deg  = d.get('rotate', d.get('rotation', d.get('rot', None)))
        conf = d.get('orientation_conf', d.get('conf', d.get('confidence', None)))
        return (None if deg is None else float(deg)), (None if conf is None else float(conf))

    def _round_to_right_angle(osd_deg: float) -> int:
        # 0/±90/180'e en yakın
        cands = np.array([0, 90, -90, 180], dtype=np.int32)
        return int(cands[np.argmin(np.abs(cands - osd_deg))])

    def _apply_right_angle(bgr: np.ndarray, ra_deg: int) -> np.ndarray:
        if ra_deg == 0:   return bgr.copy()
        if ra_deg == 90:  return np.rot90(bgr, 1).copy()
        if ra_deg == 180: return np.rot90(bgr, 2).copy()
        if ra_deg == -90: return np.rot90(bgr, 3).copy()
        # beklenmeyen: küçük açı gibi davran
        return _rotate_keep_bounds(bgr, float(ra_deg))

    def _rotate_keep_bounds(bgr: np.ndarray, angle_deg: float) -> np.ndarray:
        if abs(angle_deg) < 1e-3:
            return bgr.copy()
        (h, w) = bgr.shape[:2]
        c = (w / 2.0, h / 2.0)
        M = cv2.getRotationMatrix2D(c, angle_deg, 1.0)  # CCW+
        cos = abs(M[0, 0]); sin = abs(M[0, 1])
        nW = int((h * sin) + (w * cos))
        nH = int((h * cos) + (w * sin))
        M[0, 2] += (nW / 2) - c[0]
        M[1, 2] += (nH / 2) - c[1]
        return cv2.warpAffine(bgr, M, (nW, nH), flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REPLICATE)

    def _robust_skew_deg(bgr: np.ndarray, max_angle: float = 8.0) -> Optional[float]:
        try:
            gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
            g = cv2.GaussianBlur(gray, (3, 3), 0)
            edges = cv2.Canny(g, 50, 150)
            edges = cv2.dilate(edges, np.ones((3, 3), np.uint8), iterations=1)
            lines = cv2.HoughLinesP(edges, 1, np.pi / 1800, threshold=120,
                                    minLineLength=max(30, min(bgr.shape[:2]) // 15),
                                    maxLineGap=10)
            angs: List[float] = []
            if lines is not None:
                L = lines.squeeze(axis=1) if lines.ndim == 3 else lines
                for x1, y1, x2, y2 in L:
                    dx, dy = (x2 - x1), (y2 - y1)
                    ang = 90.0 if dx == 0 else np.degrees(np.arctan2(dy, dx))
                    while ang <= -90: ang += 180
                    while ang > 90:   ang -= 180
                    if abs(ang) <= max_angle:
                        angs.append(float(ang))
            if angs:
                a = np.array(angs, dtype=np.float32)
                med = float(np.median(a))
                mad = float(np.median(np.abs(a - med)) + 1e-6)
                keep = np.abs(a - med) <= (3.5 * mad)
                a2 = a[keep] if keep.any() else a
                return float(np.median(a2))

            # fallback: minAreaRect
            _, bw = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
            bw = cv2.morphologyEx(bw, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8), iterations=1)
            cnts, _ = cv2.findContours(bw, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
            if not cnts:
                return None
            areas = [cv2.contourArea(c) for c in cnts]
            if not areas:
                return None
            thr = max(50.0, np.percentile(areas, 60))
            angs2: List[float] = []
            for c in cnts:
                if cv2.contourArea(c) < thr:
                    continue
                rect = cv2.minAreaRect(c)
                ang = rect[-1]  # [-90,0)
                if ang < -45:
                    ang = 90 + ang
                if abs(ang) <= max_angle:
                    angs2.append(float(ang))
            if angs2:
                return float(np.median(np.array(angs2, dtype=np.float32)))
            return None
        except Exception:
            return None

    # ---- ana akış ----
    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    out_images: List[np.ndarray] = []
    metas: List[Dict[str, Any]] = []
    doc_str = None

    # ---- PDF ----
    if ext == ".pdf":
        doc_str = "pdf_doc"
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                scale = pdf_dpi / 72.0
                pix = page.get_pixmap(matrix=fitz.Matrix(scale, scale), alpha=False, colorspace=fitz.csRGB)
                buf = np.frombuffer(pix.samples, dtype=np.uint8)
                if pix.n == 1:
                    arr = buf.reshape(pix.h, pix.w).copy()
                    arr = cv2.cvtColor(arr, cv2.COLOR_GRAY2RGB)
                elif pix.n == 3:
                    arr = buf.reshape(pix.h, pix.w, 3).copy()  # RGB
                else:
                    rgba = buf.reshape(pix.h, pix.w, pix.n)[:, :, :4].copy()
                    bgr0 = _rgba_to_bgr_on_white(rgba)
                # RGB->BGR
                if pix.n in (1, 3):
                    bgr0 = cv2.cvtColor(arr, cv2.COLOR_RGB2BGR) if return_bgr else arr

                src = "pdf_raster"
                dpi_xy = (pdf_dpi, pdf_dpi)
                mode = "BGR" if return_bgr else "RGB"

                # 1) EXIF (PDF yok) -> 0
                exif_deg_applied = 0

                # 2) OSD
                osd_deg, osd_c = _osd_estimate_angle(bgr0)
                ra_deg = 0
                if osd_deg is not None and (osd_c or 0) >= osd_conf:
                    ra_deg = _round_to_right_angle(osd_deg)
                bgr1 = _apply_right_angle(bgr0, ra_deg)

                # 3) Skew
                if estimate_skew:
                    skew_deg = _robust_skew_deg(bgr1, max_angle=skew_max_angle)
                else:
                    skew_deg = None
                deskew_deg = float(skew_deg or 0.0)
                bgr2 = _rotate_keep_bounds(bgr1, deskew_deg) if abs(deskew_deg) > 0.01 else bgr1

                _imshow(bgr2, f"PDF p{i} | after RA={ra_deg}°, deskew={deskew_deg:.2f}°")

                out_images.append(bgr2)
                metas.append({
                    "page_index": i,
                    "dpi": dpi_xy,
                    "shape": tuple(bgr2.shape),
                    "mode": mode,
                    "source": src,
                    "exif_orientation_applied_deg": int(exif_deg_applied),
                    "osd_raw_deg": (None if osd_deg is None else float(osd_deg)),
                    "osd_confidence": (None if osd_c is None else float(osd_c)),
                    "right_angle_applied_deg": int(ra_deg),
                    "skew_deg": (None if skew_deg is None else float(skew_deg)),
                    "deskew_applied_deg": float(deskew_deg),
                    "total_rotation_applied_deg": float(exif_deg_applied + ra_deg + deskew_deg),
                })
        finally:
            doc.close()

    # ---- TIFF ----
    elif ext in (".tif", ".tiff"):
        doc_str = "tiff_doc"

        def _proc_tiff_pages_with_tifffile(pth: Path):
            with tiff.TiffFile(pth.as_posix()) as tf:
                for i, pg in enumerate(tf.pages):
                    # Görüntü
                    arr = pg.asarray()
                    photometric = str(getattr(pg, "photometric", "") or "")
                    bgr0 = _ensure_bgr_safe(arr, photometric=photometric)

                    # DPI
                    dpi_xy = None
                    try:
                        xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
                        if xr and yr and ru:
                            def _rat(tag): num, den = tag.value; return float(num) / float(den)
                            x, y = _rat(xr), _rat(yr)
                            ru_val = getattr(ru, "value", ru)
                            if ru_val == 3:  # cm
                                x *= 2.54; y *= 2.54
                            dpi_xy = _normalize_dpi_tuple((int(round(x)), int(round(y))))
                    except Exception:
                        dpi_xy = None

                    # EXIF Orientation
                    exif_orient = None
                    try:
                        exif_orient = (pg.tags.get("Orientation") or {}).value
                    except Exception:
                        exif_orient = None

                    exif_deg_applied = 0
                    if apply_orientation:
                        bgr0, exif_deg_applied = _apply_exif_orientation(bgr0, exif_orient)

                    # OSD
                    osd_deg, osd_c = _osd_estimate_angle(bgr0)
                    ra_deg = 0
                    if osd_deg is not None and (osd_c or 0) >= osd_conf:
                        ra_deg = _round_to_right_angle(osd_deg)
                    bgr1 = _apply_right_angle(bgr0, ra_deg)

                    # Skew
                    if estimate_skew:
                        skew_deg = _robust_skew_deg(bgr1, max_angle=skew_max_angle)
                    else:
                        skew_deg = None
                    deskew_deg = float(skew_deg or 0.0)
                    bgr2 = _rotate_keep_bounds(bgr1, deskew_deg) if abs(deskew_deg) > 0.01 else bgr1

                    _imshow(bgr2, f"TIFF p{i} | after EXIF={exif_deg_applied}°, RA={ra_deg}°, deskew={deskew_deg:.2f}°")

                    out_images.append(bgr2)
                    metas.append({
                        "page_index": i,
                        "dpi": dpi_xy,
                        "shape": tuple(bgr2.shape),
                        "mode": "BGR",
                        "source": "tifffile",
                        "exif_orientation_applied_deg": int(exif_deg_applied),
                        "osd_raw_deg": (None if osd_deg is None else float(osd_deg)),
                        "osd_confidence": (None if osd_c is None else float(osd_c)),
                        "right_angle_applied_deg": int(ra_deg),
                        "skew_deg": (None if skew_deg is None else float(skew_deg)),
                        "deskew_applied_deg": float(deskew_deg),
                        "total_rotation_applied_deg": float(exif_deg_applied + ra_deg + deskew_deg),
                    })

        def _proc_tiff_pages_with_pillow(pth: Path):
            with Image.open(pth.as_posix()) as im:
                n = getattr(im, "n_frames", 1)
                for i in range(n):
                    im.seek(i)
                    frame = im.copy()
                    # EXIF orientation
                    exif_orient = None
                    try:
                        exif_orient = frame.getexif().get(274)
                    except Exception:
                        exif_orient = None

                    # normalize mod
                    if frame.mode in ("RGB", "RGBA", "L"):
                        safe = frame
                    elif frame.mode == "1":
                        safe = frame.convert("L")
                    else:
                        safe = frame.convert("RGB")
                    arr = np.array(safe)
                    bgr0 = _ensure_bgr_safe(arr, photometric=None)

                    exif_deg_applied = 0
                    if apply_orientation:
                        bgr0, exif_deg_applied = _apply_exif_orientation(bgr0, exif_orient)

                    osd_deg, osd_c = _osd_estimate_angle(bgr0)
                    ra_deg = 0
                    if osd_deg is not None and (osd_c or 0) >= osd_conf:
                        ra_deg = _round_to_right_angle(osd_deg)
                    bgr1 = _apply_right_angle(bgr0, ra_deg)

                    if estimate_skew:
                        skew_deg = _robust_skew_deg(bgr1, max_angle=skew_max_angle)
                    else:
                        skew_deg = None
                    deskew_deg = float(skew_deg or 0.0)
                    bgr2 = _rotate_keep_bounds(bgr1, deskew_deg) if abs(deskew_deg) > 0.01 else bgr1

                    _imshow(bgr2, f"TIFF p{i} | pillow | after EXIF={exif_deg_applied}°, RA={ra_deg}°, deskew={deskew_deg:.2f}°")

                    dpi_xy = _normalize_dpi_tuple(safe.info.get("dpi")) if isinstance(safe.info.get("dpi"), (tuple, list)) else None

                    out_images.append(bgr2)
                    metas.append({
                        "page_index": i,
                        "dpi": dpi_xy,
                        "shape": tuple(bgr2.shape),
                        "mode": "BGR",
                        "source": "pillow",
                        "exif_orientation_applied_deg": int(exif_deg_applied),
                        "osd_raw_deg": (None if osd_deg is None else float(osd_deg)),
                        "osd_confidence": (None if osd_c is None else float(osd_c)),
                        "right_angle_applied_deg": int(ra_deg),
                        "skew_deg": (None if skew_deg is None else float(skew_deg)),
                        "deskew_applied_deg": float(deskew_deg),
                        "total_rotation_applied_deg": float(exif_deg_applied + ra_deg + deskew_deg),
                    })

        try:
            if _HAS_TIFFFILE:
                _proc_tiff_pages_with_tifffile(p)
            else:
                _proc_tiff_pages_with_pillow(p)
        except Exception:
            # tifffile hata verirse pillow’a düş
            _proc_tiff_pages_with_pillow(p)

    else:
        raise ValueError(f"Unsupported extension: {ext}")

    res = {
        "path": str(p),
        "doc_str": doc_str,
        "page_count": len(out_images),
        "images": out_images,   # <-- Sayfa sayfa imajlar (BGR)
        "metas": metas
    }
    return res