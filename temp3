from typing import List, Tuple, Optional, Dict, Any, Callable
import re
import math

import numpy as np
import pandas as pd

try:
    # rapidfuzz is preferred for performance; fallback to difflib if absent
    from rapidfuzz import fuzz as _rf_fuzz
    def _similarity(a: str, b: str) -> float:
        return float(_rf_fuzz.token_set_ratio(a, b)) / 100.0
except Exception:
    import difflib
    def _similarity(a: str, b: str) -> float:
        return difflib.SequenceMatcher(None, a, b).ratio()

# ----------------------- TYPE ALIASES -----------------------
BoxWH = Tuple[int, int, int, int]   # (x, y, w, h)
BoxXY = Tuple[int, int, int, int]   # (l, t, r, b)


# ----------------------- CORE FUNCTION -----------------------
def build_per_box_df_onecall(
    lower_img: np.ndarray,
    final_boxes: List[BoxWH],
    sig_boxes: List[BoxWH],
    role_blocks: List[BoxWH],
    sermaye_boxes: List[BoxWH],
    known_names: List[str],
    *,
    lang: str = "tur+eng",
    role_threshold: float = 0.01,
    name_sim_threshold: float = 0.80,
    ocr_callback: Optional[Callable[[np.ndarray, BoxWH, int, int], str]] = None,
) -> pd.DataFrame:
    """
    Build a per-box DataFrame from final boxes using OCR.
    - final_boxes: list of (x,y,w,h) that broadly cover areas
    - role_blocks: finer boxes for role text; if contained in a final box, OCR prefers role box
    - sermaye_boxes: capital/amount boxes (used for loc detection only)
    - sig_boxes: signature boxes (sig flag only when fully contained)
    - known_names: list of reference names to stabilize matching

    Returns:
        pd.DataFrame with columns:
            ["i","bbox","loc","sig","role_best","role_score","name_in_box","text_preview"]
    """

    # ---------------- OCR WRAPPER ----------------
    # psm/oem are provided for compatibility. You can ignore them in your callback if unneeded.
    def _ocr_box(img: np.ndarray, box: BoxWH, psm: int = 11, oem: int = 1) -> str:
        if ocr_callback is not None:
            try:
                return ocr_callback(img, box, psm, oem) or ""
            except Exception:
                # fall through to default
                pass
        # default: try pytesseract
        try:
            import pytesseract
            from PIL import Image
            x, y, w, h = [int(v) for v in box]
            x = max(0, x); y = max(0, y)
            h_img, w_img = img.shape[:2]
            w = max(1, min(w, w_img - x))
            h = max(1, min(h, h_img - y))
            crop = img[y:y+h, x:x+w]
            if crop.ndim == 2:
                pil = Image.fromarray(crop)
            else:
                # assume BGR
                try:
                    import cv2
                    crop_rgb = cv2.cvtColor(crop, cv2.COLOR_BGR2RGB)
                except Exception:
                    crop_rgb = crop[:, :, ::-1] if crop.shape[-1] == 3 else crop
                pil = Image.fromarray(crop_rgb)
            cfg = f'--psm {int(psm)} --oem {int(oem)}'
            return pytesseract.image_to_string(pil, lang=lang, config=cfg) or ""
        except Exception:
            # last resort: dummy
            return ""

    # ---------------- BOX GEOMETRY ----------------
    def _xywh_to_xyxy(b: BoxWH) -> BoxXY:
        x, y, w, h = map(int, b)
        return (x, y, x + w, y + h)

    def _xyxy_to_xywh(b: BoxXY) -> BoxWH:
        l, t, r, bt = map(int, b)
        return (l, t, max(1, r - l), max(1, bt - t))

    def _expand_xyxy(b: BoxXY, pad: int = 1) -> BoxXY:
        l, t, r, bt = b
        return (l - pad, t - pad, r + pad, bt + pad)

    def _clip_xyxy_to_img(b: BoxXY, shape: Tuple[int, int]) -> BoxXY:
        H, W = int(shape[0]), int(shape[1])
        l, t, r, bt = b
        l = max(0, l); t = max(0, t)
        r = min(W, r); bt = min(H, bt)
        if r <= l: r = min(W, l + 1)
        if bt <= t: bt = min(H, t + 1)
        return (l, t, r, bt)

    def _iou_xyxy(a: BoxXY, b: BoxXY) -> float:
        ax1, ay1, ax2, ay2 = a
        bx1, by1, bx2, by2 = b
        ix1, iy1 = max(ax1, bx1), max(ay1, by1)
        ix2, iy2 = min(ax2, bx2), min(ay2, by2)
        iw, ih = max(0, ix2 - ix1), max(0, iy2 - iy1)
        inter = iw * ih
        if inter <= 0:
            return 0.0
        a_area = max(1, (ax2 - ax1)) * max(1, (ay2 - ay1))
        b_area = max(1, (bx2 - bx1)) * max(1, (by2 - by1))
        return inter / float(a_area + b_area - inter)

    def _contains_xyxy(outer: BoxXY, inner: BoxXY, pad: int = 0) -> bool:
        L, T, R, B = _expand_xyxy(outer, pad)
        l, t, r, bt = inner
        return (l >= L) and (t >= T) and (r <= R) and (bt <= B)

    # ---------------- TEXT UTILITIES ----------------
    _TR_CHARS = str.maketrans({
        "Ä°":"I","I":"I","Ä±":"i","Å":"S","Å":"s","Ä":"G","Ä":"g",
        "Ã":"U","Ã¼":"u","Ã":"O","Ã¶":"o","Ã":"C","Ã§":"c","Ã":"A","Ã¢":"a"
    })

    def _normalize_hard(s: str) -> str:
        s = s or ""
        s = s.replace("\u00A0", " ")  # nbsp
        s = re.sub(r"[âââââ]+", "-", s)  # normalize dashes
        s = re.sub(r"\s+", " ", s).strip()
        return s

    def _normalize_upper_tr(s: str) -> str:
        return _normalize_hard(s).translate(_TR_CHARS).upper()

    def _tokens_no_roles(name: str) -> str:
        # remove common role tokens from a name string
        if not name:
            return ""
        t = " " + _normalize_upper_tr(name) + " "
        role_terms = [
            "YONETIM", "KURULU", "BASKANI", "BASKAN", "UYESI", "UYE",
            "TOPLANTI", "BAÅKANI", "KATIP", "KATÄ°P", "MÃDÃR", "MUDUR",
            "GENEL", "MURAKIP", "OY", "TOPLAMA", "MEMURU", "DIVAN", "BAÅKAN VEKILI",
        ]
        for kw in role_terms:
            t = t.replace(" " + kw + " ", " ")
        t = re.sub(r"\s+", " ", t).strip()
        return t

    # ---------------- FIELD EXTRACTORS ----------------
    TCKN_RE = re.compile(r"(?<!\d)(\d{11}|\d{10})(?!\d)")

    def _find_tckn(txt: str) -> Optional[str]:
        m = TCKN_RE.search(txt or "")
        return m.group(1) if m else None

    AMOUNT_RE = re.compile(r"(?<!\d)(\d{1,3}(?:[\.\s]\d{3})*(?:[.,]\d+)?|\d+(?:[.,]\d+)?)(?!\d)")

    def _extract_amount_float(txt: str) -> Optional[float]:
        if not txt:
            return None
        m = AMOUNT_RE.search(txt.replace("\xa0", " "))
        if not m:
            return None
        raw = m.group(1).replace(" ", "").replace(".", "").replace(",", ".")
        try:
            return float(raw)
        except Exception:
            return None

    def _best_role_for_text(txt: str) -> Tuple[Optional[str], float]:
        """
        Very light rule-based role classification. Replace/extend as needed.
        Returns (role_key, score).
        """
        u = _normalize_upper_tr(txt)
        rules = [
            ("yk_baskani",       [r"YONETIM\s*KURULU\s*BASKANI", r"\bYK\b.*BASKAN"]),
            ("yk_uyesi",         [r"YONETIM\s*KURULU\s*UYESI", r"\bYK\b.*UYESI?"]),
            ("toplanti_baskani", [r"TOPLANTI\s*BASKANI", r"DIVAN\s*BASKANI"]),
            ("katip_uyesi",      [r"KATIP\s*UYESI", r"KATIP\b"]),
            ("oy_toplama",       [r"OY\s*TOPLAMA\s*MEMURU"]),
            ("genel_mudur",      [r"GENEL\s*MUDUR"]),
        ]
        for key, pats in rules:
            for p in pats:
                if re.search(p, u):
                    return key, 1.0
        return None, 0.0

    def _pick_name_from_text(txt: str, known: List[str]) -> Optional[str]:
        """
        Prefer exact/near-exact matches from known names; otherwise try to heuristically
        pull a candidate (capitalized tokens). You can replace this with your NER.
        """
        if not txt:
            return None
        # known list match
        best, best_s = None, 0.0
        for k in known or []:
            s = _similarity(txt, k)
            if s > best_s:
                best_s = s
                best = k
        if best and best_s >= 0.85:
            return best

        # Heuristic: pick top 2-3 consecutive capitalized Turkish names
        tokens = re.findall(r"[A-ZÃÄÄ°ÃÅÃ][a-zÃ§ÄÄ±Ã¶ÅÃ¼']{1,}(?:\s+[A-ZÃÄÄ°ÃÅÃ][a-zÃ§ÄÄ±Ã¶ÅÃ¼']{1,}){0,3}", txt)
        if tokens:
            # choose the longest
            tokens.sort(key=len, reverse=True)
            return tokens[0]
        return None

    def _sanitize_names(name: str, context_txt: str, known: List[str]) -> str:
        if not name:
            return ""
        name = _tokens_no_roles(name)
        name = re.sub(r"\s+", " ", name).strip()
        # clip trailing role-like suffix in context
        return name

    def _merge_name_tckn(name: str, tckn: Optional[str]) -> str:
        name = (name or "").strip()
        if not name and not tckn:
            return ""
        if name and tckn:
            return f"{name} ({tckn})"
        return name or (tckn or "")

    # ---------------- PSM/OEM POLICY ----------------
    def _decide_psm_oem(loc: str) -> Tuple[int, int]:
        if loc == "sermaye":
            return 1, 1
        if loc == "roles":
            return 11, 1
        return 11, 1

    # ---------------- CONVERT & FILTER BOX LISTS ----------------
    def _norm_xywh_list(lst: List[BoxWH]) -> List[BoxWH]:
        out: List[BoxWH] = []
        for b in lst or []:
            if not b:
                continue
            x, y, w, h = [int(v) for v in b]
            if w > 0 and h > 0:
                out.append((x, y, w, h))
        return out

    final_xywh = _norm_xywh_list(final_boxes)
    role_xywh  = _norm_xywh_list(role_blocks)
    serm_xywh  = _norm_xywh_list(sermaye_boxes)
    sig_xywh   = _norm_xywh_list(sig_boxes)

    final_xyxy = [_xywh_to_xyxy(b) for b in final_xywh]
    role_xyxy  = [_xywh_to_xyxy(b) for b in role_xywh]
    serm_xyxy  = [_xywh_to_xyxy(b) for b in serm_xywh]
    sig_xyxy   = [_xywh_to_xyxy(b) for b in sig_xywh]

    known_pool = list(dict.fromkeys(known_names or []))  # dedupe keep order

    # ---------------- ROLE ROI PICKER ----------------
    def _best_role_roi_for_final(final_xyxy: BoxXY) -> Optional[BoxWH]:
        """Choose the LARGEST role block fully contained by the final box (with small pad)."""
        best = None
        best_area = -1
        for r_wh, r_xy in zip(role_xywh, role_xyxy):
            if _contains_xyxy(final_xyxy, r_xy, pad=1):
                area = (r_xy[2] - r_xy[0]) * (r_xy[3] - r_xy[1])
                if area > best_area:
                    best_area = area
                    best = r_wh
        return best  # may be None

    # ---------------- MAIN LOOP ----------------
    rows: List[Dict[str, Any]] = []
    H, W = lower_img.shape[:2]

    for i, (b_wh, b_xyxy) in enumerate(zip(final_xywh, final_xyxy)):
        # 1) loc via containment
        has_role    = any(_contains_xyxy(b_xyxy, r, pad=1) for r in role_xyxy)
        has_sermaye = any(_contains_xyxy(b_xyxy, s, pad=1) for s in serm_xyxy)

        if has_role:
            loc = "roles"
        elif has_sermaye:
            loc = "sermaye"
        else:
            loc = "other"

        # 2) signature flag (containment only)
        sig = any(_contains_xyxy(b_xyxy, s, pad=1) for s in sig_xyxy)

        # 3) OCR ROI selection
        roi_wh = b_wh
        if loc == "roles":
            cand = _best_role_roi_for_final(b_xyxy)
            if cand is not None:
                roi_wh = cand

        # Clip ROI to image (safety)
        roi_xyxy = _clip_xyxy_to_img(_xywh_to_xyxy(roi_wh), (H, W))
        roi_wh = _xyxy_to_xywh(roi_xyxy)

        # 4) OCR
        psm0, oem0 = _decide_psm_oem(loc)
        text0 = _ocr_box(lower_img, roi_wh, psm=psm0, oem=oem0) or ""
        text_preview = re.sub(r"\s+", " ", text0).strip()[:200]

        # 5) Inference
        role_best, role_score = None, 0.0
        name_in_box: Optional[Any] = None

        if loc == "roles":
            # role label
            role_best, role_score = _best_role_for_text(text0)

            # name & tckn
            name0 = _pick_name_from_text(text0, known_pool)
            tckn0 = _find_tckn(text0)

            # fallback if weak
            need_fb = (not name0)
            if (not need_fb) and known_pool and name0:
                best_sim = max((_similarity(name0, k) for k in known_pool), default=0.0)
                if best_sim < float(name_sim_threshold):
                    need_fb = True

            if need_fb:
                text1 = _ocr_box(lower_img, roi_wh, psm=1, oem=1) or ""
                if len(text1) > len(text0):
                    text0 = text1
                    text_preview = re.sub(r"\s+", " ", text0).strip()[:200]
                    role_best, role_score = _best_role_for_text(text0)
                n2 = _pick_name_from_text(text0, known_pool)
                if n2:
                    name0 = n2
                t2 = _find_tckn(text0)
                if t2 and t2 != tckn0:
                    tckn0 = (tckn0 + "; " + t2) if tckn0 else t2

            clean_name = _sanitize_names(_tokens_no_roles(name0 or ""), text_preview, known_pool)
            name_in_box = _merge_name_tckn(clean_name, tckn0)

        elif loc == "sermaye":
            amount = _extract_amount_float(text0)
            if amount is None:
                text1 = _ocr_box(lower_img, b_wh, psm=1, oem=1) or ""
                if len(text1) > len(text0):
                    text0 = text1
                    text_preview = re.sub(r"\s+", " ", text0).strip()[:200]
                amount = _extract_amount_float(text0)
            if amount is not None and float(amount).is_integer():
                amount = int(amount)
            name_in_box = amount

        else:  # other
            name0 = _pick_name_from_text(text0, known_pool)
            tckn0 = _find_tckn(text0)
            if not name0:
                text1 = _ocr_box(lower_img, b_wh, psm=1, oem=1) or ""
                if len(text1) > len(text0):
                    text0 = text1
                    text_preview = re.sub(r"\s+", " ", text0).strip()[:200]
                    name0 = _pick_name_from_text(text0, known_pool)
                    t2 = _find_tckn(text0)
                    if t2 and t2 != tckn0:
                        tckn0 = (tckn0 + "; " + t2) if tckn0 else t2
            clean_name = _sanitize_names(name0 or "", text_preview, known_pool)
            name_in_box = _merge_name_tckn(clean_name, tckn0)

        # 6) append row
        rows.append({
            "i": i,
            "bbox": b_wh,
            "loc": loc,
            "sig": bool(sig),
            "role_best": role_best,
            "role_score": float(role_score),
            "name_in_box": name_in_box,
            "text_preview": text_preview,
        })

    # ---------------- RETURN DF ----------------
    return pd.DataFrame(rows, columns=[
        "i","bbox","loc","sig","role_best","role_score","name_in_box","text_preview"
    ])
