# -*- coding: utf-8 -*-
def extract_roles_and_bottom(
    lower_img,
    result,
    table_df_final,
    ocr_fn,                       # def ocr_fn(img, xywh, *, lang, psm, oem, url) -> str
    *,
    new_url=None,
    lang="tur+eng",
    psm_list=(11, 6),
    oem_list=(1, 3),
    known_names=None,
    role_threshold=0.60,
    soft_toplanti_floor=0.50,
    name_sim_threshold=0.88,
    force_margin_px=10,
    iou_thresh=0.25,
    debug=False,
):
    import re, unicodedata
    from typing import Any, Dict, List, Optional, Tuple
    import numpy as np
    import pandas as pd
    from rapidfuzz import fuzz

    # ---------------- text utils ----------------
    CONFUSION = str.maketrans({"0":"O","1":"I","5":"S","8":"B","€":"E","$":"S","@":"A"})
    ALT_MAP = {"Ş":"S","Ğ":"G","İ":"I","I":"I","Ü":"U","Ö":"O","Ç":"C",
               "ş":"s","ğ":"g","ı":"i","i":"i","ü":"u","ö":"o","ç":"c"}

    def tr_upper(s: str) -> str:
        return (s or "").replace("i","İ").replace("ı","I").upper()
    def tr_lower(s: str) -> str:
        return (s or "").replace("I","ı").replace("İ","i").lower()
    def tr_title(s: str) -> str:
        parts = re.split(r"(\s+)", s or ""); out=[]
        for w in parts:
            if not w or w.isspace(): out.append(w); continue
            out.append(tr_upper(w[:1]) + tr_lower(w[1:]))
        return "".join(out)
    def strip_diac(s: str) -> str:
        return "".join(c for c in unicodedata.normalize("NFD", s) if not unicodedata.combining(c))
    def canon_key(name: str) -> str:
        k = re.sub(r"[^A-ZÇĞIİÖŞÜ ]", " ", tr_upper(strip_diac(name or "")))
        toks = [t for t in k.split() if len(t) >= 2]
        return " ".join(toks)
    def norm_space(s: str) -> str:
        return re.sub(r"\s+", " ", (s or "").strip())
    def is_all_caps_ctx(s: str) -> bool:
        letters = re.findall(r"[A-ZÇĞIİÖŞÜ]", tr_upper(s or ""))
        total   = len(re.findall(r"[A-Za-zÇĞIİÖŞÜçğıişöü]", s or ""))
        return len(letters) >= max(1, int(0.8*total))

    def normalize_hard(s: str) -> str:
        if not s: return ""
        s = "".join(ALT_MAP.get(c, c) for c in s)
        s = unicodedata.normalize("NFD", s)
        s = "".join(c for c in s if not unicodedata.combining(c))
        s = s.translate(CONFUSION).upper()
        s = re.sub(r"[^A-Z0-9\s]", " ", s)
        s = re.sub(r"\s+", " ", s).strip()
        s = (s.replace("TOFLANI","TOPLANTI")
               .replace("TOPLANI","TOPLANTI")
               .replace("TOPLANT1","TOPLANTI"))
        s = (s.replace("BAS I","BASKANI")
               .replace("BASI","BASKANI")
               .replace("BAS.","BASKANI")
               .replace("BASKAN.","BASKANI"))
        s = (s.replace("Y0NETIM","YONETIM")
               .replace("YONET1M","YONETIM"))
        return s

    # ---------------- geometry ----------------
    def to_xywh(obj: Any) -> Optional[Tuple[int,int,int,int]]:
        if isinstance(obj, dict) and "bbox" in obj: obj = obj["bbox"]
        if isinstance(obj, (tuple, list, np.ndarray)) and len(obj)==4:
            x1,y1,a,b = [int(round(float(v))) for v in obj]
            if a>x1 and b>y1: return (x1,y1,a-x1,b-y1)  # xyxy
            return (x1,y1,a,b)
        if isinstance(obj, dict):
            if all(k in obj for k in ("x","y","w","h")):
                return (int(obj["x"]), int(obj["y"]), int(obj["w"]), int(obj["h"]))
            if all(k in obj for k in ("x0","y0","x1","y1")):
                x0,y0,x1,y1 = int(obj["x0"]),int(obj["y0"]),int(obj["x1"]),int(obj["y1"])
                return (x0,y0,x1-x0,y1-y0)
        if hasattr(obj, "__dict__"):
            def get(o,*n):
                for t in n:
                    if hasattr(o,t): return getattr(o,t)
                return None
            x=get(obj,"x","x0","left"); y=get(obj,"y","y0","top")
            w=get(obj,"w","width");     h=get(obj,"h","height")
            x1=get(obj,"x1","right");   y1=get(obj,"y1","bottom")
            if None not in (x,y,w,h):   return (int(x),int(y),int(w),int(h))
            if None not in (x,y,x1,y1): return (int(x),int(y),int(x1)-int(x),int(y1)-int(y))
        return None
    def xywh_to_xyxy(b): x,y,w,h=b; return (x,y,x+w,y+h)
    def expand_xyxy(b, m): x0,y0,x1,y1=b; return (x0-m, y0-m, x1+m, y1+m)
    def iou_xyxy(a, b):
        ax0,ay0,ax1,ay1=a; bx0,by0,bx1,by1=b
        ix=max(0, min(ax1,bx1)-max(ax0,bx0)); iy=max(0, min(ay1,by1)-max(ay0,by0))
        inter=ix*iy
        if inter<=0: return 0.0
        a_area=max(1,(ax1-ax0)*(ay1-ay0)); b_area=max(1,(bx1-bx0)*(by1-by0))
        return inter/(a_area+b_area-inter)
    def contains_xyxy(outer, inner, tol=0):
        ox0,oy0,ox1,oy1=outer; ix0,iy0,ix1,iy1=inner
        return (ix0>=ox0-tol and iy0>=oy0-tol and ix1<=ox1+tol and iy1<=oy1+tol)

    # ---------------- OCR wrapper ----------------
    def ocr_text(img, xywh, lang, psm_list, oem_list, url):
        x,y,w,h = xywh
        pad = max(3, int(0.04*max(w,h)))
        crop=(max(0,x-pad), max(0,y-pad),
              min(img.shape[1],x+w+pad)-max(0,x-pad),
              min(img.shape[0],y+h+pad)-max(0,y-pad))
        best=""; bestq=-1e9
        for psm in psm_list:
            for oem in oem_list:
                try:
                    txt=ocr_fn(img, crop, lang=lang, psm=psm, oem=oem, url=url)
                except Exception:
                    txt=""
                q = len(re.findall(r"[A-Za-zÇĞIİÖŞÜçğışöü]", txt)) - 2*len(re.findall(r"[^\w\s]", txt))
                if q>bestq: bestq, best = q, txt
        return best

    # ---------------- role detection ----------------
    ROLE_WORD_SET = {
        "TOPLANTI","BASKANI","BAKANLIK","TEMSILCISI","YK","YONETIM","KURULU",
        "UYESI","YAZMAN","KATIP","DIVAN","SERMAYESI","NISABI","PAY","TOPLAMI"
    }

    YKBASKANI_RE   = re.compile(r"\b(?:YK|YONETIM\s+KURULU)\s*BASKANI\b")
    YKUYESI_RE     = re.compile(r"\b(?:YK|YONETIM\s+KURULU)\s*UYESI\b")
    TOPBASKANI_RE  = re.compile(r"\bTOPLANTI\s*BASKANI\b")
    BAKTEMS_RE     = re.compile(r"\b(?:TICARET\s+BAKANLIGI|BAKANLIK)\s*TEMSILCISI\b")
    SERMAYE_RE     = re.compile(r"\bSERMAYESI\b|\bNISABI\b|\bPAYLARIN\s+TOPLAMI\b")

    def regex_role(text: str):
        t = normalize_hard(text)
        if YKBASKANI_RE.search(t):  return ("yk_baskani", 1.0, "regex")
        if YKUYESI_RE.search(t):    return ("yk_uyesi", 1.0, "regex")
        if TOPBASKANI_RE.search(t): return ("toplanti_baskani", 1.0, "regex")
        if BAKTEMS_RE.search(t):    return ("bakanlik_temsilcisi", 1.0, "regex")
        if SERMAYE_RE.search(t) and any(ch.isdigit() for ch in t):
            return ("sermaye", 0.95, "regex+digits")
        return (None, 0.0, "")

    ROLE_ALIASES = {
        "toplanti_baskani": ["TOPLANTI BASKANI","TOPLANTI BSK","TOPLANTI BASKAN","TOPLANTI BASKAN I"],
        "bakanlik_temsilcisi": ["BAKANLIK TEMSILCISI","TICARET BAKANLIGI TEMSILCISI"],
        "yk_baskani": ["YK BASKANI","YONETIM KURULU BASKANI","YK BSK","YONETIM KURULU BASI","YK BASI","YONETIM KURULU BAS I"],
        "yk_uyesi": ["YK UYESI","YONETIM KURULU UYESI","YK UYE"],
        "tutanak_yazmani": ["TUTANAK YAZMANI","YAZMAN"],
        "katip": ["KATIP","OY TOPLAMA MEMURU","OY TOPLAYICI"],
        "divan_baskani": ["DIVAN BASKANI","DIVAN BSK"],
        "sermaye": ["SIRKETIN SERMAYESI","SERMAYESI VE PAYLARIN TOPLAMI ITIBARI DEGERI","ASGARI TOPLANTI NISABI","MEVCUT TOPLANTI NISABI"],
    }

    def gen_ngrams(tokens, nmin=1, nmax=5):
        L=len(tokens)
        for n in range(nmin, min(nmax, L)+1):
            for i in range(0, L-n+1):
                yield " ".join(tokens[i:i+n])

    def fuzzy_best_role(text: str):
        r_rgx, sc_rgx, why_rgx = regex_role(text)
        if r_rgx: return r_rgx, sc_rgx, why_rgx

        t = normalize_hard(text); toks = t.split()
        has_top = max(fuzz.partial_ratio("TOPLANTI", t), fuzz.token_set_ratio("TOPLANTI", t))/100.0
        has_bsk = max(fuzz.partial_ratio("BASKANI", t), fuzz.partial_ratio("BASKAN", t))/100.0
        has_yk  = max(fuzz.partial_ratio("YK", t), fuzz.token_set_ratio("YONETIM KURULU", t))/100.0
        has_uye = max(fuzz.partial_ratio("UYESI", t), fuzz.token_set_ratio("UYESI", t))/100.0

        best_role, best_score, why = None, 0.0, ""
        for role, aliases in ROLE_ALIASES.items():
            alias_full = max(fuzz.token_set_ratio(t, a) for a in aliases)/100.0
            ng_best = 0.0
            for ng in gen_ngrams(toks, 1, 5):
                ng_best = max(ng_best, max(fuzz.token_set_ratio(ng, a) for a in aliases)/100.0)
            sc = max(alias_full, ng_best)

            if role == "toplanti_baskani" and min(has_top, has_bsk) >= 0.72:
                sc = max(sc, 0.90); why = "co-occur(TOPLANTI+BASKANI)"
            if role == "yk_baskani":
                if min(has_yk, has_bsk) >= 0.68:
                    sc = max(sc, 0.92); why = "co-occur(YK+BAŞKAN)"
                if has_uye >= 0.70:
                    sc = max(0.0, sc - 0.18)
            if role == "yk_uyesi":
                if has_uye >= 0.75:
                    sc = max(sc, 0.88); why = "token(UYESI)"
                if has_bsk >= 0.70:
                    sc = max(0.0, sc - 0.22)
            if role == "sermaye" and any(ch.isdigit() for ch in t):
                sc = max(sc, sc + 0.05)

            if sc > best_score:
                best_role, best_score, why = role, sc, (why or f"alias/ngram:{sc:.2f}")

        if best_score >= role_threshold:
            return best_role, best_score, why
        if best_role == "toplanti_baskani" and best_score >= soft_toplanti_floor and min(has_top, has_bsk) >= 0.70:
            return best_role, best_score, "soft-assign(toplanti+baskan)"
        return None, best_score, "low-score"

    def why_hint_role(why: str) -> Optional[str]:
        w = normalize_hard(why or "")
        if "YK+BASKAN" in w: return "yk_baskani"
        if "TOPLANTI+BASKANI" in w or "TOPLANTI+BASKAN" in w: return "toplanti_baskani"
        return None

    # ---------------- known names canon ----------------
    if known_names is None:
        pools=[]
        for c in ["pay_sahibinin_ad_soyadi_unvani","temsilci_adi_soyadi_unvani"]:
            if c in table_df_final.columns:
                pools.append(table_df_final[c].dropna().astype(str))
        known_names = pd.concat(pools).dropna().astype(str).unique().tolist() if pools else []
    KN_CANON={}
    for kn in known_names:
        k=canon_key(kn)
        if k and (k not in KN_CANON or len(KN_CANON[k])<len(kn)): KN_CANON[k]=kn

    # ---------------- role blocks (result["roles"]) ----------------
    role_blocks=[]
    for rb in (result.get("roles") or []):
        b = to_xywh(rb if not (isinstance(rb,dict) and "bbox" in rb) else rb["bbox"])
        if not b: continue
        txt = (rb.get("txt") if isinstance(rb, dict) else getattr(rb, "txt", None))
        if not txt or not txt.strip():
            txt = ocr_text(lower_img, b, lang, psm_list, oem_list, new_url)
        r, sc, why = fuzzy_best_role(txt)
        hint = why_hint_role(why)
        if hint and hint != r:
            r = hint; sc = max(sc, 0.93); why = (why or "") + "|why2role(%s)" % hint
        if r:
            role_blocks.append({"bbox": b, "role": r, "score": sc, "txt": txt, "why": why})

    # şablon düzeltme: aynı satırda sağ uç genelde yk_baskani, orta bakanlik
    def row_cluster(blocks, y_tol_frac=0.05):
        if not blocks: return []
        H, _ = lower_img.shape[:2]
        tol = max(6, int(H*y_tol_frac))
        items=[]
        for rb in blocks:
            x,y,w,h = rb["bbox"]; cy = y + h//2; cx = x + w//2
            items.append((cy, cx, rb))
        items.sort()
        rows=[]
        for cy, cx, rb in items:
            placed=False
            for row in rows:
                if abs(row["cy"]-cy) <= row["tol"]:
                    row["items"].append((cx, rb)); placed=True; break
            if not placed:
                rows.append({"cy": cy, "tol": tol, "items":[(cx, rb)]})
        for row in rows:
            row["items"].sort(key=lambda t: t[0])
        return rows

    rows = row_cluster(role_blocks)
    for row in rows:
        if len(row["items"]) < 2: continue
        _, rb_right = row["items"][-1]
        t_right = normalize_hard(rb_right.get("txt",""))
        if (YKBASKANI_RE.search(t_right) or ("YK" in t_right and "BASKANI" in t_right and "UYESI" not in t_right)):
            rb_right["role"] = "yk_baskani"; rb_right["why"] = (rb_right.get("why","")+"|layout(rightmost)+regex").strip("|")
        if len(row["items"]) >= 3:
            _, rb_mid = row["items"][1]
            t_mid = normalize_hard(rb_mid.get("txt",""))
            if ("BAKANLIK" in t_mid or "TICARET" in t_mid) and "TEMSILCISI" in t_mid:
                rb_mid["role"] = "bakanlik_temsilcisi"; rb_mid["why"] = (rb_mid.get("why","")+"|layout(center)").strip("|")

    # ---------------- final boxes normalize ----------------
    def normalize_with_ref(seq):
        out=[]
        if seq is None: return out
        try: it=list(seq)
        except Exception: it=[seq]
        for item in it:
            xywh = to_xywh(item if not (isinstance(item,dict) and "bbox" in item) else item["bbox"])
            if xywh and xywh[2]>0 and xywh[3]>0: out.append((xywh, item))
        return out

    pairs = normalize_with_ref(result.get("final") or result.get("roles") or [])
    boxes_xywh = [p[0] for p in pairs]
    objs        = [p[1] for p in pairs]
    boxes_xyxy  = [xywh_to_xyxy(b) for b in boxes_xywh]

    sigs=[]
    for sb in result.get("sigs", []) or []:
        b = to_xywh(sb if not (isinstance(sb,dict) and "bbox" in sb) else sb["bbox"])
        if b: sigs.append(xywh_to_xyxy(b))

    ROLE_PRIORITY_ORDER = {
        "yk_baskani": 5, "bakanlik_temsilcisi": 4, "toplanti_baskani": 3,
        "yk_uyesi": 2, "tutanak_yazmani": 1, "katip": 1, "divan_baskani": 1,
        "sermaye": 0, None: -1,
    }

    # ---------------- per-box ----------------
    rows_out=[]
    for i,(xywh,xyxy,obj) in enumerate(zip(boxes_xywh, boxes_xyxy, objs)):
        obj_txt=None
        if isinstance(obj, dict): obj_txt=obj.get("txt")
        if (obj_txt is None) and hasattr(obj,"txt"): obj_txt=getattr(obj,"txt")
        text = obj_txt if (obj_txt and obj_txt.strip()) else ocr_text(lower_img, xywh, lang, psm_list, oem_list, new_url)
        text = norm_space(text)

        r_rgx, sc_rgx, _ = regex_role(text)

        # roleblock eşleştirme
        box_exp_xyxy = expand_xyxy(xywh_to_xyxy(xywh), force_margin_px)
        cands=[]
        for rb in role_blocks:
            rb_xyxy = xywh_to_xyxy(rb["bbox"])
            iou = iou_xyxy(rb_xyxy, box_exp_xyxy)
            if contains_xyxy(rb_xyxy, box_exp_xyxy, tol=0) or iou >= iou_thresh:
                bx=(box_exp_xyxy[0]+box_exp_xyxy[2])/2.0; by=(box_exp_xyxy[1]+box_exp_xyxy[3])/2.0
                rx=(rb_xyxy[0]+rb_xyxy[2])/2.0; ry=(rb_xyxy[1]+rb_xyxy[3])/2.0
                dist = (bx-rx)**2 + (by-ry)**2
                hint = why_hint_role(rb.get("why",""))
                cands.append({
                    "rb": rb, "iou": iou, "dist": dist,
                    "score": rb.get("score", 0.0),
                    "role": rb.get("role"),
                    "hint": hint, "hint_bonus": 1.0 if hint else 0.0,
                    "prio": ROLE_PRIORITY_ORDER.get(rb.get("role"), -1),
                    "regex_bonus": 1.0 if (r_rgx and rb.get("role")==r_rgx) else 0.0,
                    "why": rb.get("why","")
                })

        forced=None; chosen=None; reasons=[]
        if cands:
            cands.sort(key=lambda c: (-c["iou"], -c["regex_bonus"], -c["hint_bonus"], -c["prio"], -c["score"], c["dist"]))
            chosen = cands[0]
            forced = chosen["role"]
            reasons.append(f"roleblock+occur iou={chosen['iou']:.2f} {chosen['why']}")

        if forced is None:
            if r_rgx:
                role_best, role_score = r_rgx, max(sc_rgx, 0.95)
                reasons.append("regex")
            else:
                r_fz, sc_fz, why_fz = fuzzy_best_role(text)
                hint_fz = why_hint_role(why_fz)
                if hint_fz and hint_fz != r_fz:
                    role_best, role_score = hint_fz, max(sc_fz, 0.93)
                    reasons.append(f"{why_fz}|why->role({r_fz}->{hint_fz})")
                else:
                    role_best, role_score = r_fz, sc_fz
                    reasons.append(why_fz)
        else:
            hint_rb = chosen.get("hint")
            if hint_rb and hint_rb != forced:
                role_best, role_score = hint_rb, 0.99
                reasons.append(f"why-override({forced}->{hint_rb})")
            elif r_rgx in {"yk_baskani","toplanti_baskani","yk_uyesi","bakanlik_temsilcisi","sermaye"} and r_rgx != forced:
                role_best, role_score = r_rgx, max(sc_rgx, 0.98)
                reasons.append(f"regex-override({forced}->{r_rgx})")
            else:
                role_best, role_score = forced, 1.0

        # -------- isim & TCKN çıkarımı (rol-özel) --------
        U = normalize_hard(text)

        ROLE_AFTER_PAT = {
            "toplanti_baskani": re.compile(r"(?:TOPLANTI)\s*BASKAN[II]?\s+([A-ZÇĞIİÖŞÜ]{2,}(?:\s+[A-ZÇĞIİÖŞÜ]{2,}){1,2})"),
            "yk_baskani":       re.compile(r"(?:YK|YONETIM\s+KURULU)\s*BASKAN[II]?\s+([A-ZÇĞIİÖŞÜ]{2,}(?:\s+[A-ZÇĞIİÖŞÜ]{2,}){1,2})"),
            "yk_uyesi":         re.compile(r"(?:YK|YONETIM\s+KURULU)\s*UYES[II]\s+([A-ZÇĞIİÖŞÜ]{2,}(?:\s+[A-ZÇĞIİÖŞÜ]{2,}){1,2})"),
            "bakanlik_temsilcisi": re.compile(r"(?:TICARET\s+BAKANLIGI|BAKANLIK)\s*TEMSILCIS[II]\s+([A-ZÇĞIİÖŞÜ]{2,}(?:\s+[A-ZÇĞIİÖŞÜ]{2,}){1,2})"),
            "tutanak_yazmani":  re.compile(r"TUTANAK\s*YAZMAN[II]\s+([A-ZÇĞIİÖŞÜ]{2,}(?:\s+[A-ZÇĞIİÖŞÜ]{2,}){1,2})"),
            "katip":            re.compile(r"KAT[II]P\s+([A-ZÇĞIİÖŞÜ]{2,}(?:\s+[A-ZÇĞIİÖŞÜ]{2,}){1,2})"),
            "divan_baskani":    re.compile(r"DIVAN\s*BASKAN[II]\s+([A-ZÇĞIİÖŞÜ]{2,}(?:\s+[A-ZÇĞIİÖŞÜ]{2,}){1,2})"),
        }

        def role_specific_pick(role: Optional[str], Utext: str) -> Optional[str]:
            if not role or role == "sermaye": return None
            pat = ROLE_AFTER_PAT.get(role); 
            if not pat: return None
            m = pat.search(Utext); 
            return m.group(1) if m else None

        # TCKN adayı (10–11 digit; TCKN 11’dir ama bazı formlarda 10 da gelebiliyor)
        tckn = None
        for m in re.finditer(r"\b\d{10,11}\b", U):
            tckn = m.group(0)
            # gürültülü toplamlardan kaçın: yanında 'TL','DEGER' gibi şeyler varsa alma
            window = U[max(0, m.start()-10): m.end()+10]
            if not re.search(r"(TL|DEGER|TOPLAM|PAY|HISSE)", window):
                break
        if tckn and len(tckn)==10:  # 10 haneli ise çoğu zaman sicil/ID; yine de döndürelim
            pass

        def scrub_roles_for_name(t: str) -> str:
            tU = normalize_hard(t)
            tU = re.sub(r"(?:TOPLANTI)\s*BASKAN[II]?", " ", tU)
            tU = re.sub(r"(?:YK|YONETIM\s+KURULU)\s*BASKAN[II]?", " ", tU)
            tU = re.sub(r"(?:YK|YONETIM\s+KURULU)\s*UYES[II]", " ", tU)
            tU = re.sub(r"(?:TICARET\s+BAKANLIGI|BAKANLIK)\s*TEMSILCIS[II]", " ", tU)
            tU = re.sub(r"TUTANAK\s*YAZMAN[II]", " ", tU)
            tU = re.sub(r"KAT[II]P", " ", tU)
            tU = re.sub(r"DIVAN\s*BASKAN[II]", " ", tU)
            tU = re.sub(r"\b(TOPLANTI|BASKANI|YK|YONETIM|KURULU|UYESI|BAKANLIK|TICARET|TEMSILCISI|KATIP|YAZMANI|DIVAN|SERMAYESI|NISABI|PAY|TOPLAMI)\b"," ", tU)
            tU = re.sub(r"\b\d{6,}\b"," ", tU)  # uzun ID’ler
            return norm_space(tU)

        # Aday isimler: önce rol-özel, sonra fallback
        candidates = []
        picked_upper = role_specific_pick(role_best, U)
        if picked_upper: candidates.append(picked_upper)

        if not candidates:
            cleaned_txt = scrub_roles_for_name(text)
            NU = normalize_hard(cleaned_txt)
            for m in re.finditer(r"\b([A-ZÇĞIİÖŞÜ]{2,}(?:\s+[A-ZÇĞIİÖŞÜ]{2,}){1,2})\b", NU):
                candidates.append(m.group(1))
            for m in re.finditer(r"\b([A-ZÇĞIİÖŞÜ][a-zçğıiöşü’']+(?:\s+[A-ZÇĞIİÖŞÜ][a-zçğıiöşü’']+){1,2})\b", cleaned_txt):
                candidates.append(m.group(1))

        # filtre: yalnız 2–3 kelime, sadece harf içeren tokenlar
        def valid_person_name(s: str) -> bool:
            toks = [t for t in re.split(r"\s+", s.strip()) if t]
            if not (2 <= len(toks) <= 3): return False
            for t in toks:
                if len(strip_diac(t)) < 2: return False
                if not re.match(r"^[A-Za-zÇĞİÖŞÜçğıöşü’']+$", t): return False
            return True

        final=[]
        for c in candidates:
            if not valid_person_name(c): 
                continue
            key = canon_key(c)
            best = KN_CANON.get(key)
            if not best:
                for k,v in KN_CANON.items():
                    if fuzz.token_set_ratio(key, k)/100.0 >= name_sim_threshold:
                        best = v; break
            if not best:
                best = tr_title(" ".join(re.split(r"\s+", c.strip())))
            if any(tok in ROLE_WORD_SET for tok in normalize_hard(best).split()):
                continue
            best = tr_upper(best) if is_all_caps_ctx(text) else best
            final.append(best)

        # de-dup
        seen=set(); uni=[]
        for n in final:
            k=canon_key(n)
            if k not in seen:
                seen.add(k); uni.append(n)

        sig_hit = any(
            (max(xywh_to_xyxy(xywh)[0], s[0]) < min(xywh_to_xyxy(xywh)[2], s[2]) and
             max(xywh_to_xyxy(xywh)[1], s[1]) < min(xywh_to_xyxy(xywh)[3], s[3]))
            for s in sigs
        )

        rows_out.append({
            "i": i,
            "bbox": xywh,
            "sig": sig_hit,
            "role_best": role_best,
            "role_score": float(role_score),
            "role_reasons": ";".join([r for r in reasons if r]),
            "name_in_box": "; ".join(uni) if uni else None,
            "tckn_in_box": tckn,
            "text_preview": text[:220],
        })

    per_box_df = pd.DataFrame(
        rows_out,
        columns=["i","bbox","sig","role_best","role_score","role_reasons","name_in_box","tckn_in_box","text_preview"]
    )

    # ---------------- per-role name de-dup ----------------
    def _lastname(s: str) -> str:
        toks = canon_key(s).split()
        return toks[-1] if toks else ""
    def dedupe_within_role_strict(df: pd.DataFrame) -> pd.DataFrame:
        out = []; seen = {}
        for _, r in df.iterrows():
            role = r.get("role_best"); names = r.get("name_in_box")
            if not role or not isinstance(names, str) or not names.strip():
                out.append(names); continue
            kept = seen.setdefault(role, [])
            curr = []
            for nm in [p.strip() for p in names.split(";") if p.strip()]:
                add = True
                ck = canon_key(nm); ln = _lastname(nm)
                for prev in kept:
                    if canon_key(prev) == ck:
                        add=False; break
                    if _lastname(prev) == ln:
                        fn1 = " ".join(canon_key(nm).split()[:-1])
                        fn2 = " ".join(canon_key(prev).split()[:-1])
                        if fn1 and fn2 and fuzz.ratio(fn1, fn2) >= 98:
                            add=False; break
                if add:
                    kept.append(nm); curr.append(nm)
            out.append("; ".join(curr) if curr else None)
        df = df.copy(); df["name_in_box"] = out
        return df

    per_box_df = dedupe_within_role_strict(per_box_df)

    # ---------------- sermaye ----------------
    sermaye=None
    if "sermaye" in result and result["sermaye"] is not None:
        s_txt = getattr(result["sermaye"], "txt", None) if hasattr(result["sermaye"], "__dict__") \
                else (result["sermaye"].get("txt") if isinstance(result["sermaye"], dict) else None)
        if s_txt:
            m = re.search(r"(\d{1,3}(?:\.\d{3})+)", s_txt)
            if m: sermaye = int(m.group(1).replace(".",""))
    if sermaye is None:
        previews = " ".join(per_box_df["text_preview"].fillna("").tolist())
        m = re.search(r"(\d{1,3}(?:\.\d{3})+)", previews)
        if m: sermaye = int(m.group(1).replace(".",""))
    if sermaye is None and "paylarin_toplam_itibari_degeri(tl)" in getattr(table_df_final, "columns", []):
        try:
            sermaye = int(pd.to_numeric(table_df_final["paylarin_toplam_itibari_degeri(tl)"], errors="coerce").fillna(0).sum())
        except Exception:
            pass

    # ---------------- bottom_df ----------------
    out = {
        "sermaye_toplam_tl": sermaye,
        "toplanti_baskani_ad_soyad": None, "toplanti_baskani_imza_var_mi": None, "toplanti_baskani_tckn": None,
        "tutanak_yazmani_ad_soyad":  None, "tutanak_yazmani_imza_var_mi":  None, "tutanak_yazmani_tckn": None,
        "bakanlik_temsilcisi_ad_soyad": None, "bakanlik_temsilcisi_imza_var_mi": None, "bakanlik_temsilcisi_tckn": None,
        "yk_uyesi_ad_soyad": None, "yk_uyesi_imza_var_mi": None, "yk_uyesi_tckn": None,
        "yk_baskani_ad_soyad": None, "yk_baskani_imza_var_mi": None, "yk_baskani_tckn": None,
        "katip_ad_soyad": None, "katip_imza_var_mi": None, "katip_tckn": None,
        "divan_baskani_ad_soyad": None, "divan_baskani_imza_var_mi": None, "divan_baskani_tckn": None,
    }
    name_cols = {
        "toplanti_baskani":"toplanti_baskani_ad_soyad",
        "tutanak_yazmani":"tutanak_yazmani_ad_soyad",
        "bakanlik_temsilcisi":"bakanlik_temsilcisi_ad_soyad",
        "yk_uyesi":"yk_uyesi_ad_soyad",
        "yk_baskani":"yk_baskani_ad_soyad",
        "katip":"katip_ad_soyad",
        "divan_baskani":"divan_baskani_ad_soyad",
    }
    sig_cols = {k: v.replace("_ad_soyad","_imza_var_mi") for k,v in name_cols.items()}
    tckn_cols = {k: v.replace("_ad_soyad","_tckn") for k,v in name_cols.items()}

    for _,r in per_box_df.iterrows():
        role=r.get("role_best")
        if not role or role=="sermaye": continue
        ncol=name_cols.get(role); scol=sig_cols.get(role); tcol=tckn_cols.get(role)

        # ad-soyad listesi
        raw=r.get("name_in_box")
        if isinstance(raw, str) and ";" in raw:
            parts=[p.strip() for p in raw.split(";") if p.strip()]
        elif isinstance(raw, str) and raw.strip():
            parts=[raw.strip()]
        else:
            parts=[]

        # sadece 2–3 kelimelik isimleri tut
        parts=[p for p in parts if 2 <= len(p.split()) <= 3]

        if not parts and role!="yk_uyesi":
            pass
        elif role=="yk_uyesi":
            out[ncol] = (out[ncol]+"; "+"; ".join(parts)) if out[ncol] else ("; ".join(parts) if parts else out[ncol])
        else:
            if out[ncol] is None and parts: out[ncol] = "; ".join(parts)

        if scol and out[scol] is None:
            out[scol] = bool(r.get("sig"))

        # tckn
        tckn_val = r.get("tckn_in_box")
        if tcol and tckn_val and (10 <= len(str(tckn_val)) <= 11):
            out[tcol] = tckn_val if (out.get(tcol) in (None, "")) else out[tcol]

    bottom_df = pd.DataFrame([out])

    if debug:
        try:
            from IPython.display import display
            print(f"[INFO] role_blocks={len(role_blocks)}, boxes={len(per_box_df)}")
            if role_blocks:
                display(pd.DataFrame([{"role":rb["role"], "score":rb["score"], "bbox":rb["bbox"],
                                       "txt":str(rb.get('txt',''))[:90], "why":rb.get("why","")} for rb in role_blocks]))
            display(per_box_df); display(bottom_df)
        except Exception:
            pass

    return per_box_df, bottom_df