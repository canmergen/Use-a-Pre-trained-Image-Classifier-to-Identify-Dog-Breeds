# --- Robust signature detection from numpy array (2-pass) ---

from dataclasses import dataclass
from typing import List, Tuple, Optional
import cv2, numpy as np

BBox = Tuple[int,int,int,int]  # (x,y,w,h)

@dataclass
class _Params:
    target_height: int = 1600
    include_stamps: bool = True
    nms_iou: float = 0.25
    min_aspect: float = 1.05
    max_aspect: float = 20.0
    min_ink_ratio: float = 0.02
    max_solid: float = 0.975
    max_circularity_for_signature: float = 0.90

def _to_gray_any(img: np.ndarray) -> np.ndarray:
    if img is None:
        raise ValueError("img is None")
    if img.dtype != np.uint8:
        if img.dtype in (np.float32, np.float64):
            img = np.clip(img, 0, 1)
            img = (img * 255).astype(np.uint8)
        else:
            img = img.astype(np.uint8)
    if img.ndim == 2:
        return img
    if img.ndim == 3 and img.shape[2] == 3:
        return cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    if img.ndim == 3 and img.shape[2] == 4:
        return cv2.cvtColor(img, cv2.COLOR_BGRA2GRAY)
    raise ValueError(f"Unsupported image shape {img.shape}")

def _resize_keep_aspect(img: np.ndarray, target_h: int):
    h, w = img.shape[:2]
    scale = target_h / float(h)
    if abs(scale - 1.0) < 1e-3:
        return img.copy(), 1.0
    new_w = max(1, int(round(w * scale)))
    new_h = max(1, int(round(h * scale)))
    return cv2.resize(img, (new_w, new_h), interpolation=cv2.INTER_LINEAR), scale

def _binarize(gray: np.ndarray) -> np.ndarray:
    _, bw = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    return 255 - bw  # ink=255

def _remove_lines(ink: np.ndarray) -> np.ndarray:
    work = ink.copy()
    edges = cv2.Canny(work, 50, 150, apertureSize=3)
    lines = cv2.HoughLinesP(edges, 1, np.pi/180, threshold=120, minLineLength=80, maxLineGap=4)
    if lines is not None:
        for x1,y1,x2,y2 in lines[:,0]:
            cv2.line(work, (x1,y1), (x2,y2), 0, 5)
    return work

def _morph_refine(ink: np.ndarray) -> np.ndarray:
    k_close = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))
    k_open  = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3,3))
    closed  = cv2.morphologyEx(ink, cv2.MORPH_CLOSE, k_close, 1)
    opened  = cv2.morphologyEx(closed, cv2.MORPH_OPEN,  k_open,  1)
    return opened

def _estimate_min_area(mask: np.ndarray) -> int:
    bin_ = (mask > 0).astype(np.uint8)
    num, _, stats, _ = cv2.connectedComponentsWithStats(bin_, connectivity=8)
    areas, dims = [], []
    for i in range(1, num):
        x, y, w, h, a = stats[i]
        if w > 1 and h > 1:
            areas.append(int(a)); dims.append((w, h))
    if not areas:
        return 96
    areas = np.array(areas, np.float32)
    loga = np.log(areas + 1.0).astype(np.float32)
    loga_norm = cv2.normalize(loga, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
    otsu, _ = cv2.threshold(loga_norm, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)
    alpha = float(otsu) / 255.0
    log_thr = float(loga.min()) + (float(loga.max()) - float(loga.min())) * alpha
    area_otsu = max(1.0, float(np.exp(log_thr) - 1.0))
    dims_arr = np.array(dims, np.float32)
    sw_est = float(np.median(dims_arr.min(1)))
    area_floor = (max(1.0, sw_est) * 6.0) ** 2
    return int(max(area_otsu * 1.3, area_floor, 96.0))

def _component_features(mask: np.ndarray, x: int, y: int, w: int, h: int):
    roi = mask[y:y+h, x:x+w]
    area = int(np.count_nonzero(roi))
    ink_ratio = area / float(max(1, w*h))
    cnts, _ = cv2.findContours(roi, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts:
        return area, ink_ratio, 1.0, 1.0
    cnt = max(cnts, key=cv2.contourArea)
    hull = cv2.convexHull(cnt)
    ca = cv2.contourArea(cnt); ha = max(1.0, cv2.contourArea(hull))
    solidity = ca / ha
    per = cv2.arcLength(cnt, True)
    circularity = (4.0*np.pi*ca) / (per*per + 1e-6)
    return area, ink_ratio, solidity, circularity

def _nms(boxes: List[Tuple[int,int,int,int]], scores: np.ndarray, iou_thr: float):
    if not boxes: return []
    b = np.array(boxes, np.float32)
    x1,y1,x2,y2 = b[:,0],b[:,1],b[:,2],b[:,3]
    areas = (x2-x1+1)*(y2-y1+1)
    order = scores.argsort()[::-1]
    keep = []
    while order.size>0:
        i = order[0]
        keep.append(i)
        xx1 = np.maximum(x1[i], x1[order[1:]])
        yy1 = np.maximum(y1[i], y1[order[1:]])
        xx2 = np.minimum(x2[i], x2[order[1:]])
        yy2 = np.minimum(y2[i], y2[order[1:]])
        w = np.maximum(0.0, xx2-xx1+1); h = np.maximum(0.0, yy2-yy1+1)
        inter = w*h
        iou = inter / (areas[i] + areas[order[1:]] - inter + 1e-6)
        inds = np.where(iou <= iou_thr)[0]
        order = order[inds + 1]
    return [boxes[i] for i in keep]

def _detect_once(img: np.ndarray, p: _Params) -> List[BBox]:
    # ölçek + binarizasyon
    work, _ = _resize_keep_aspect(img, p.target_height)
    gray = _to_gray_any(work)
    gray = cv2.GaussianBlur(gray, (3,3), 0)
    ink  = _binarize(gray)
    ink  = _remove_lines(ink)
    ink  = _morph_refine(ink)

    min_area = _estimate_min_area(ink)
    num, _, stats, _ = cv2.connectedComponentsWithStats((ink>0).astype(np.uint8), connectivity=8)

    H, W = ink.shape[:2]; page_area = H*W
    cands, scores = [], []
    for i in range(1, num):
        x,y,w,h,_ = stats[i]
        if w <= 2 or h <= 2: continue
        A = w*h
        if A < min_area or A > 0.35*page_area: continue
        aspect = w/float(h)
        if not (p.min_aspect <= aspect <= p.max_aspect): continue
        _, ink_ratio, solidity, circ = _component_features(ink, x, y, w, h)
        if ink_ratio < p.min_ink_ratio: continue
        if not p.include_stamps:
            if solidity > p.max_solid or circ > p.max_circularity_for_signature: 
                continue
        cands.append((int(x),int(y),int(x+w),int(y+h)))
        scores.append(float(ink_ratio))

    if not cands:
        return []
    boxes = _nms(cands, np.array(scores, np.float32), p.nms_iou)
    # kesin Python tuple/int döndür
    return [(int(x1), int(y1), int(x2-x1), int(y2-y1)) for (x1,y1,x2,y2) in boxes]

def robust_detect_signatures_from_array(img: np.ndarray,
                                        include_stamps: bool = True) -> List[BBox]:
    """
    2 geçişli sağlam tespit:
      1) Normal eşikler
      2) Sonuç yoksa eşikleri gevşet (küçük paraf/soluk imza için)
    """
    # Pass-1
    p1 = _Params(include_stamps=include_stamps,
                 target_height=1600, min_aspect=1.05, min_ink_ratio=0.02)
    boxes = _detect_once(img, p1)
    if boxes:
        return boxes

    # Pass-2 (aggressive)
    p2 = _Params(include_stamps=include_stamps,
                 target_height=2000, min_aspect=0.60, min_ink_ratio=0.010)
    return _detect_once(img, p2)