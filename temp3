# -*- coding: utf-8 -*-
from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, Optional, Tuple, Union, List

import numpy as np
import cv2
import fitz  # PyMuPDF
from PIL import Image
Image.MAX_IMAGE_PIXELS = None  # çok büyük sayfalar için koruma kaldırma

# Opsiyonel: tifffile + imagecodecs (daha hızlı ve çok codec destekli)
try:
    import tifffile as tiff
    _HAS_TIFFFILE = True
except Exception:
    _HAS_TIFFFILE = False


def convert_document_to_images(
    path: Union[str, Path],
    *,
    pdf_dpi: int = 600,               # PDF tam sayfa raster DPI (kırpmasız)
    apply_orientation: bool = True,   # TIFF/EXIF Orientation uygula (görüldüğü gibi)
    debug: bool = False               # True: sayfaları tek tek göster
) -> Dict[str, Any]:
    """
    PDF/TIFF'i sayfa sayfa 'görüldüğü gibi' image'a çevirir.
    - **Kırpma yapmaz**: PDF her zaman tam sayfa 600 DPI raster edilir.
    - TIFF: ham piksel döndürülür (orientation uygulanır), kırpma/yeniden örnekleme yok.
    Dönen dict: {"doc_str","path","page_count","pages":[{"index","dpi","shape","dtype","mode","colorspace","source","image"},...]}
    """
    # ---------- yardımcılar ----------
    def _imshow(img: np.ndarray, title: str):
        if not debug:
            return
        import matplotlib.pyplot as plt
        plt.figure(figsize=(10, 10))
        if img.ndim == 2:
            plt.imshow(img, cmap="gray")
        else:
            plt.imshow(img)
        plt.title(title)
        plt.axis("off")
        plt.show()

    def _apply_exif_orientation(arr: np.ndarray, orient: Optional[int]) -> np.ndarray:
        # 1..8; 3=180°, 6=90° CW, 8=90° CCW
        if orient is None:
            return arr
        if orient == 3:
            return np.rot90(arr, 2)
        if orient == 6:
            return np.rot90(arr, 3)
        if orient == 8:
            return np.rot90(arr, 1)
        return arr

    def _normalize_dpi_tuple(dpi_xy) -> Optional[Tuple[int, int]]:
        # (1,1) veya (0,0) gibi anlamsız metayı None yap
        if dpi_xy is None:
            return None
        try:
            x, y = int(dpi_xy[0]), int(dpi_xy[1])
            if x <= 1 and y <= 1:
                return None
            return (x, y)
        except Exception:
            return None

    # ---------- çekirdek akış ----------
    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    out: Dict[str, Any] = {"doc_str": None, "path": str(p), "page_count": 0, "pages": []}

    if ext == ".pdf":
        # **Her sayfa tam sayfa raster** (kenar boşlukları ve arka plan dahil) → kırpma yok
        out["doc_str"] = "pdf_doc"
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                scale = pdf_dpi / 72.0
                pix = page.get_pixmap(
                    matrix=fitz.Matrix(scale, scale),
                    alpha=True,              # saydamlık varsa koru (kırpma değil)
                    colorspace=fitz.csRGB    # sRGB raster
                )
                buf = np.frombuffer(pix.samples, dtype=np.uint8)
                if pix.n == 1:
                    img = buf.reshape(pix.h, pix.w).copy(); cs = "GRAY"
                elif pix.n == 3:
                    img = buf.reshape(pix.h, pix.w, 3).copy(); cs = "RGB"
                else:
                    img = buf.reshape(pix.h, pix.w, pix.n)[:, :, :4].copy(); cs = "RGBA"

                _imshow(img, f"PDF Sayfa {i} | tam sayfa raster | {cs} | dpi={pdf_dpi} | {img.shape}")
                out["pages"].append({
                    "index": i,
                    "dpi": pdf_dpi,
                    "shape": tuple(img.shape),
                    "dtype": str(img.dtype),
                    "mode": cs,
                    "colorspace": cs,
                    "source": "raster_fullpage",
                    "image": img
                })
        finally:
            doc.close()
        out["page_count"] = len(out["pages"])

    elif ext in (".tif", ".tiff"):
        out["doc_str"] = "tiff_doc"

        # Tercih: tifffile (hız/codec). Hata (örn. CCITT decoder yok) durumunda Pillow fallback.
        def _tiff_with_tifffile(pth: Path) -> List[Dict[str, Any]]:
            pages: List[Dict[str, Any]] = []
            with tiff.TiffFile(pth.as_posix()) as tf:
                for i, pg in enumerate(tf.pages):
                    arr = pg.asarray()  # ham piksel (kırpma/yeniden örnekleme yok)
                    # Orientation
                    orient = None
                    if apply_orientation:
                        try:
                            ori_tag = pg.tags.get("Orientation")
                            if ori_tag is not None:
                                orient = int(ori_tag.value)
                        except Exception:
                            orient = None
                    if apply_orientation and orient in (3, 6, 8):
                        arr = _apply_exif_orientation(arr, orient)
                    # DPI
                    dpi_xy = None
                    xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
                    if xr and yr and ru:
                        def _rat(tag):
                            num, den = tag.value
                            return float(num) / float(den)
                        x, y = _rat(xr), _rat(yr)
                        if ru.value == 3:  # dpcm -> dpi
                            x *= 2.54; y *= 2.54
                        dpi_xy = _normalize_dpi_tuple((int(round(x)), int(round(y))))
                    # mode bilgisi
                    if arr.ndim == 2:
                        mode = "1BIT" if arr.dtype == np.bool_ else "GRAY"
                    elif arr.ndim == 3 and arr.shape[2] == 3:
                        mode = "RGB"
                    elif arr.ndim == 3 and arr.shape[2] == 4:
                        mode = "RGBA"
                    else:
                        mode = f"NDIM{arr.ndim}_C{arr.shape[2] if arr.ndim==3 else 1}"

                    _imshow(arr, f"TIFF Sayfa {i} | tifffile | {mode} | dpi={dpi_xy} | {arr.shape}")
                    pages.append({
                        "index": i, "dpi": dpi_xy, "shape": tuple(arr.shape),
                        "dtype": str(arr.dtype), "mode": mode, "colorspace": mode, "source": "tifffile",
                        "image": arr
                    })
            return pages

        def _tiff_with_pillow(pth: Path) -> List[Dict[str, Any]]:
            pages: List[Dict[str, Any]] = []
            with Image.open(pth.as_posix()) as im:
                n = getattr(im, "n_frames", 1)
                for i in range(n):
                    im.seek(i)
                    frame = im.copy()
                    orient = None
                    if apply_orientation:
                        try:
                            exif = frame.getexif()
                            orient = int(exif.get(274) or 1) if exif else 1
                        except Exception:
                            orient = 1
                    arr = np.array(frame)  # kırpma yok, olduğu gibi
                    if apply_orientation and orient in (3, 6, 8):
                        arr = _apply_exif_orientation(arr, orient)
                    dpi_xy = frame.info.get("dpi")
                    dpi_xy = _normalize_dpi_tuple(dpi_xy if isinstance(dpi_xy, (tuple, list)) else None)
                    mode = frame.mode

                    _imshow(arr, f"TIFF Sayfa {i} | pillow | {mode} | dpi={dpi_xy} | {arr.shape}")
                    pages.append({
                        "index": i, "dpi": dpi_xy, "shape": tuple(arr.shape),
                        "dtype": str(arr.dtype), "mode": mode, "colorspace": mode, "source": "pillow",
                        "image": arr
                    })
            return pages

        if _HAS_TIFFFILE:
            try:
                out["pages"] = _tiff_with_tifffile(p)
            except Exception:
                # Örn: CCITT decoder yok → Pillow'a düş
                out["pages"] = _tiff_with_pillow(p)
        else:
            out["pages"] = _tiff_with_pillow(p)

        out["page_count"] = len(out["pages"])

    else:
        raise ValueError(f"Unsupported extension: {ext}")

    # İsteğe bağlı: debug=True iken tüm sayfaları sırayla göster
    if debug:
        for pg in out["pages"]:
            _imshow(pg["image"], f"Sayfa {pg['index']} | shape={pg['shape']} | dpi={pg['dpi']}")

    return out