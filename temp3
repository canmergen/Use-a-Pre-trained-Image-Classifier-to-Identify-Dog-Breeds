# -*- coding: utf-8 -*-
# Dinamik, çok-ölçekli, çok-eşikli imza/paraf/damga tespiti (yalnızca OpenCV+NumPy)

from typing import List, Tuple
from dataclasses import dataclass
import numpy as np
import cv2
import matplotlib.pyplot as plt

BBox = Tuple[int,int,int,int]  # (x,y,w,h)

# ---------- Yardımcılar ----------
def _to_gray_any(img: np.ndarray) -> np.ndarray:
    if img is None: raise ValueError("img is None")
    if img.dtype != np.uint8:
        img = (np.clip(img,0,1)*255).astype(np.uint8) if img.dtype in (np.float32,np.float64) else img.astype(np.uint8)
    if img.ndim == 2: return img
    if img.ndim == 3 and img.shape[2] == 3: return cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    if img.ndim == 3 and img.shape[2] == 4: return cv2.cvtColor(img, cv2.COLOR_BGRA2GRAY)
    raise ValueError(f"Unsupported shape: {img.shape}")

def _resize_keep_aspect(img: np.ndarray, target_h: int):
    h, w = img.shape[:2]
    s = target_h / float(h)
    if abs(s-1.0) < 1e-3: return img.copy(), 1.0
    return cv2.resize(img, (max(1,int(round(w*s))), max(1,int(round(h*s)))), cv2.INTER_LINEAR), s

def _binarize_union(gray: np.ndarray) -> np.ndarray:
    clahe = cv2.createCLAHE(clipLimit=2.2, tileGridSize=(8,8))
    g = clahe.apply(gray)
    g = cv2.GaussianBlur(g, (3,3), 0)
    _, otsu = cv2.threshold(g, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU); otsu = 255 - otsu
    adp = cv2.adaptiveThreshold(g, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 31, 7)
    kbh = cv2.getStructuringElement(cv2.MORPH_RECT, (25,25))
    bh = cv2.morphologyEx(g, cv2.MORPH_BLACKHAT, kbh); _, bh = cv2.threshold(bh, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)
    return np.maximum(np.maximum(otsu, adp), bh)  # ink=255

def _remove_lines(ink: np.ndarray) -> np.ndarray:
    e = cv2.Canny(ink, 50, 150, apertureSize=3)
    lines = cv2.HoughLinesP(e, 1, np.pi/180, threshold=140, minLineLength=120, maxLineGap=6)
    out = ink.copy()
    if lines is not None:
        for x1,y1,x2,y2 in lines[:,0]:
            cv2.line(out, (x1,y1), (x2,y2), 0, 5)
    return out

def _morph(ink: np.ndarray, close=5, open_=3, dilate_iter=0) -> np.ndarray:
    k1 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (close,close))
    k2 = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (open_,open_))
    m  = cv2.morphologyEx(ink, cv2.MORPH_CLOSE, k1, 1)
    m  = cv2.morphologyEx(m,   cv2.MORPH_OPEN,  k2, 1)
    if dilate_iter>0:
        kd = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3,3))
        m = cv2.dilate(m, kd, iterations=dilate_iter)
    return m

def _estimate_min_area(mask: np.ndarray) -> int:
    bin_ = (mask>0).astype(np.uint8)
    num, _, stats, _ = cv2.connectedComponentsWithStats(bin_, 8)
    areas, dims = [], []
    for i in range(1,num):
        x,y,w,h,a = stats[i]
        if w>1 and h>1: areas.append(int(a)); dims.append((w,h))
    if not areas: return 96
    areas = np.array(areas, np.float32)
    loga  = np.log(areas+1.0).astype(np.float32)
    logn  = cv2.normalize(loga, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
    otsu,_= cv2.threshold(logn, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)
    alpha = float(otsu)/255.0
    thr   = float(loga.min()) + (float(loga.max())-float(loga.min()))*alpha
    a_otsu= max(1.0, float(np.exp(thr)-1.0))
    dims  = np.array(dims, np.float32)
    sw    = float(np.median(dims.min(1)))
    a_floor = (max(1.0, sw)*6.0)**2
    return int(max(a_otsu*1.3, a_floor, 96.0))

def _features(mask: np.ndarray, x:int,y:int,w:int,h:int):
    roi = mask[y:y+h, x:x+w]
    area = int(np.count_nonzero(roi))
    ink_ratio = area / float(max(1,w*h))
    cnts,_ = cv2.findContours(roi, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts: return area, ink_ratio, 1.0, 1.0, 0.0
    cnt  = max(cnts, key=cv2.contourArea)
    hull = cv2.convexHull(cnt)
    ca   = cv2.contourArea(cnt); ha = max(1.0, cv2.contourArea(hull))
    solidity = ca/ha
    per  = cv2.arcLength(cnt, True)
    circ = (4.0*np.pi*ca)/(per*per + 1e-6)
    dt   = cv2.distanceTransform((roi>0).astype(np.uint8), cv2.DIST_L2, 3)
    stroke = float(dt[dt>0].mean()*2.0) if np.any(dt>0) else 0.0
    return area, ink_ratio, solidity, circ, stroke

def _nms(boxes: List[Tuple[int,int,int,int]], scores: np.ndarray, iou_thr: float):
    if not boxes: return []
    b = np.array(boxes, np.float32)
    x1,y1,x2,y2 = b[:,0],b[:,1],b[:,2],b[:,3]
    areas = (x2-x1+1)*(y2-y1+1)
    order = scores.argsort()[::-1]
    keep=[]
    while order.size>0:
        i=order[0]; keep.append(i)
        xx1 = np.maximum(x1[i], x1[order[1:]]); yy1 = np.maximum(y1[i], y1[order[1:]])
        xx2 = np.minimum(x2[i], x2[order[1:]]); yy2 = np.minimum(y2[i], y2[order[1:]])
        w = np.maximum(0.0, xx2-xx1+1); h = np.maximum(0.0, yy2-yy1+1)
        inter = w*h
        iou = inter/(areas[i]+areas[order[1:]]-inter+1e-6)
        inds = np.where(iou<=iou_thr)[0]
        order = order[inds+1]
    return [boxes[i] for i in keep]

def _merge_horizontals(boxes: List[Tuple[int,int,int,int]], max_gap:int=18):
    if not boxes: return boxes
    boxes = sorted(boxes, key=lambda b: (b[1], b[0]))
    out=[]; cur=list(boxes[0])
    for b in boxes[1:]:
        same_row = abs(b[1]-cur[1]) < max(b[3]-b[1], cur[3]-cur[1]) * 0.6
        touching = b[0] - cur[2] <= max_gap
        if same_row and touching:
            cur[2]=max(cur[2],b[2]); cur[3]=max(cur[3],b[3])
        else:
            out.append(tuple(cur)); cur=list(b)
    out.append(tuple(cur)); return out

# ---------- Dinamik dedektör ----------
@dataclass
class _P:
    target_height:int
    min_aspect:float
    min_ink_ratio:float
    min_stroke:float
    include_stamps:bool=True

def _detect_once(img: np.ndarray, p:_P, dilate_iter:int, min_area_scale:float, nms_iou:float=0.25):
    work, s = _resize_keep_aspect(img, p.target_height)
    gray   = _to_gray_any(work)
    ink    = _binarize_union(gray)
    ink    = _remove_lines(ink)
    ink    = _morph(ink, close=5, open_=3, dilate_iter=dilate_iter)
    min_area = max(32, int(_estimate_min_area(ink)*float(min_area_scale)))

    num, _, stats, _ = cv2.connectedComponentsWithStats((ink>0).astype(np.uint8), 8)
    H,W = ink.shape[:2]; page_area = H*W

    cand, scores = [], []
    for i in range(1,num):
        x,y,w,h,a = stats[i]
        if w<=2 or h<=2: continue
        A = w*h
        if A < min_area or A > 0.40*page_area: continue
        aspect = w/float(h)
        if aspect < p.min_aspect or aspect > 22.0: continue

        _, ink_ratio, solidity, circ, stroke = _features(ink, x,y,w,h)
        if ink_ratio < p.min_ink_ratio: continue
        if stroke < p.min_stroke: continue
        if not p.include_stamps:
            if solidity > 0.975 or circ > 0.92:   # damga/kaşe ele
                continue

        cand.append((int(x),int(y),int(x+w),int(y+h)))
        score = float(ink_ratio * (1.2 - min(1.0,solidity)) * (1.05 - min(1.0,circ)) * (0.5 + min(stroke,3.0)/3.0))
        scores.append(score)

    if not cand: return []

    keep = _nms(cand, np.array(scores,np.float32), nms_iou)
    keep = _merge_horizontals(keep, max_gap=18)

    inv = 1.0/s
    return [(int(round(x1*inv)),int(round(y1*inv)),int(round((x2-x1)*inv)),int(round((y2-y1)*inv))) for (x1,y1,x2,y2) in keep]

def detect_signatures_dynamic(img: np.ndarray, include_stamps: bool=True) -> List[BBox]:
    """
    Tam dinamik tespit: görüntüden istatistik çıkar, çok-ölçek + çok-eşik gridini otomatik kur,
    sonuçları birleştir (NMS) ve (x,y,w,h) döndür.
    """
    H, W = img.shape[:2]

    # Görüntü tabanlı otomatik grid:
    # sayfa yüksekliği küçükse ölçek listesi daraltılır
    base_scales = [1400, 1700, 2000, 2300] if H < 2200 else [1600, 2000, 2400, 2800]
    # tahmini gürültü/doluluk → daha boş sayfada daha gevşek eşikler
    gray = _to_gray_any(img); ink0 = _binarize_union(gray)
    ink_density = float(np.count_nonzero(ink0))/float(H*W + 1e-6)

    if ink_density < 0.08:
        min_ink_list = [0.010, 0.006, 0.003]   # çok boş: paraflar zayıf olabilir
        stroke_list  = [0.7, 0.6, 0.5]
        min_area_scales = [1.0, 0.7, 0.45]
        dilates = [0,1,2]
    else:
        min_ink_list = [0.014, 0.010, 0.006]
        stroke_list  = [0.8, 0.7, 0.6]
        min_area_scales = [1.0, 0.8, 0.6]
        dilates = [0,1,2]

    # grid denemesi
    all_boxes: List[BBox] = []
    tried = 0
    for th in base_scales:
        for mi, st, mas, d in zip(min_ink_list, stroke_list, min_area_scales, dilates):
            p = _P(target_height=th, min_aspect=0.5, min_ink_ratio=mi, min_stroke=st, include_stamps=include_stamps)
            boxes = _detect_once(img, p, dilate_iter=d, min_area_scale=mas, nms_iou=0.25)
            all_boxes.extend(boxes)
            tried += 1
        # erken durdurma: bu ölçekte yeterince kutu bulunduysa diğer ölçeklere geçme
        if len(all_boxes) >= 3:  # istersen artır/azalt
            pass  # yorum satırı bırakıyorum; çok çeşit doküman varsa erken durdurmayı istemeyebilirsin

    if not all_boxes: return []

    xyxy = [(x,y,x+w,y+h) for (x,y,w,h) in all_boxes]
    scores = np.ones(len(xyxy), np.float32)
    keep = _nms(xyxy, scores, 0.25)
    merged = _merge_horizontals(keep, max_gap=18)
    return [(int(x1),int(y1),int(x2-x1),int(y2-y1)) for (x1,y1,x2,y2) in merged]

# ---- Opsiyonel görselleştirme
def visualize_boxes(img: np.ndarray, boxes: List[BBox]) -> None:
    vis = img.copy()
    for (x,y,w,h) in boxes:
        cv2.rectangle(vis, (x,y), (x+w,y+h), (0,255,0), 2)
    plt.figure(figsize=(10,6))
    if vis.ndim==3: plt.imshow(cv2.cvtColor(vis, cv2.COLOR_BGR2RGB))
    else:           plt.imshow(vis, cmap='gray')
    plt.axis("off"); plt.title("Detected signatures (dynamic)"); plt.show()