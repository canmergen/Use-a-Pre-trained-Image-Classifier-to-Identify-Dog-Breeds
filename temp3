def rewrite_regions_texts_exactlike(paddle_ocr_regions, paddle_ocr_texts,
                                    flex=0, lookahead=80, min_ratio=0.65):
    """
    Her bbox'ın 'text'ini, aynı sayfanın metnindeki EN BENZER aynı-uzunluklu
    (±flex) dilimle değiştirir. Kutu sınırları korunur; yalnızca yazım/boşluk/
    diakritik düzeltmesi yapılır. Eşleşme zayıfsa, bbox'ın kendi temiz hâli bırakılır.

    flex=0  -> birebir aynı token sayısı (önerilen)
    lookahead -> cursor'dan ileri bakılacak max token
    min_ratio -> benzerlik tabanı (0.65 tipik; veri kalitesine göre 0.55–0.75)

    Beklenen veri:
      paddle_ocr_regions: List[List[{'text': str, 'bbox': {...}, ...}]]
      paddle_ocr_texts  : List[str]
    """
    import re, unicodedata, difflib

    assert len(paddle_ocr_regions) == len(paddle_ocr_texts), "Uzunluklar uyuşmuyor."

    # --- normalizasyon yardımcıları ---
    def _norm(s: str) -> str:
        if not isinstance(s, str):
            return ""
        s = unicodedata.normalize("NFKC", s)
        s = (s.replace("•"," ").replace("·"," ").replace("§","S")
               .replace("|"," ").replace("¦"," ").replace("—","-").replace("–","-")
               .replace("İ","İ").replace("i̇","i")
               .replace("Ş","Ş").replace("Ğ","Ğ").replace("Ç","Ç").replace("Ü","Ü")
               .replace("ş","ş").replace("ğ","ğ").replace("ç","ç").replace("ü","ü"))
        s = re.sub(r"\s*([.,:;/()\-])\s*", r"\1", s)     # 25 . 000 , 00 -> 25.000,00
        s = re.sub(r"\s+", " ", s).strip()
        return s

    def _tokens(s: str):
        s = _norm(s)
        return s.split() if s else []

    def _yx_key(r):
        b = r.get("bbox", {})
        y = (b.get("y1",0)+b.get("y2",0)+b.get("y3",0)+b.get("y4",0))//4
        x = (b.get("x1",0)+b.get("x2",0)+b.get("x3",0)+b.get("x4",0))//4
        return (y, x)

    def _digits_mask(s: str) -> str:
        # Sayı kalıbını koruma (örn. 25.000.000,00) için hızlı kontrol
        return re.sub(r"\d", "#", s)

    for page_regions, page_text in zip(paddle_ocr_regions, paddle_ocr_texts):
        if not page_regions:
            continue

        regs_sorted = sorted(page_regions, key=_yx_key)

        tgt_toks = _tokens(page_text)
        if not tgt_toks:
            # sayfa metni boşsa: yalnızca kendi metnini normalize et
            for r in regs_sorted:
                r["text"] = _norm(r.get("text",""))
            continue

        cursor = 0  # hedef akışta ilerleyen imleç

        for r in regs_sorted:
            src_raw  = r.get("text","")
            src_clean = _norm(src_raw)
            src_toks  = src_clean.split() if src_clean else []
            n = len(src_toks)

            if n == 0:
                r["text"] = ""
                continue

            start = max(0, cursor)
            end   = min(len(tgt_toks), start + max(lookahead, n + 2*max(1,flex)))

            best = (0.0, start, start)  # (ratio, j0, j1)
            min_len = max(1, n - flex)
            max_len = min(n + flex, max(1, end - start))

            src_join = " ".join(src_toks)
            src_mask = _digits_mask(src_join)

            for L in range(min_len, max_len + 1):
                j0 = start
                while j0 + L <= end:
                    cand_tokens = tgt_toks[j0:j0+L]
                    cand = " ".join(cand_tokens)
                    # hızlı sayı kalıbı kontrolü (sayılar yer/biçim olarak benzer kalsın)
                    if _digits_mask(cand) != src_mask:
                        j0 += 1
                        continue
                    ratio = difflib.SequenceMatcher(a=src_join, b=cand, autojunk=False).ratio()
                    if ratio > best[0]:
                        best = (ratio, j0, j0+L)
                    j0 += 1

            ratio, j0, j1 = best
            if ratio >= min_ratio:
                r["text"] = " ".join(tgt_toks[j0:j1])
                cursor = j1
            else:
                # Eşleşme zayıfsa: kutuyu bozma, yalnız kendi metnini düzgünleştir
                r["text"] = src_clean

    return paddle_ocr_regions

paddle_ocr_regions = rewrite_regions_texts_exactlike(
    paddle_ocr_regions, paddle_ocr_texts,
    flex=0,          # birebir uzunluk
    lookahead=100,
    min_ratio=0.65
)