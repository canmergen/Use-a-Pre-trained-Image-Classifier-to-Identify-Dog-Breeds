# doc_to_images.py
# -*- coding: utf-8 -*-

from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import numpy as np
import cv2
import fitz  # PyMuPDF
from PIL import Image
Image.MAX_IMAGE_PIXELS = None

try:
    import tifffile as tiff
    _HAS_TIFFFILE = True
except Exception:
    _HAS_TIFFFILE = False


def convert_document_to_images(
    path: Union[str, Path],
    *,
    pdf_dpi: int = 600,
    apply_orientation: bool = True,
    # --- yeni meta parametreleri ---
    osd_tc: Any = None,                 # TesseractClient gibi bir obje; yoksa OSD atlanır
    osd_conf: float = 0.0,              # OSD güven eşiği
    estimate_skew: bool = True,         # skew (eğiklik) tahmini yap
    skew_max_angle: float = 8.0,        # |açı| > bu değer ise outlier sayılır
    return_bgr: bool = True,            # görüntüyü BGR olarak döndür (OCR için önerilir)
    debug: bool = False
) -> Dict[str, Any]:
    """
    PDF/TIFF dosyasını sayfa sayfa imajlara çevirir (kırpma yok) ve meta bilgileri üretir.
    - PDF: her zaman tam sayfa raster, pdf_dpi çözünürlükte
    - TIFF: ham piksel + orientation uygular
    - OSD varsa sayfayı oto-rotate eder ve rotation_deg/meta döner
    - estimate_skew=True ise residual skew (eğiklik) derecesi tahmin edilir
    - Görüntü default BGR döner (OCR öncesi pipeline'lar için uygun)

    Dönen sözlük:
    {
      "doc_str": "pdf_doc"|"tiff_doc",
      "path": "...",
      "page_count": N,
      "pages": [
        {
          "index": i,
          "dpi": (x_dpi, y_dpi) | pdf_dpi,
          "shape": (H, W, C)  # C her zaman 3 (BGR),
          "dtype": "uint8",
          "mode": "BGR",
          "colorspace": "BGR",
          "source": "pdf_raster"|"tifffile"|"pillow",
          "rotation_deg": float,      # OSD sonucu (yoksa 0)
          "osd_confidence": float|None,
          "skew_deg": float|None,     # residual skew (yoksa None)
          "image": np.ndarray (BGR)
        }, ...
      ],
      "metas": [ {page_index: i, rotation_deg:..., ...}, ... ]  # kolay erişim için
    }
    """

    # ----------------- yardımcılar -----------------

    def _imshow(img: np.ndarray, title: str):
        if not debug:
            return
        import matplotlib.pyplot as plt
        plt.figure(figsize=(10, 10))
        if img.ndim == 2:
            plt.imshow(img, cmap="gray")
        else:
            plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB) if img.ndim == 3 else img)
        plt.title(title)
        plt.axis("off")
        plt.show()

    def _apply_exif_orientation(arr: np.ndarray, orient: Optional[int]) -> np.ndarray:
        # 1: normal, 3: 180, 6: 270 CW, 8: 90 CW (EXIF konvansiyonu)
        if orient is None:
            return arr
        if orient == 3:
            return np.rot90(arr, 2)
        if orient == 6:
            return np.rot90(arr, 3)
        if orient == 8:
            return np.rot90(arr, 1)
        return arr

    def _normalize_dpi_tuple(dpi_xy) -> Optional[Tuple[int, int]]:
        if dpi_xy is None:
            return None
        try:
            x, y = int(dpi_xy[0]), int(dpi_xy[1])
            if x <= 1 and y <= 1:
                return None
            return (x, y)
        except Exception:
            return None

    def _ensure_bgr(arr: np.ndarray) -> np.ndarray:
        if arr.ndim == 2:
            return cv2.cvtColor(arr, cv2.COLOR_GRAY2BGR)
        if arr.ndim == 3 and arr.shape[2] == 3:
            # PyMuPDF: RGB; Pillow: genelde RGB
            # varsayılanı RGB kabul edip BGR'e çeviriyoruz
            return cv2.cvtColor(arr, cv2.COLOR_RGB2BGR)
        if arr.ndim == 3 and arr.shape[2] == 4:
            # RGBA -> RGB -> BGR
            rgb = cv2.cvtColor(arr, cv2.COLOR_RGBA2RGB)
            return cv2.cvtColor(rgb, cv2.COLOR_RGB2BGR)
        # Bilinmeyen -> güvenli taraf: GRAY'e düşür + BGR
        gray = cv2.cvtColor(arr, cv2.COLOR_BGR2GRAY) if arr.ndim == 3 else arr
        return cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)

    def _osd_rotate_if_needed(bgr: np.ndarray) -> Tuple[np.ndarray, float, Optional[float]]:
        """
        Ortamınızda tanımlı rotate_img_using_osd(before_bgr, osd_tc, osd_conf) fonksiyonunu çağırır.
        Yoksa (osd_tc=None) doğrudan giriş döner.
        """
        if osd_tc is None:
            return bgr, 0.0, None
        # Kullanıcının ortamındaki imzayı aynen koruyoruz:
        try:
            from rotate_utils import rotate_img_using_osd  # varsa proje içi modül
        except Exception:
            # Fonksiyon global isim alanında olabilir:
            try:
                rotate_img_using_osd  # type: ignore
            except NameError:
                # Uygun fonksiyon yoksa OSD'yi pas geç
                return bgr, 0.0, None

        try:
            after_bgr, deg, conf = rotate_img_using_osd(bgr, osd_tc=osd_tc, osd_conf=osd_conf)  # type: ignore
            return after_bgr, float(deg or 0.0), (None if conf is None else float(conf))
        except Exception:
            # OSD başarısızsa dokunma
            return bgr, 0.0, None

    def _robust_skew_deg(bgr: np.ndarray, max_angle: float = 8.0) -> Optional[float]:
        """
        Metin satırlarından eğiklik (skew) tahmini (derece).
        1) Kenar + HoughLinesP ile açı topluyoruz.
        2) Açı yoksa minAreaRect fallback.
        Pozitif açı: saat yönünün tersi (cv2 koordinat sisteminde).
        """
        try:
            gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
            # hafif blur -> kenarlar
            g = cv2.GaussianBlur(gray, (3, 3), 0)
            v = cv2.Canny(g, 50, 150)
            v = cv2.dilate(v, np.ones((3, 3), np.uint8), iterations=1)
            lines = cv2.HoughLinesP(v, rho=1, theta=np.pi/1800, threshold=120,
                                    minLineLength=max(30, min(bgr.shape[:2]) // 15),
                                    maxLineGap=10)
            angles: List[float] = []
            if lines is not None:
                for ln in lines.squeeze(axis=1) if lines.ndim == 3 else lines:
                    x1, y1, x2, y2 = map(int, ln[:4])
                    dx, dy = (x2 - x1), (y2 - y1)
                    if dx == 0:
                        ang = 90.0
                    else:
                        ang = np.degrees(np.arctan2(dy, dx))
                    # Açıyı -90..90 aralığına getir
                    while ang <= -90: ang += 180
                    while ang > 90:   ang -= 180
                    # yataya yakın olanları al (başlık çizgileri/tablolar baskınsa işe yarar)
                    if abs(ang) <= max_angle:
                        angles.append(ang)

            if angles:
                # Outlier'ları kırp, medyanı dön
                a = np.array(angles, dtype=np.float32)
                med = float(np.median(a))
                mad = float(np.median(np.abs(a - med)) + 1e-6)
                keep = np.abs(a - med) <= (3.5 * mad)
                a2 = a[keep] if keep.any() else a
                return float(np.median(a2))

            # Fallback: minAreaRect (connected components üzerinden)
            _, bw = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
            bw = cv2.morphologyEx(bw, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8), iterations=1)
            cnts, _ = cv2.findContours(bw, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
            if not cnts:
                return None
            # Yeterince büyük komponentleri dikkate al
            areas = [cv2.contourArea(c) for c in cnts]
            if not areas:
                return None
            thr = max(50.0, np.percentile(areas, 60))  # küçük parçaları at
            angles2: List[float] = []
            for c in cnts:
                if cv2.contourArea(c) < thr:
                    continue
                rect = cv2.minAreaRect(c)
                ang = rect[-1]  # [-90, 0)
                # OpenCV'de -90..0 → -45 yatay benzeri, 0 dikey; yatay tabanına çevir
                if ang < -45:
                    ang = 90 + ang
                # artık -45..45
                if abs(ang) <= max_angle:
                    angles2.append(float(ang))
            if angles2:
                return float(np.median(np.array(angles2, dtype=np.float32)))
            return None
        except Exception:
            return None

    # ----------------- ana akış -----------------

    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    out: Dict[str, Any] = {"doc_str": None, "path": str(p), "page_count": 0, "pages": [], "metas": []}

    # ---- PDF ----
    if ext == ".pdf":
        out["doc_str"] = "pdf_doc"
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                scale = pdf_dpi / 72.0
                pix = page.get_pixmap(
                    matrix=fitz.Matrix(scale, scale),
                    alpha=True,
                    colorspace=fitz.csRGB
                )
                buf = np.frombuffer(pix.samples, dtype=np.uint8)
                if pix.n == 1:
                    arr = buf.reshape(pix.h, pix.w).copy()
                    arr = cv2.cvtColor(arr, cv2.COLOR_GRAY2RGB)
                elif pix.n == 3:
                    arr = buf.reshape(pix.h, pix.w, 3).copy()  # RGB
                else:
                    arr = buf.reshape(pix.h, pix.w, pix.n)[:, :, :4].copy()  # RGBA
                    arr = cv2.cvtColor(arr, cv2.COLOR_RGBA2RGB)

                bgr = _ensure_bgr(arr) if return_bgr else arr
                _imshow(bgr, f"PDF Sayfa {i} | dpi={pdf_dpi} | {bgr.shape}")

                # OSD rotate
                bgr_rot, rot_deg, conf = _osd_rotate_if_needed(bgr)

                # Skew
                skew_deg = _robust_skew_deg(bgr_rot, max_angle=skew_max_angle) if estimate_skew else None

                page_meta = {
                    "index": i,
                    "dpi": (pdf_dpi, pdf_dpi),
                    "shape": tuple(bgr_rot.shape),
                    "dtype": str(bgr_rot.dtype),
                    "mode": "BGR" if return_bgr else "RGB",
                    "colorspace": "BGR" if return_bgr else "RGB",
                    "source": "pdf_raster",
                    "rotation_deg": rot_deg,
                    "osd_confidence": conf,
                    "skew_deg": skew_deg,
                }
                out["pages"].append({**page_meta, "image": bgr_rot})
                out["metas"].append({"page_index": i, **{k: page_meta[k] for k in ("dpi", "shape", "rotation_deg", "osd_confidence", "skew_deg")}})
        finally:
            doc.close()
        out["page_count"] = len(out["pages"])

    # ---- TIFF ----
    elif ext in (".tif", ".tiff"):
        out["doc_str"] = "tiff_doc"

        def _tiff_with_tifffile(pth: Path) -> List[Dict[str, Any]]:
            pages: List[Dict[str, Any]] = []
            with tiff.TiffFile(pth.as_posix()) as tf:
                for i, pg in enumerate(tf.pages):
                    arr = pg.asarray()
                    orient = None
                    if apply_orientation:
                        try:
                            ori_tag = pg.tags.get("Orientation")
                            if ori_tag is not None:
                                orient = int(ori_tag.value)
                        except Exception:
                            orient = None
                    if apply_orientation and orient in (3, 6, 8):
                        arr = _apply_exif_orientation(arr, orient)

                    dpi_xy = None
                    xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
                    if xr and yr and ru:
                        def _rat(tag):
                            num, den = tag.value
                            return float(num) / float(den)
                        x, y = _rat(xr), _rat(yr)
                        if getattr(ru, "value", ru) == 3:  # 2: inch, 3: cm
                            x *= 2.54; y *= 2.54
                        dpi_xy = _normalize_dpi_tuple((int(round(x)), int(round(y))))

                    bgr = _ensure_bgr(arr) if return_bgr else arr
                    _imshow(bgr, f"TIFF Sayfa {i} | tifffile | dpi={dpi_xy} | {bgr.shape}")

                    bgr_rot, rot_deg, conf = _osd_rotate_if_needed(bgr)
                    skew_deg = _robust_skew_deg(bgr_rot, max_angle=skew_max_angle) if estimate_skew else None

                    page_meta = {
                        "index": i,
                        "dpi": dpi_xy,
                        "shape": tuple(bgr_rot.shape),
                        "dtype": str(bgr_rot.dtype),
                        "mode": "BGR" if return_bgr else "RGB",
                        "colorspace": "BGR" if return_bgr else "RGB",
                        "source": "tifffile",
                        "rotation_deg": rot_deg,
                        "osd_confidence": conf,
                        "skew_deg": skew_deg,
                    }
                    pages.append({**page_meta, "image": bgr_rot})
            return pages

        def _tiff_with_pillow(pth: Path) -> List[Dict[str, Any]]:
            pages: List[Dict[str, Any]] = []
            with Image.open(pth.as_posix()) as im:
                n = getattr(im, "n_frames", 1)
                for i in range(n):
                    im.seek(i)
                    frame = im.copy()
                    orient = None
                    if apply_orientation:
                        try:
                            exif = frame.getexif()
                            orient = int(exif.get(274) or 1) if exif else 1
                        except Exception:
                            orient = 1
                    arr = np.array(frame)
                    if apply_orientation and orient in (3, 6, 8):
                        arr = _apply_exif_orientation(arr, orient)

                    dpi_xy = frame.info.get("dpi")
                    dpi_xy = _normalize_dpi_tuple(dpi_xy if isinstance(dpi_xy, (tuple, list)) else None)

                    bgr = _ensure_bgr(arr) if return_bgr else arr
                    _imshow(bgr, f"TIFF Sayfa {i} | pillow | dpi={dpi_xy} | {bgr.shape}")

                    bgr_rot, rot_deg, conf = _osd_rotate_if_needed(bgr)
                    skew_deg = _robust_skew_deg(bgr_rot, max_angle=skew_max_angle) if estimate_skew else None

                    page_meta = {
                        "index": i,
                        "dpi": dpi_xy,
                        "shape": tuple(bgr_rot.shape),
                        "dtype": str(bgr_rot.dtype),
                        "mode": "BGR" if return_bgr else "RGB",
                        "colorspace": "BGR" if return_bgr else "RGB",
                        "source": "pillow",
                        "rotation_deg": rot_deg,
                        "osd_confidence": conf,
                        "skew_deg": skew_deg,
                    }
                    pages.append({**page_meta, "image": bgr_rot})
            return pages

        try:
            if _HAS_TIFFFILE:
                out["pages"] = _tiff_with_tifffile(p)
            else:
                out["pages"] = _tiff_with_pillow(p)
        except Exception:
            # tifffile hata verirse pillow'a düş
            out["pages"] = _tiff_with_pillow(p)

        out["page_count"] = len(out["pages"])
        # metas listesi
        for pg in out["pages"]:
            out["metas"].append({"page_index": pg["index"],
                                 "dpi": pg["dpi"],
                                 "shape": pg["shape"],
                                 "rotation_deg": pg["rotation_deg"],
                                 "osd_confidence": pg["osd_confidence"],
                                 "skew_deg": pg["skew_deg"]})

    else:
        raise ValueError(f"Unsupported extension: {ext}")

    return out