# -*- coding: utf-8 -*-
def extract_roles_and_bottom(
    lower_img,
    result,
    table_df_final,
    ocr_fn,                         
    *,
    new_url=None,
    lang="tur+eng",
    psm_list=(11, 6),
    oem_list=(1, 3),
    known_names=None,
    role_threshold=0.60,
    soft_toplanti_floor=0.50,
    name_sim_threshold=0.88,
    force_margin_px=10,
    iou_thresh=0.25,
    debug=False,
):
    import re, unicodedata
    import numpy as np
    import pandas as pd
    from rapidfuzz import fuzz

    # ---------- text utils ----------
    CONFUSION = str.maketrans({"0":"O","1":"I","5":"S","8":"B","€":"E","$":"S","@":"A"})
    ALT_MAP = {"Ş":"S","Ğ":"G","İ":"I","I":"I","Ü":"U","Ö":"O","Ç":"C",
               "ş":"s","ğ":"g","ı":"i","i":"i","ü":"u","ö":"o","ç":"c"}

    def tr_upper(s: str) -> str:
        return (s or "").replace("i","İ").replace("ı","I").upper()
    def tr_lower(s: str) -> str:
        return (s or "").replace("I","ı").replace("İ","i").lower()
    def tr_title(s: str) -> str:
        return " ".join([w.capitalize() for w in (s or "").split()])
    def strip_diac(s: str) -> str:
        return "".join(c for c in unicodedata.normalize("NFD", s) if not unicodedata.combining(c))
    def canon_key(name: str) -> str:
        k = re.sub(r"[^A-ZÇĞIİÖŞÜ ]", " ", tr_upper(strip_diac(name or "")))
        toks = [t for t in k.split() if len(t) >= 2]
        return " ".join(toks)
    def norm_space(s: str) -> str:
        return re.sub(r"\s+", " ", (s or "").strip())
    def is_all_caps_ctx(s: str) -> bool:
        letters = re.findall(r"[A-ZÇĞIİÖŞÜ]", tr_upper(s or ""))
        total   = len(re.findall(r"[A-Za-zÇĞIİÖŞÜçğıişöü]", s or ""))
        return len(letters) >= max(1, int(0.8*total))

    def normalize_hard(s: str) -> str:
        if not s: return ""
        s = "".join(ALT_MAP.get(c, c) for c in s)
        s = unicodedata.normalize("NFD", s)
        s = "".join(c for c in s if not unicodedata.combining(c))
        s = s.translate(CONFUSION).upper()
        s = re.sub(r"[^A-Z0-9\s]", " ", s)
        s = re.sub(r"\s+", " ", s).strip()
        s = (s.replace("TOFLANI","TOPLANTI").replace("TOPLANI","TOPLANTI").replace("TOPLANT1","TOPLANTI"))
        s = (s.replace("BAS I","BASKANI").replace("BASI","BASKANI").replace("BASKAN.","BASKANI").replace("BASKAN","BASKANI"))
        s = (s.replace("Y0NETIM","YONETIM").replace("YONET1M","YONETIM"))
        return s

    # ---------- geometry ----------
    def to_xywh(obj):
        if isinstance(obj, dict) and "bbox" in obj: obj = obj["bbox"]
        if isinstance(obj, (tuple, list, np.ndarray)) and len(obj)==4:
            x1,y1,a,b = [int(round(float(v))) for v in obj]
            if a>x1 and b>y1: return (x1,y1,a-x1,b-y1)
            return (x1,y1,a,b)
        return None
    def xywh_to_xyxy(b): x,y,w,h=b; return (x,y,x+w,y+h)
    def expand_xyxy(b, m): x0,y0,x1,y1=b; return (x0-m, y0-m, x1+m, y1+m)
    def iou_xyxy(a, b):
        ax0,ay0,ax1,ay1=a; bx0,by0,bx1,by1=b
        ix=max(0, min(ax1,bx1)-max(ax0,bx0)); iy=max(0, min(ay1,by1)-max(ay0,by0))
        inter=ix*iy
        if inter<=0: return 0.0
        a_area=max(1,(ax1-ax0)*(ay1-ay0)); b_area=max(1,(bx1-bx0)*(by1-by0))
        return inter/(a_area+b_area-inter)

    # ---------- OCR wrapper ----------
    def ocr_text(img, xywh, lang, psm_list, oem_list, url):
        x,y,w,h = xywh
        pad = max(3, int(0.04*max(w,h)))
        crop=(max(0,x-pad), max(0,y-pad),
              min(img.shape[1],x+w+pad)-max(0,x-pad),
              min(img.shape[0],y+h+pad)-max(0,y-pad))
        best=""; bestq=-1e9
        for psm in psm_list:
            for oem in oem_list:
                try: txt=ocr_fn(img, crop, lang=lang, psm=psm, oem=oem, url=url)
                except Exception: txt=""
                q = len(re.findall(r"[A-Za-zÇĞIİÖŞÜçğışöü]", txt)) - 2*len(re.findall(r"[^\w\s]", txt))
                if q>bestq: bestq, best = q, txt
        return best

    # ---------- role regex ----------
    YKBASKANI_RE   = re.compile(r"YONETIM\s*KURULU\s*BASKANI|YK\s*BASKANI")
    TOPBASKANI_RE  = re.compile(r"TOPLANTI\s*BASKANI")
    YKUYESI_RE     = re.compile(r"YONETIM\s*KURULU\s*UYESI|YK\s*UYESI")
    BAKTEMS_RE     = re.compile(r"BAKANLIK\s*TEMSILCISI|TICARET\s*BAKANLIGI\s*TEMSILCISI")

    def regex_role(text: str):
        t = normalize_hard(text)
        if YKBASKANI_RE.search(t): return ("yk_baskani", 1.0, "regex")
        if TOPBASKANI_RE.search(t): return ("toplanti_baskani", 1.0, "regex")
        if YKUYESI_RE.search(t): return ("yk_uyesi", 1.0, "regex")
        if BAKTEMS_RE.search(t): return ("bakanlik_temsilcisi", 1.0, "regex")
        return (None, 0.0, "")

    # ---------- why hint ----------
    def why_hint_role(why: str):
        w = normalize_hard(why or "")
        if "YK+BASKAN" in w: return "yk_baskani"
        if "TOPLANTI+BASKAN" in w: return "toplanti_baskani"
        return None

    # ---------- role blocks ----------
    role_blocks=[]
    for rb in (result.get("roles") or []):
        b = to_xywh(rb)
        if not b: continue
        txt = rb.get("txt") if isinstance(rb, dict) else None
        r, sc, why = regex_role(txt or "")
        hint = why_hint_role(why)
        if hint: r = hint
        if r: role_blocks.append({"bbox": b, "role": r, "score": sc, "txt": txt, "why": why})

    # ---------- per box ----------
    boxes = result.get("final") or result.get("roles") or []
    boxes_xywh = [to_xywh(rb) for rb in boxes]

    rows_out=[]
    for i,(b,obj) in enumerate(zip(boxes_xywh, boxes)):
        if not b: continue
        text = norm_space(obj.get("txt","") if isinstance(obj,dict) else "")
        r_rgx, sc_rgx, why_rgx = regex_role(text)
        role_best = r_rgx; role_score = sc_rgx; reasons=[]
        for rb in role_blocks:
            if rb["bbox"] == b:
                role_best = rb["role"]; role_score = rb["score"]
                reasons.append(rb.get("why",""))
        hint = why_hint_role(" ".join(reasons))
        if hint and hint!=role_best:
            role_best, role_score = hint, 0.99
            reasons.append(f"why-override->{hint}")
        # ad-soyad temizle (rol kelimeleri atılır)
        name_in_box=None
        txt_clean = re.sub(r"\b(TOPLANTI|BASKANI|YK|YONETIM|KURULU|UYESI|BAKANLIK|TEMSILCISI)\b"," ", normalize_hard(text))
        name_in_box = norm_space(txt_clean)
        rows_out.append({
            "i": i,"bbox": b,"sig": False,
            "role_best": role_best,"role_score": role_score,
            "role_reasons": ";".join([r for r in reasons if r]),
            "name_in_box": name_in_box if name_in_box else None,
            "text_preview": text[:200],
        })

    per_box_df = pd.DataFrame(rows_out)

    # ---------- bottom_df doldurma ----------
    out = {
        "sermaye_toplam_tl": None,
        "toplanti_baskani_ad_soyad": None, "yk_baskani_ad_soyad": None,
        "yk_uyesi_ad_soyad": None, "bakanlik_temsilcisi_ad_soyad": None,
        "katip_ad_soyad": None, "divan_baskani_ad_soyad": None,
        "tutanak_yazmani_ad_soyad": None
    }
    name_cols = {
        "toplanti_baskani":"toplanti_baskani_ad_soyad",
        "yk_baskani":"yk_baskani_ad_soyad",
        "yk_uyesi":"yk_uyesi_ad_soyad",
        "bakanlik_temsilcisi":"bakanlik_temsilcisi_ad_soyad",
        "katip":"katip_ad_soyad",
        "divan_baskani":"divan_baskani_ad_soyad",
        "tutanak_yazmani":"tutanak_yazmani_ad_soyad"
    }
    for _,r in per_box_df.iterrows():
        role=r.get("role_best"); ncol=name_cols.get(role)
        if not ncol: continue
        out[ncol]=r.get("name_in_box")
    bottom_df=pd.DataFrame([out])

    if debug:
        from IPython.display import display
        print(f"[INFO] role_blocks={len(role_blocks)}, boxes={len(per_box_df)}")
        display(pd.DataFrame(role_blocks))
        display(per_box_df); display(bottom_df)

    return per_box_df, bottom_df