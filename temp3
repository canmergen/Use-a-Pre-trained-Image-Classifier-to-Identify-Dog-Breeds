def convert_document_to_images(
    path,
    *,
    pdf_dpi: int = 600,             # PDF raster DPI
    cover_thresh: float = 0.97,     # PDF: sayfayı kaplayan görsel eşiği
    apply_orientation: bool = True, # TIFF/EXIF Orientation uygula
    debug: bool = False
):
    """
    Çok sayfalı PDF/TIFF'i 'görüldüğü gibi' image'lara çevirir (renk/kanal/dtype'e dokunmadan).
    - PDF: önce native (tek/kaplayan görsel) → yoksa 600 DPI raster.
    - TIFF: tifffile (varsa) → decode hatasında otomatik Pillow fallback.
    - DPI metası (1,1)/(0,0) görülürse None'a normalize edilir.
    Dönen:
      {"doc_str","path","page_count","pages":[{"index","dpi","shape","dtype","mode","colorspace","source","image"},...]}
    """
    # ---- imports ----
    from pathlib import Path
    from typing import Optional
    import numpy as np
    import cv2, fitz  # PyMuPDF
    from PIL import Image
    Image.MAX_IMAGE_PIXELS = None
    try:
        import tifffile as tiff
        _HAS_TIFFFILE = True
    except Exception:
        _HAS_TIFFFILE = False

    # ---- helpers ----
    def _imshow(img, title: str):
        if not debug: return
        import matplotlib.pyplot as plt
        plt.figure(figsize=(10,10))
        if img.ndim == 2: plt.imshow(img, cmap='gray')
        else:             plt.imshow(img)
        plt.title(title); plt.axis('off'); plt.show()

    def _apply_exif_orientation(arr, orient: Optional[int]):
        if orient is None: return arr
        if orient == 3:  return np.rot90(arr, 2)
        if orient == 6:  return np.rot90(arr, 3)  # 90° CW
        if orient == 8:  return np.rot90(arr, 1)  # 90° CCW
        return arr

    def _decode_image_bytes_lossless(b: bytes):
        buf = np.frombuffer(b, dtype=np.uint8)
        im = cv2.imdecode(buf, cv2.IMREAD_UNCHANGED)
        if im is None:
            raise ValueError("cv2.imdecode failed.")
        if im.ndim == 2:
            return im, "GRAY"
        if im.shape[2] == 3:
            return cv2.cvtColor(im, cv2.COLOR_BGR2RGB), "RGB"
        return cv2.cvtColor(im, cv2.COLOR_BGRA2RGBA), "RGBA"

    # --- robust area helpers (Rect | tuple destek) ---
    def _rect_area(rect_or_tuple) -> float:
        # fitz.Rect
        if hasattr(rect_or_tuple, "get_area"):
            return float(rect_or_tuple.get_area())
        if hasattr(rect_or_tuple, "width") and hasattr(rect_or_tuple, "height"):
            return float(rect_or_tuple.width * rect_or_tuple.height)
        # (x0, y0, x1, y1)
        if isinstance(rect_or_tuple, (tuple, list)) and len(rect_or_tuple) >= 4:
            x0, y0, x1, y1 = rect_or_tuple[:4]
            return float(max(0.0, (x1 - x0)) * max(0.0, (y1 - y0)))
        return 0.0

    def _pdf_try_native_cover(doc, page, cover_thresh: float):
        # 1) tek görsel + metin yok
        imgs = page.get_images(full=True)
        if len(imgs) == 1 and not page.get_text("blocks"):
            return doc.extract_image(imgs[0][0])["image"]
        # 2) sayfayı kaplayan görsel(ler)
        page_area = _rect_area(page.rect)
        covers = []
        for info in page.get_image_info(xrefs=True):
            bbox = info.get("bbox")
            if bbox and ( _rect_area(bbox) / max(page_area, 1e-9) ) >= cover_thresh:
                covers.append(info["xref"])
        if len(covers) == 1:
            return doc.extract_image(covers[0])["image"]
        return None

    def _normalize_dpi(dpi_xy):
        # (1,1) veya (0,0) gibi anlamsız değerleri None yap
        if dpi_xy is None: return None
        try:
            x, y = int(dpi_xy[0]), int(dpi_xy[1])
            if x <= 1 and y <= 1: return None
            return (x, y)
        except Exception:
            return None

    def _tiff_with_tifffile(p: Path):
        pages = []
        with tiff.TiffFile(p.as_posix()) as tf:
            for i, pg in enumerate(tf.pages):
                arr = pg.asarray()  # ham piksel (decoder gerekebilir)
                # Orientation
                orient = None
                if apply_orientation:
                    try:
                        ori_tag = pg.tags.get("Orientation")
                        if ori_tag is not None: orient = int(ori_tag.value)
                    except Exception:
                        orient = None
                if apply_orientation and orient in (3, 6, 8):
                    arr = _apply_exif_orientation(arr, orient)
                # DPI
                dpi_xy = None
                xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
                if xr and yr and ru:
                    def _rat(tag):
                        num, den = tag.value
                        return float(num)/float(den)
                    x, y = _rat(xr), _rat(yr)
                    if ru.value == 3: x *= 2.54; y *= 2.54  # dpcm->dpi
                    dpi_xy = _normalize_dpi((int(round(x)), int(round(y))))
                # mode bilgisi
                if arr.ndim == 2:
                    mode = "1BIT" if arr.dtype == np.bool_ else "GRAY"
                elif arr.ndim == 3 and arr.shape[2] == 3:
                    mode = "RGB"
                elif arr.ndim == 3 and arr.shape[2] == 4:
                    mode = "RGBA"
                else:
                    mode = f"NDIM{arr.ndim}_C{arr.shape[2] if arr.ndim==3 else 1}"

                pages.append({
                    "index": i, "dpi": dpi_xy, "shape": tuple(arr.shape),
                    "dtype": str(arr.dtype), "mode": mode, "colorspace": mode, "source": "tifffile",
                    "image": arr
                })
        return pages

    def _tiff_with_pillow(p: Path):
        pages = []
        with Image.open(p.as_posix()) as im:
            n = getattr(im, "n_frames", 1)
            for i in range(n):
                im.seek(i)
                frame = im.copy()
                # Orientation (EXIF 274)
                orient = None
                if apply_orientation:
                    try:
                        exif = frame.getexif()
                        orient = int(exif.get(274) or 1) if exif else 1
                    except Exception:
                        orient = 1
                arr = np.array(frame)
                if apply_orientation and orient in (3, 6, 8):
                    arr = _apply_exif_orientation(arr, orient)
                # DPI
                dpi_xy = frame.info.get("dpi")
                dpi_xy = _normalize_dpi(dpi_xy if isinstance(dpi_xy, (tuple, list)) else None)
                mode = frame.mode
                pages.append({
                    "index": i, "dpi": dpi_xy, "shape": tuple(arr.shape),
                    "dtype": str(arr.dtype), "mode": mode, "colorspace": mode, "source": "pillow",
                    "image": arr
                })
        return pages

    # ---- core ----
    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    out = {"doc_str": None, "path": str(p), "page_count": 0, "pages": []}

    if ext == ".pdf":
        out["doc_str"] = "pdf_doc"
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                nb = _pdf_try_native_cover(doc, page, cover_thresh=cover_thresh)
                if nb is not None:
                    img, cs = _decode_image_bytes_lossless(nb)
                    src = "native"; dpi_val = None
                else:
                    scale = pdf_dpi / 72.0
                    pix = page.get_pixmap(matrix=fitz.Matrix(scale, scale), alpha=True, colorspace=fitz.csRGB)
                    buf = np.frombuffer(pix.samples, dtype=np.uint8)
                    if pix.n == 1:
                        img = buf.reshape(pix.h, pix.w).copy(); cs = "GRAY"
                    elif pix.n == 3:
                        img = buf.reshape(pix.h, pix.w, 3).copy(); cs = "RGB"
                    else:
                        img = buf.reshape(pix.h, pix.w, pix.n)[:, :, :4].copy(); cs = "RGBA"
                    src = "raster"; dpi_val = pdf_dpi

                _imshow(img, f"Sayfa {i} | {src} | {cs} | dpi={dpi_val} | {img.shape}")
                out["pages"].append({
                    "index": i, "dpi": dpi_val, "shape": tuple(img.shape),
                    "dtype": str(img.dtype), "mode": cs, "colorspace": cs, "source": src, "image": img
                })
        finally:
            doc.close()
        out["page_count"] = len(out["pages"])

    elif ext in (".tif", ".tiff"):
        out["doc_str"] = "tiff_doc"
        if _HAS_TIFFFILE:
            try:
                out["pages"] = _tiff_with_tifffile(p)
            except Exception:
                # Örn: CCITT decoder yokluğu → Pillow fallback
                out["pages"] = _tiff_with_pillow(p)
        else:
            out["pages"] = _tiff_with_pillow(p)
        out["page_count"] = len(out["pages"])

    else:
        raise ValueError(f"Unsupported extension: {ext}")

    # debug modunda sayfaları ayrıca tek tek göster
    if debug:
        for pg in out["pages"]:
            _imshow(pg["image"], f"Sayfa {pg['index']} | shape={pg['shape']} | dpi={pg['dpi']}")

    return out