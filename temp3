# -*- coding: utf-8 -*-
from __future__ import annotations
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import numpy as np
import cv2
import fitz  # PyMuPDF
from PIL import Image
Image.MAX_IMAGE_PIXELS = None

try:
    import tifffile as tiff
    _HAS_TIFF = True
except Exception:
    _HAS_TIFF = False


def convert_document_with_rotation_and_keywords(
    path: Union[str, Path],
    *,
    pdf_dpi: int = 600,
    # OSD (yön) için client: get_osd_ocr(PIL, ..., output_type='dict') -> {'rotate': 0/90/180/270, ...}
    osd_tc: Any = None,
    # Keyword self-check için OCR client (opsiyonel)
    tc_new: Any = None,
    keywords: Optional[List[str]] = None,
    enable_keyword_rotation: bool = True,
    tc_new_lang: str = "tur",
    tc_new_psm: Optional[int] = None,
    tc_new_oem: Optional[int] = None,
    tc_new_config: Optional[str] = None,
    # Deskew ayarları
    deskew: bool = True,
    deskew_method: str = "projection",   # 'projection' | 'hough' | 'auto'
    deskew_max_abs: float = 15.0,        # ± açı aralığı
    deskew_step: float = 0.5,            # tarama adımı
    # Performans / görselleştirme
    angle_estimation_max_side: int = 1600,  # OSD/OCR/deskew küçük kopya uzun kenar
    return_bgr: bool = True,
    debug: bool = False
) -> Dict[str, Any]:
    """
    PDF/TIFF -> raster -> (TIFF) EXIF -> OSD 0/±90/180 -> (opsiyonel) keyword self-check
              -> deskew (projection/hough/auto) -> kırpmasız döndürme.

    Dönüş: {'images': [BGR...], 'metas': [...], 'page_count': int, ...}
    """

    # ---------- image helpers ----------
    def _rgba_to_bgr_on_white(rgba: np.ndarray) -> np.ndarray:
        rgb = rgba[..., :3].astype(np.float32)
        a = rgba[..., 3:4].astype(np.float32) / 255.0
        out = rgb * a + 255.0 * (1.0 - a)
        return cv2.cvtColor(np.clip(out, 0, 255).astype(np.uint8), cv2.COLOR_RGB2BGR)

    def _ensure_bgr(arr: np.ndarray) -> np.ndarray:
        if arr.ndim == 2:
            return cv2.cvtColor(arr.astype(np.uint8, copy=False), cv2.COLOR_GRAY2BGR)
        if arr.ndim == 3 and arr.shape[2] == 3:
            return arr.astype(np.uint8, copy=False)
        if arr.ndim == 3 and arr.shape[2] == 4:
            return arr[:, :, :3].astype(np.uint8, copy=False)
        s = np.squeeze(arr)
        if s.ndim == 2:
            return cv2.cvtColor(s.astype(np.uint8, copy=False), cv2.COLOR_GRAY2BGR)
        if s.ndim == 3 and s.shape[2] >= 3:
            return s[:, :, :3].astype(np.uint8, copy=False)
        raise ValueError(f"Unsupported array shape: {arr.shape}")

    def _apply_exif_orientation(bgr: np.ndarray, orient: Optional[int]) -> Tuple[np.ndarray, int]:
        # 1: normal, 3: 180, 6: 270 CW(= +90 CCW), 8: 90 CW(= -90 CCW)
        deg = 0
        if orient == 3:  return np.rot90(bgr, 2).copy(), 180
        if orient == 6:  return np.rot90(bgr, 1).copy(),  90
        if orient == 8:  return np.rot90(bgr, 3).copy(), -90
        return bgr, deg

    def _rotate_full_canvas(bgr: np.ndarray, angle_ccw: float) -> np.ndarray:
        # KIRPMASIZ döndürme
        if abs(angle_ccw) < 1e-6: return bgr
        (h, w) = bgr.shape[:2]
        c = (w / 2.0, h / 2.0)
        M = cv2.getRotationMatrix2D(c, angle_ccw, 1.0)  # CCW +
        cos, sin = abs(M[0, 0]), abs(M[0, 1])
        nW = int(h * sin + w * cos)
        nH = int(h * cos + w * sin)
        M[0, 2] += (nW / 2) - c[0]
        M[1, 2] += (nH / 2) - c[1]
        return cv2.warpAffine(bgr, M, (nW, nH), flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REPLICATE)

    def _apply_right_angle_ccw(bgr: np.ndarray, ra: int) -> np.ndarray:
        if ra == 0:   return bgr
        if ra == 90:  return np.rot90(bgr, 1).copy()
        if ra == 180: return np.rot90(bgr, 2).copy()
        if ra == -90: return np.rot90(bgr, 3).copy()
        return _rotate_full_canvas(bgr, float(ra))

    def _make_small(bgr: np.ndarray) -> np.ndarray:
        h, w = bgr.shape[:2]
        m = max(h, w)
        if m <= angle_estimation_max_side: return bgr
        scale = angle_estimation_max_side / float(m)
        return cv2.resize(bgr, (int(w * scale), int(h * scale)), interpolation=cv2.INTER_AREA)

    # ---------- OCR helpers ----------
    def _osd_detect_deg_cw(bgr_small: np.ndarray) -> Tuple[Optional[int], Optional[float]]:
        if osd_tc is None: return None, None
        try:
            pil = Image.fromarray(cv2.cvtColor(bgr_small, cv2.COLOR_BGR2RGB))
            raw = osd_tc.get_osd_ocr(pil, config='', model='best', output_type='dict')
            if not isinstance(raw, dict): return None, None
            d = raw.get('dict', raw)
            deg = int(d.get('rotate', d.get('rotation', d.get('rot', 0))) or 0) % 360
            conf = float(d.get('orientation_conf', d.get('conf', d.get('confidence', 0.0))) or 0.0)
            return deg, conf
        except Exception:
            return None, None

    def _tc_new_text(bgr_small: np.ndarray) -> str:
        if tc_new is None: return ""
        pil = Image.fromarray(cv2.cvtColor(bgr_small, cv2.COLOR_BGR2RGB))
        kwargs: Dict[str, Any] = {}
        if tc_new_config:
            kwargs["config"] = tc_new_config
        else:
            cfg = []
            if tc_new_psm is not None: cfg.append(f"--psm {int(tc_new_psm)}")
            if tc_new_oem is not None: cfg.append(f"--oem {int(tc_new_oem)}")
            if cfg: kwargs["config"] = " ".join(cfg)
        if tc_new_lang: kwargs["lang"] = tc_new_lang

        for name in ["ocr", "run_ocr", "predict", "infer", "get_text", "__call__"]:
            fn = getattr(tc_new, name, None)
            if callable(fn):
                try:
                    txt = fn(pil, **kwargs)
                    if isinstance(txt, dict): txt = txt.get("text", "")
                    return txt if isinstance(txt, str) else str(txt)
                except TypeError:
                    try:
                        txt = fn(pil, output_type="text", **kwargs)
                        if isinstance(txt, dict): txt = txt.get("text", "")
                        return txt if isinstance(txt, str) else str(txt)
                    except Exception:
                        pass
                except Exception:
                    pass
        return ""

    def _keyword_score(text: str, kws: List[str]) -> int:
        t = text.lower()
        return sum(1 for kw in kws if kw.strip() and kw.lower() in t)

    # ---------- angles ----------
    def _osd_cw_to_ccw_deg(dcw: Optional[int]) -> int:
        if dcw is None: return 0
        d = int(dcw) % 360
        # OSD rotate (CW) -> uygulanacak CCW:
        if d == 0:   return 0
        if d == 90:  return 90      # sağa yatık (CW) -> +90 CCW
        if d == 180: return 180
        if d == 270: return -90     # sola yatık (CCW) -> -90 CCW
        return 0

    # ---- PROJECTION-BAZLI SKEW (önerilen) ----
    def _deskew_projection_angle(bgr_small: np.ndarray,
                                 max_abs: float = 15.0,
                                 step: float = 0.5) -> Tuple[float, float]:
        """
        Döndürme açısını (CCW, uygulanacak açı) ve skorunu döndürür.
        Skor = projeksiyon varyansı + farkların varyansı (ne kadar çizgiliyse o kadar büyük).
        """
        gray = cv2.cvtColor(bgr_small, cv2.COLOR_BGR2GRAY)
        g = cv2.GaussianBlur(gray, (3, 3), 0)
        thr, bw = cv2.threshold(g, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        if np.mean(bw) > 127: bw = 255 - bw  # metin=1 olacak şekilde tersle

        # Ink oranı çok düşükse deskew yapma
        ink_frac = float(np.count_nonzero(bw)) / bw.size
        if ink_frac < 0.005:
            return 0.0, 0.0

        angles = np.arange(-max_abs, max_abs + 1e-6, step, dtype=np.float32)
        best_score = -1e18
        best_angle = 0.0

        h, w = bw.shape
        c = (w/2.0, h/2.0)
        for a in angles:
            M = cv2.getRotationMatrix2D(c, a, 1.0)  # CCW +
            cos, sin = abs(M[0,0]), abs(M[0,1])
            nW = int(h*sin + w*cos); nH = int(h*cos + w*sin)
            Mt = M.copy()
            Mt[0,2] += (nW/2.0) - c[0]; Mt[1,2] += (nH/2.0) - c[1]
            rot = cv2.warpAffine(bw, Mt, (nW, nH), flags=cv2.INTER_NEAREST, borderValue=0)
            proj = rot.sum(axis=1).astype(np.float32) / 255.0
            # skoru keskinleştirmek için hem varyans hem de farkların varyansını kullan
            score = float(np.var(proj) + np.var(np.diff(proj)))
            if score > best_score:
                best_score = score
                best_angle = float(a)

        return best_angle, best_score

    # ---- HOUGH-BAZLI SKEW (opsiyonel) ----
    def _deskew_hough_angle(bgr_small: np.ndarray, cap: float = 10.0) -> Tuple[float, int]:
        try:
            gray = cv2.cvtColor(bgr_small, cv2.COLOR_BGR2GRAY)
            g = cv2.GaussianBlur(gray, (3,3), 0)
            edges = cv2.Canny(g, 50, 150)
            edges = cv2.dilate(edges, np.ones((3,3), np.uint8), iterations=1)
            lines = cv2.HoughLinesP(edges, 1, np.pi/1800, threshold=120,
                                    minLineLength=max(30, min(bgr_small.shape[:2])//15),
                                    maxLineGap=10)
            if lines is None: return 0.0, 0
            angs=[]
            L = lines.squeeze(axis=1) if lines.ndim == 3 else lines
            for x1,y1,x2,y2 in L:
                dx,dy=x2-x1,y2-y1
                ang = 90.0 if dx==0 else np.degrees(np.arctan2(dy,dx))
                while ang <= -90: ang += 180
                while ang >   90: ang -= 180
                if abs(ang) <= cap: angs.append(float(ang))
            if not angs: return 0.0, 0
            a = np.array(angs, dtype=np.float32)
            med = float(np.median(a)); mad = float(np.median(np.abs(a-med))+1e-6)
            keep = np.abs(a-med) <= 3.5*mad
            a2 = a[keep] if keep.any() else a
            return float(np.median(a2)), int(len(a2))
        except Exception:
            return 0.0, 0

    def _imshow_before_after(before: np.ndarray, after: np.ndarray, title: str):
        if not debug: return
        import matplotlib.pyplot as plt
        plt.figure(figsize=(12, 6))
        ax1 = plt.subplot(1,2,1); ax1.imshow(cv2.cvtColor(before, cv2.COLOR_BGR2RGB)); ax1.set_title("Before"); ax1.axis("off")
        ax2 = plt.subplot(1,2,2); ax2.imshow(cv2.cvtColor(after,  cv2.COLOR_BGR2RGB)); ax2.set_title("After");  ax2.axis("off")
        plt.suptitle(title); plt.tight_layout(); plt.show()

    def _normalize_dpi_tuple(dpi_xy) -> Optional[Tuple[int,int]]:
        if dpi_xy is None: return None
        try:
            x,y = int(dpi_xy[0]), int(dpi_xy[1])
            if x <= 1 and y <= 1: return None
            return (x,y)
        except Exception:
            return None

    # ---------- raster: PDF / TIFF ----------
    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    pages_raw: List[Tuple[int, np.ndarray, Optional[Tuple[int,int]], str, Optional[int]]] = []
    # (index, BGR, dpi_xy, source, tiff_orientation_tag)

    if ext == ".pdf":
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                scale = pdf_dpi / 72.0
                pix = page.get_pixmap(matrix=fitz.Matrix(scale, scale), alpha=False, colorspace=fitz.csRGB)
                buf = np.frombuffer(pix.samples, dtype=np.uint8)
                if pix.n == 3:
                    arr = buf.reshape(pix.h, pix.w, 3).copy()
                elif pix.n == 1:
                    arr = cv2.cvtColor(buf.reshape(pix.h, pix.w), cv2.COLOR_GRAY2RGB)
                else:
                    rgba = buf.reshape(pix.h, pix.w, pix.n)[:, :, :4].copy()
                    bgr = _rgba_to_bgr_on_white(rgba)
                    pages_raw.append((i, bgr, (pdf_dpi, pdf_dpi), "pdf_raster", None))
                    continue
                bgr = cv2.cvtColor(arr, cv2.COLOR_RGB2BGR) if return_bgr else arr
                pages_raw.append((i, bgr, (pdf_dpi, pdf_dpi), "pdf_raster", None))
        finally:
            doc.close()
        doc_str = "pdf_doc"

    elif ext in (".tif", ".tiff"):
        doc_str = "tiff_doc"
        if _HAS_TIFF:
            with tiff.TiffFile(p.as_posix()) as tf:
                for i, pg in enumerate(tf.pages):
                    try:
                        comp = getattr(pg, "compression", None)
                        if comp is not None and "CCITT" in str(comp):
                            raise NotImplementedError("CCITT -> Pillow fallback")
                        arr = pg.asarray()
                        bgr = _ensure_bgr(arr)
                        dpi_xy = None
                        try:
                            xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
                            if xr and yr and ru:
                                def _rat(tag): num, den = tag.value; return float(num)/float(den)
                                x, y = _rat(xr), _rat(yr)
                                if getattr(ru, "value", ru) == 3: x *= 2.54; y *= 2.54
                                dpi_xy = _normalize_dpi_tuple((int(round(x)), int(round(y))))
                        except Exception:
                            dpi_xy = None
                        orient = None
                        try: orient = (pg.tags.get("Orientation") or {}).value
                        except Exception: pass
                        pages_raw.append((i, bgr, dpi_xy, "tifffile", orient))
                    except Exception:
                        with Image.open(p.as_posix()) as im:
                            im.seek(i)
                            pil = im.convert("RGB")
                            arr = np.array(pil)
                            bgr = cv2.cvtColor(arr, cv2.COLOR_RGB2BGR)
                            dpi_xy = _normalize_dpi_tuple(pil.info.get("dpi")) if isinstance(pil.info.get("dpi"), (tuple, list)) else None
                            pages_raw.append((i, bgr, dpi_xy, "pillow", None))
        else:
            with Image.open(p.as_posix()) as im:
                n = getattr(im, "n_frames", 1)
                for i in range(n):
                    im.seek(i)
                    pil = im.convert("RGB")
                    arr = np.array(pil)
                    bgr = cv2.cvtColor(arr, cv2.COLOR_RGB2BGR)
                    dpi_xy = _normalize_dpi_tuple(pil.info.get("dpi")) if isinstance(pil.info.get("dpi"), (tuple, list)) else None
                    pages_raw.append((i, bgr, dpi_xy, "pillow", None))
    else:
        raise ValueError(f"Unsupported extension: {ext}")

    # ---------- process: EXIF -> OSD -> (optional) keywords -> DESKEW ----------
    images: List[np.ndarray] = []
    metas: List[Dict[str, Any]] = []

    kw_enabled = (
        enable_keyword_rotation and
        tc_new is not None and
        isinstance(keywords, list) and
        any(isinstance(k, str) and k.strip() for k in keywords)
    )
    kw_list = [k for k in (keywords or []) if isinstance(k, str) and k.strip()]

    for (i, bgr0, dpi_xy, source, orient_tag) in pages_raw:
        # EXIF (TIFF) – kayıpsız
        exif_deg = 0
        if orient_tag is not None:
            bgr1, exif_deg = _apply_exif_orientation(bgr0, orient_tag)
        else:
            bgr1 = bgr0

        # OSD (küçük kopya) ve mapping
        small1 = _make_small(bgr1)
        osd_deg_cw, osd_conf = _osd_detect_deg_cw(small1)
        osd_to_ccw = _osd_cw_to_ccw_deg(osd_deg_cw)

        # OSD right-angle uygula (kayıpsız)
        bgr2 = _apply_right_angle_ccw(bgr1, osd_to_ccw)

        # (opsiyonel) Keyword self-check: 0/±90/180
        best_ra = 0
        best_score = 0
        best_img = bgr2

        if kw_enabled:
            candidate_ras = [0, 90, 180, -90]
            best_score = -1
            for ra in candidate_ras:
                prev_img = _apply_right_angle_ccw(bgr2, ra) if ra != 0 else bgr2
                txt = _tc_new_text(_make_small(prev_img))
                score = _keyword_score(txt, kw_list)
                if score > best_score:
                    best_score = score
                    best_ra = ra
                    best_img = prev_img

        # DESKEW (küçük açı, kırpmasız)
        small2 = _make_small(best_img)
        deskew_deg = 0.0
        proj_score = 0.0
        hough_deg, hough_n = 0.0, 0

        if deskew:
            if deskew_method == "projection":
                deskew_deg, proj_score = _deskew_projection_angle(small2, deskew_max_abs, deskew_step)
            elif deskew_method == "hough":
                hough_deg, hough_n = _deskew_hough_angle(small2, cap=min(deskew_max_abs, 15.0))
                deskew_deg = float(hough_deg)
            else:  # 'auto': her ikisini dene, daha güvenilir olanı seç
                a1, s1 = _deskew_projection_angle(small2, deskew_max_abs, deskew_step)
                a2, n2 = _deskew_hough_angle(small2, cap=min(deskew_max_abs, 15.0))
                # basit seçim kuralı: projeksiyon skoru belirginse onu al, değilse hough
                if s1 > 0 and (n2 < 10 or abs(a2) < 0.2):
                    deskew_deg, proj_score = a1, s1
                else:
                    deskew_deg, hough_deg, hough_n = a2, a2, n2

        bgr3 = _rotate_full_canvas(best_img, float(deskew_deg))
        total_deg = float(exif_deg + osd_to_ccw + best_ra + deskew_deg)

        if debug:
            _imshow_before_after(bgr0, bgr3, f"Page {i} | total={total_deg:.2f}°")

        images.append(bgr3)
        metas.append({
            "page_index": i,
            "dpi": dpi_xy,
            "shape": tuple(bgr3.shape),
            "source": source,
            "exif_orientation_applied_deg": int(exif_deg),
            "osd_raw_deg_cw": (None if osd_deg_cw is None else int(osd_deg_cw)),
            "osd_confidence": (None if osd_conf is None else float(osd_conf)),
            "osd_to_ccw_deg": int(osd_to_ccw),
            "keyword_rotation_enabled": bool(kw_enabled),
            "keyword_best_ccw_deg": int(best_ra),
            "keyword_match_score": int(best_score if kw_enabled else 0),
            "deskew_method": deskew_method,
            "deskew_deg": float(deskew_deg),          # UYGULANAN düzeltme açısı (CCW)
            "deskew_projection_score": float(proj_score),
            "deskew_hough_deg": float(hough_deg),
            "deskew_hough_votes": int(hough_n),
            "total_rotation_applied_deg": total_deg
        })

    return {
        "path": str(p),
        "doc_str": "pdf_doc" if ext == ".pdf" else "tiff_doc",
        "page_count": len(images),
        "images": images,     # sayfa sayfa BGR
        "metas": metas
    }