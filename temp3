def load_document_lossless(
    path: Union[str, Path],
    *,
    mode: str = "auto",        # PDF: "auto" | "native_only" | "raster_only"
    raster_dpi: int = 600,     # PDF rasterizasyon DPI
    enforce_rgb: bool = False, # True -> tüm çıktıları RGB'ye normalize et
    debug: bool = False,       # True -> sayfa sayfa görsel göster + özet
    cover_thresh: float = 0.97 # PDF’te sayfayı kaplayan gömülü görsel eşiği
) -> Dict[str, Any]:
    """
    PDF/TIFF belgeyi çok sayfalı biçimde lossless (mümkün olduğunda) veya tek-sefer raster ile okur.
    Dönen sözlük:
      {"doc_str": "pdf_doc"|"tiff_doc", "path": str, "page_count": int, "pages": [
          {"index": i, "dpi": int|(int,int)|None, "shape": tuple, "dtype": str, "image": np.ndarray}, ...
      ]}
    """
    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    out: Dict[str, Any] = {"doc_str": None, "path": str(p), "page_count": 0, "pages": []}

    # ---- iç yardımcılar ----
    def _imshow(img: np.ndarray, title: str):
        if not debug:
            return
        plt.figure()
        if img.ndim == 2:
            plt.imshow(img, cmap="gray")
        else:
            # matplotlib RGB bekler; burada RGB varsayıyoruz (PDF raster RGB üretir).
            plt.imshow(img)
        plt.title(title); plt.axis("off"); plt.show()

    def _cv_imdecode_exact(b: bytes) -> np.ndarray:
        buf = np.frombuffer(b, dtype=np.uint8)
        im = cv2.imdecode(buf, cv2.IMREAD_UNCHANGED)
        if im is None:
            raise ValueError("cv2.imdecode failed (embedded format unsupported).")
        return im  # dtype/kanal korunur (1-bit/L/RGB/RGBA olabilir)

    def _pdf_try_native_page_image(doc: fitz.Document, page: fitz.Page) -> Optional[np.ndarray]:
        # 1) tek görsel + metin yok → doğrudan
        imgs = page.get_images(full=True)
        if len(imgs) == 1 and not page.get_text("blocks"):
            xref = imgs[0][0]
            data = doc.extract_image(xref)["image"]
            return _cv_imdecode_exact(data)
        # 2) sayfayı neredeyse kaplayan görsel(ler)
        page_area = float(page.rect.get_area())
        for info in page.get_image_info(xrefs=True):
            bbox = info.get("bbox")
            if bbox and (bbox.get_area() / page_area) >= cover_thresh:
                data = doc.extract_image(info["xref"])["image"]
                return _cv_imdecode_exact(data)
        return None

    def _pixmap_to_numpy_rgb(pix: fitz.Pixmap) -> np.ndarray:
        arr = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.h, pix.w, pix.n)
        if pix.n == 1:          # GRAY
            return arr
        return arr[:, :, :3]    # RGB

    def _tiff_dpi_from_tifffile(pg: "tiff.TiffPage") -> Optional[Tuple[int,int]]:
        xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
        if not (xr and yr and ru):
            return None
        def rat(tag):
            num, den = tag.value
            return float(num) / float(den)
        x, y = rat(xr), rat(yr)
        # ResolutionUnit: 2 inç, 3 cm
        if ru.value == 3:  # dpcm -> dpi
            x *= 2.54; y *= 2.54
        return int(round(x)), int(round(y))

    def _tiff_dpi_from_pillow(img: Image.Image) -> Optional[Tuple[int,int]]:
        # Pillow >=10: dpi info -> img.info.get("dpi"); yoksa tag (282/283/296)
        dpi = img.info.get("dpi")
        if isinstance(dpi, (tuple, list)) and len(dpi) >= 2:
            return int(round(float(dpi[0]))), int(round(float(dpi[1])))
        tags = getattr(img, "tag", None)
        if tags:
            xr, yr, ru = tags.get(282), tags.get(283), tags.get(296)
            if xr is not None and yr is not None and ru is not None:
                def _to_float(v):
                    if isinstance(v, (tuple, list)) and len(v) == 2 and all(isinstance(t, int) for t in v):
                        return v[0] / v[1]
                    try:
                        return float(v)
                    except Exception:
                        return None
                x = _to_float(xr); y = _to_float(yr)
                if x is None or y is None:
                    return None
                if int(ru) == 3:  # dpcm -> dpi
                    x *= 2.54; y *= 2.54
                return int(round(x)), int(round(y))
        return None

    # ---- PDF yolu ----
    if ext == ".pdf":
        out["doc_str"] = "pdf_doc"
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                img = None; dpi_val = None

                if mode in ("auto", "native_only"):
                    try:
                        img = _pdf_try_native_page_image(doc, page)
                    except Exception:
                        img = None
                    if img is not None:
                        dpi_val = None  # gömülü resimlerde DPI etiketi olmayabilir
                    elif mode == "native_only":
                        raise RuntimeError(f"PDF page {i}: no native raster found (native_only).")

                if img is None:
                    # vektör/karma içerik → tek sefer rasterizasyon (RGB)
                    scale = raster_dpi / 72.0
                    pix = page.get_pixmap(matrix=fitz.Matrix(scale, scale), alpha=False, colorspace=fitz.csRGB)
                    img = _pixmap_to_numpy_rgb(pix)
                    dpi_val = raster_dpi

                # normalize istenirse
                if enforce_rgb:
                    if img.ndim == 2:
                        img = cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)
                    elif img.ndim == 3 and img.shape[2] == 4:
                        img = img[:, :, :3]

                _imshow(img, f"PDF p{i} | shape={img.shape} | dpi={dpi_val}")
                out["pages"].append({
                    "index": i, "dpi": dpi_val, "shape": tuple(img.shape),
                    "dtype": str(img.dtype), "image": img
                })
        finally:
            doc.close()

    # ---- TIFF yolu ----
    elif ext in (".tif", ".tiff"):
        out["doc_str"] = "tiff_doc"
        # 1) tifffile ile dene (imagecodecs varsa CCITT/LZW vs. çalışır)
        try:
            with tiff.TiffFile(p.as_posix()) as tf:
                for i, pg in enumerate(tf.pages):
                    arr = pg.asarray()  # 1:1 ham piksel
                    dpi_xy = _tiff_dpi_from_tifffile(pg)
                    if enforce_rgb:
                        if arr.ndim == 2:
                            arr = cv2.cvtColor(arr, cv2.COLOR_GRAY2RGB)
                        elif arr.ndim == 3 and arr.shape[2] == 4:
                            arr = arr[:, :, :3]
                    _imshow(arr, f"TIFF p{i} | shape={arr.shape} | dpi={dpi_xy}")
                    out["pages"].append({
                        "index": i, "dpi": dpi_xy, "shape": tuple(arr.shape),
                        "dtype": str(arr.dtype), "image": arr
                    })
        except Exception:
            # 2) Pillow fallback (CCITT/LZW codec yoksa)
            with Image.open(p.as_posix()) as im:
                n_frames = getattr(im, "n_frames", 1)
                for i in range(n_frames):
                    im.seek(i)
                    frame = im.copy()
                    dpi_xy = _tiff_dpi_from_pillow(frame)

                    # 1-bit (fax) için 0/1 -> 0/255 genişletme (bilgi kaybı yok)
                    if frame.mode == "1":
                        arr = np.array(frame, dtype=np.uint8) * 255
                        if enforce_rgb:
                            arr = cv2.cvtColor(arr, cv2.COLOR_GRAY2RGB)
                    elif frame.mode in ("L", "P"):
                        arr = np.array(frame, dtype=np.uint8)
                        if enforce_rgb:
                            arr = cv2.cvtColor(arr, cv2.COLOR_GRAY2RGB)
                    elif frame.mode in ("RGB", "RGBA"):
                        arr = np.array(frame)
                        if enforce_rgb and arr.ndim == 3 and arr.shape[2] == 4:
                            arr = arr[:, :, :3]
                    else:
                        # bilinmeyen modları güvenli tarafta RGB'ye çevir
                        arr = np.array(frame.convert("RGB"))

                    _imshow(arr, f"TIFF(pillow) p{i} | shape={arr.shape} | dpi={dpi_xy}")
                    out["pages"].append({
                        "index": i, "dpi": dpi_xy, "shape": tuple(arr.shape),
                        "dtype": str(arr.dtype), "image": arr
                    })

    else:
        raise ValueError(f"Unsupported extension: {ext}")

    out["page_count"] = len(out["pages"])
    if debug:
        print(f"\nBelge: {out['path']}\nTür: {out['doc_str']}\nSayfa: {out['page_count']}")
        for pg in out["pages"]:
            print(f"p{pg['index']:>3}  shape={pg['shape']}  dtype={pg['dtype']}  dpi={pg['dpi']}")
    return out