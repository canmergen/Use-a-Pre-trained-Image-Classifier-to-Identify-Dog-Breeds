from __future__ import annotations
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union
import numpy as np
import cv2
import fitz              # PyMuPDF
import tifffile as tiff
import matplotlib.pyplot as plt

# ----------------- yardımcılar -----------------

def _cv_imdecode_exact(img_bytes: bytes) -> np.ndarray:
    """Bayttan görseli yeniden kodlamadan NumPy'a aç (IMREAD_UNCHANGED)."""
    buf = np.frombuffer(img_bytes, dtype=np.uint8)
    img = cv2.imdecode(buf, cv2.IMREAD_UNCHANGED)
    if img is None:
        raise ValueError("cv2.imdecode başarısız: gömülü format desteklenmiyor.")
    return img  # dtype ve kanal düzeni dosyadaki gibidir (BGR/RGB/GRAY/RGBA)

def _tiff_page_dpi(pg: tiff.TiffPage) -> Optional[Tuple[int, int]]:
    xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
    if not (xr and yr and ru):
        return None
    def rat(tag):
        num, den = tag.value
        return float(num) / float(den)
    x, y = rat(xr), rat(yr)
    # 2=inç, 3=cm
    if ru.value == 3:  # dpcm -> dpi
        x *= 2.54
        y *= 2.54
    return int(round(x)), int(round(y))

def _pdf_try_native_page_image(doc: fitz.Document, page: fitz.Page, cover_thresh: float = 0.97) -> Optional[np.ndarray]:
    """Sayfa tek/kaplayıcı gömülü raster içeriyorsa onu bayt düzeyinde çıkar; yoksa None."""
    imgs = page.get_images(full=True)
    if len(imgs) == 1 and not page.get_text("blocks"):
        xref = imgs[0][0]
        data = doc.extract_image(xref)["image"]
        return _cv_imdecode_exact(data)

    page_area = float(page.rect.get_area())
    for info in page.get_image_info(xrefs=True):
        bbox = info.get("bbox")
        if not bbox:
            continue
        if (bbox.get_area() / page_area) >= cover_thresh:
            data = doc.extract_image(info["xref"])["image"]
            return _cv_imdecode_exact(data)
    return None

def _pixmap_to_ndarray(pix: fitz.Pixmap) -> np.ndarray:
    """PyMuPDF Pixmap -> np.ndarray (RGB veya GRAY). Alfa kanalını atar."""
    arr = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.h, pix.w, pix.n)
    if pix.n == 1:
        return arr  # GRAY, HxW
    return arr[:, :, :3]  # RGB, HxWx3

def _imshow_any(img: np.ndarray, title: str = ""):
    """Renk uzayına bakıp doğru şekilde çizer (matplotlib)."""
    plt.figure()
    if img.ndim == 2:
        plt.imshow(img, cmap="gray")
    else:
        # OpenCV BGR olabilir, PNG native RGBA olabilir; en güvenlisi heuristik:
        if img.shape[2] == 4:
            # RGBA varsayalım
            plt.imshow(img)
        else:
            # 3 kanal: çoğu durumda RGB veya BGR.
            # BGR olup olmadığını kesin bilemesek de PDF rasterizasyonunda RGB döndürüyoruz.
            plt.imshow(img)
    plt.title(title)
    plt.axis("off")
    plt.show()

# ----------------- ana API -----------------

def load_document_lossless(
    path: Union[str, Path],
    *,
    mode: str = "auto",        # "auto" | "native_only" | "raster_only"
    raster_dpi: int = 600,     # PDF rasterizasyon DPI'ı (tek sefer)
    enforce_rgb: bool = False, # True -> görüntüleri zorla RGB'ye çevir
    debug: bool = False,       # True -> sayfa sayfa ekranda göster ve özet yaz
    cover_thresh: float = 0.97 # PDF sayfayı kaplayan görsel eşiği
) -> Dict[str, Any]:
    """
    PDF/TIFF belgeyi çok sayfalı biçimde lossless (mümkün olduğunda) okur ve NumPy görsellere çevirir.

    TIFF:
      - Sayfalar 1:1 piksel olarak alınır (yeniden örnekleme yok), dtype korunur.
    PDF:
      - mode="auto": varsa gömülü raster 1:1 çıkar; yoksa tek sefer rasterize (raster_dpi).
      - mode="native_only": yalnızca gömülü raster kabul; yoksa hata.
      - mode="raster_only": her koşulda rasterize (raster_dpi).
    """
    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    out: Dict[str, Any] = {"doc_str": None, "path": str(p), "page_count": 0, "pages": []}

    if ext == ".pdf":
        out["doc_str"] = "pdf_doc"
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                img: Optional[np.ndarray] = None
                dpi_val: Optional[int] = None

                if mode in ("auto", "native_only"):
                    img = _pdf_try_native_page_image(doc, page, cover_thresh=cover_thresh)
                    if img is not None:
                        dpi_val = None  # gömülü resimlerde DPI etiketi olmayabilir
                    elif mode == "native_only":
                        raise RuntimeError(f"PDF sayfa {i}: Gömülü raster bulunamadı (native_only).")

                if img is None:
                    # Vektör/karma içerik -> tek sefer rasterizasyon (RGB)
                    scale = raster_dpi / 72.0
                    pix = page.get_pixmap(matrix=fitz.Matrix(scale, scale), alpha=False, colorspace=fitz.csRGB)
                    img = _pixmap_to_ndarray(pix)   # RGB veya GRAY
                    dpi_val = raster_dpi

                # İstenirse zorla RGB (OCR zincirini standartlaştırmak için)
                if enforce_rgb:
                    if img.ndim == 2:
                        img = cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)
                    elif img.ndim == 3 and img.shape[2] == 4:
                        img = img[:, :, :3]

                # Debug gösterim
                if debug:
                    ttl = f"PDF p{i} | shape={img.shape} | dpi={dpi_val}"
                    _imshow_any(img, title=ttl)

                out["pages"].append({
                    "index": i,
                    "dpi": dpi_val,
                    "shape": tuple(img.shape),
                    "dtype": str(img.dtype),
                    "image": img
                })
        finally:
            doc.close()

    elif ext in (".tif", ".tiff"):
        out["doc_str"] = "tiff_doc"
        with tiff.TiffFile(p.as_posix()) as tf:
            for i, pg in enumerate(tf.pages):
                arr = pg.asarray()            # ham piksel (1:1), dtype korunur
                dpi_xy = _tiff_page_dpi(pg)   # (x,y) veya None

                # İstenirse zorla RGB
                if enforce_rgb:
                    if arr.ndim == 2:
                        arr = cv2.cvtColor(arr, cv2.COLOR_GRAY2RGB)
                    elif arr.ndim == 3 and arr.shape[2] == 4:
                        arr = arr[:, :, :3]  # alfa at

                # Debug gösterim
                if debug:
                    ttl = f"TIFF p{i} | shape={arr.shape} | dpi={dpi_xy}"
                    _imshow_any(arr, title=ttl)

                out["pages"].append({
                    "index": i,
                    "dpi": dpi_xy,
                    "shape": tuple(arr.shape),
                    "dtype": str(arr.dtype),
                    "image": arr
                })

    else:
        raise ValueError(f"Desteklenmeyen uzantı: {ext}")

    out["page_count"] = len(out["pages"])

    # Debug özet
    if debug:
        print(f"\nBelge: {out['path']}")
        print(f"Tür   : {out['doc_str']}")
        print(f"Sayfa : {out['page_count']}\n")
        for pg in out["pages"]:
            print(f"p{pg['index']:>3}  shape={pg['shape']}  dtype={pg['dtype']}  dpi={pg['dpi']}")

    return out