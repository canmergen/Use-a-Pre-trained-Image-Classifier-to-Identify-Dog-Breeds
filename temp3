from typing import Any, Dict, List, Optional, Tuple
import re, unicodedata
import numpy as np
import pandas as pd
from rapidfuzz import fuzz

def run_perbox_pipeline(
    lower_img: np.ndarray,
    result: Dict[str, Any],
    table_df_final: pd.DataFrame,
    NEW_URL: str,
    known_names: Optional[List[str]] = None,
    role_threshold: float = 0.60,
    name_sim_threshold: float = 0.88,
    psm_list: Tuple[int,...] = (11, 6),
    oem_list: Tuple[int,...] = (1, 3),
    lang: str = "tur+eng",
    debug: bool = False,
):
    # ----------- utils ----------
    def strip_diac(s: str) -> str:
        return ''.join(c for c in unicodedata.normalize('NFKD', s) if not unicodedata.combining(c))
    def norm_space(s: str) -> str:
        return re.sub(r"\s+", " ", (s or "").strip())
    def ascii_up(s: str) -> str:
        return strip_diac(s).upper()
    def tr_upper(s: str) -> str:
        # Türkçe büyük harf dönüşümü: aksanları KORUR (İ, I, Ğ, Ş, Ç, Ö, Ü dahil)
        # Not: Python .upper() Türkçe locale olmadan i→İ yapmaz; düzeltelim.
        s = (s or "")
        s = s.replace("i", "İ").replace("ı", "I")
        return s.upper()

    def canon_key(name: str) -> str:
        # diakritiksiz, büyük, yalnızca harf + tek boşluk; 2+ harfli tokenlar
        k = re.sub(r"[^A-ZÇĞİÖŞÜ ]", "", tr_upper(strip_diac(name)))
        toks = [t for t in k.split() if len(t) >= 2]
        return " ".join(toks)

    ROLE_ALIASES = {
        "toplanti_baskani":    ["TOPLANTI BAŞKANI","TOPLANTI BASKANI"],
        "tutanak_yazmani":     ["TUTANAK YAZMANI","YAZMAN"],
        "bakanlik_temsilcisi": ["BAKANLIK TEMSİLCİSİ","TİCARET BAKANLIĞI TEMSİLCİSİ","TICARET BAKANLIGI TEMSILCISI"],
        "yk_baskani":          ["YÖNETİM KURULU BAŞKANI","YONETIM KURULU BASKANI","YK BAŞKANI","YK BASKANI"],
        "yk_uyesi":            ["YÖNETİM KURULU ÜYESİ","YONETIM KURULU UYESI","YK ÜYESİ","YK UYESI","YÖNETİM KURULU ÜYELERİ"],
        "katip":               ["KÂTİP","KATİP","OY TOPLAMA MEMURU","OY TOPLAYICI"],
        "divan_baskani":       ["DİVAN BAŞKANI","DIVAN BASKANI"],
    }
    ROLE_PRIORITY = ["toplanti_baskani","yk_baskani","yk_uyesi","bakanlik_temsilcisi","katip","divan_baskani","tutanak_yazmani"]

    # ASCII varyantları dahil geniş rol sözcük kümesi
    ROLE_WORDS = {
        "TOPLANTI","BAŞKANI","BAŞKAN","YÖNETİM","KURULU","ÜYESİ","ÜYE","YAZMAN","YAZMANI",
        "KÂTİP","KATİP","TEMSİLCİSİ","BAKANLIK","DİVAN","OY","TOPLAMA","MEMURU","YK","BŞK",
        "BASKANI","YONETIM","KURULU","UYESI","KATIP","TEMSILCISI","DIVAN","BSK"
    }
    STOP_SHORT = {"DR","SN","PZ","MR","MRS","MS","DR.","SN.","AV","AV."}

    # ----------- known names (kanonik aksanlı) ----------
    if known_names is None:
        pools=[]
        for c in ["pay_sahibinin_ad_soyadi_unvani","temsilci_adi_soyadi_unvani"]:
            if c in table_df_final.columns:
                pools.append(table_df_final[c].dropna().astype(str))
        known_names = pd.concat(pools).dropna().astype(str).unique().tolist() if pools else []
    KN_CANON: Dict[str,str] = {}
    for kn in known_names:
        k = canon_key(kn)
        if k and (k not in KN_CANON or len(KN_CANON[k]) < len(kn)):
            KN_CANON[k] = kn  # aksanlı orijinal

    # ----------- geometry ----------
    def to_xywh(obj: Any) -> Optional[Tuple[int,int,int,int]]:
        if isinstance(obj, dict) and "bbox" in obj:
            obj = obj["bbox"]
        if isinstance(obj, (tuple, list, np.ndarray)) and len(obj)==4:
            x1,y1,a,b = [int(round(float(v))) for v in obj]
            if a> x1 and b> y1:  # xyxy
                return (x1, y1, a-x1, b-y1)
            return (x1, y1, a, b)
        if isinstance(obj, dict):
            if all(k in obj for k in ("x","y","w","h")):
                return (int(obj["x"]), int(obj["y"]), int(obj["w"]), int(obj["h"]))
            if all(k in obj for k in ("x0","y0","x1","y1")):
                x0,y0,x2,y2 = int(obj["x0"]), int(obj["y0"]), int(obj["x1"]), int(obj["y1"])
                return (x0, y0, x2-x0, y2-y0)
        if hasattr(obj, "__dict__"):
            def get(o,*n):
                for t in n:
                    if hasattr(o,t): return getattr(o,t)
                return None
            x=get(obj,"x","x0","left"); y=get(obj,"y","y0","top")
            w=get(obj,"w","width");     h=get(obj,"h","height")
            x1=get(obj,"x1","right");   y1=get(obj,"y1","bottom")
            if x is not None and y is not None and w is not None and h is not None:
                return (int(x),int(y),int(w),int(h))
            if x is not None and y is not None and x1 is not None and y1 is not None:
                return (int(x),int(y),int(x1)-int(x),int(y1)-int(y))
        return None
    def to_xyxy(xywh): x,y,w,h = xywh; return (x,y,x+w,y+h)

    # ----------- role detection ----------
    def best_role(text: str):
        t = ascii_up(text)
        best,score=None,0.0
        for rk,aliases in ROLE_ALIASES.items():
            s = max(fuzz.token_set_ratio(t, ascii_up(a)) for a in aliases)/100.0
            if (s>score) or (abs(s-score)<1e-6 and (best is None or ROLE_PRIORITY.index(rk)<ROLE_PRIORITY.index(best))):
                best,score = rk,s
        return best, float(score)

    # ----------- OCR fallback ----------
    def ocr_text(img, xywh):
        x,y,w,h = xywh
        pad = max(3, int(0.04*max(w,h)))
        x1=max(0,x-pad); y1=max(0,y-pad); x2=min(img.shape[1],x+w+pad); y2=min(img.shape[0],y+h+pad)
        crop=(x1,y1,x2-x1,y2-y1)
        best=""; bestq=-1e9
        for psm in psm_list:
            for oem in oem_list:
                try:
                    txt=ocr_text_from_box_remote(lower_img, crop, lang=lang, psm=psm, oem=oem, url=NEW_URL)
                except Exception:
                    txt=""
                q = len(re.findall(r"[A-Za-zÇĞİÖŞÜçğışöü]", txt)) - 2*len(re.findall(r"[^\w\s]", txt))
                if q>bestq: bestq, best = q, txt
        return best

    # ----------- text scrub (ROL ifadelerini SÖK) ----------
    ROLE_PATTERNS = []
    for aliases in ROLE_ALIASES.values():
        for a in aliases:
            aa = re.escape(a)
            ROLE_PATTERNS.append(re.compile(rf"\b{aa}\b", flags=re.IGNORECASE))
            ROLE_PATTERNS.append(re.compile(rf"\b{ascii_up(a)}\b"))
    # tekil rol kelimeleri
    for w in ROLE_WORDS:
        ROLE_PATTERNS.append(re.compile(rf"\b{re.escape(w)}\b", flags=re.IGNORECASE))

    def scrub_roles(text: str) -> str:
        t = norm_space(text or "")
        for pat in ROLE_PATTERNS:
            t = pat.sub(" ", t)
        # ":" veya "-" sonrası boşlukları toparla
        t = re.sub(r"[:\-–—]\s*", " ", t)
        return norm_space(t)

    # ----------- name candidates ----------
    def is_all_caps_ctx(s: str) -> bool:
        letters = re.findall(r"[A-ZÇĞİÖŞÜ]", tr_upper(s))
        return len(letters) >= max(1, int(0.8*len(re.findall(r"[A-Za-zÇĞİÖŞÜçğışöü]", s))))
    def clean_tokens(toks: List[str]) -> List[str]:
        out=[]
        for t in toks:
            tu = tr_upper(t)
            if tu in STOP_SHORT or tu in ROLE_WORDS: continue
            if len(strip_diac(t)) < 2: continue
            out.append(t)
        return out
    def reorder_if_needed(toks: List[str]) -> List[str]:
        if len(toks)==2:
            a,b=toks
            if a.isupper() and b.isupper() and len(strip_diac(a))>=len(strip_diac(b)):
                return [b,a]
        return toks
    def strict_candidates(text: str) -> List[str]:
        text = scrub_roles(text)  # <— kritik: önce rol kırp
        out=[]
        # ALL-CAPS 2–3 uzun kelime
        for m in re.finditer(r"\b([A-ZÇĞİÖŞÜ]{2,}(?:\s+[A-ZÇĞİÖŞÜ]{2,}){1,2})\b", tr_upper(text)):
            toks = reorder_if_needed(clean_tokens(m.group(1).split()))
            if 2 <= len(toks) <= 3:
                out.append(" ".join(toks))
        # Title-Case 2–3 kelime
        for m in re.finditer(r"\b([A-ZÇĞİÖŞÜ][a-zçğıöşü’']+(?:\s+[A-ZÇĞİÖŞÜ][a-zçğıöşü’']+){1,2})\b", text):
            toks = reorder_if_needed(clean_tokens(m.group(1).split()))
            if 2 <= len(toks) <= 3:
                out.append(" ".join(toks))
        # uniq by canon
        seen=set(); res=[]
        for n in out:
            k=canon_key(n)
            if k and k not in seen:
                seen.add(k); res.append(n)
        return res

    def promote_and_format(name: str, ctx: str) -> Optional[str]:
        if not name: return None
        key = canon_key(name)
        best = KN_CANON.get(key)
        if not best:
            # yakın kanonik eşleşme
            for k,v in KN_CANON.items():
                if fuzz.token_set_ratio(key, k)/100.0 >= name_sim_threshold:
                    best = v; break
        if not best:
            toks = clean_tokens(name.split())
            if not (2 <= len(toks) <= 3): return None
            best = " ".join(toks).title()
        # bağlam ALL-CAPS ise aksanlı ALL-CAPS döndür
        return tr_upper(best) if is_all_caps_ctx(ctx) else best

    def dedupe_by_canon(names: List[str]) -> List[str]:
        seen=set(); out=[]
        for n in names:
            k=canon_key(n)
            if k and k not in seen:
                seen.add(k); out.append(n)
        return out

    # ----------- collect boxes ----------
    def normalize_with_ref(seq):
        out=[]
        if seq is None: return out
        try: it=list(seq)
        except: it=[seq]
        for item in it:
            xywh = to_xywh(item if not (isinstance(item,dict) and "bbox" in item) else item["bbox"])
            if xywh and xywh[2]>0 and xywh[3]>0:
                out.append((xywh, item))
        return out

    pairs = normalize_with_ref(result.get("final") or result.get("roles") or [])
    boxes_xywh = [p[0] for p in pairs]
    objs        = [p[1] for p in pairs]
    boxes_xyxy  = [to_xyxy(b) for b in boxes_xywh]

    sigs=[]
    for sb in result.get("sigs", []):
        b = to_xywh(sb if not (isinstance(sb,dict) and "bbox" in sb) else sb["bbox"])
        if b: sigs.append(to_xyxy(b))

    # ----------- per_box_df ----------
    rows=[]
    for i,(xywh,xyxy,obj) in enumerate(zip(boxes_xywh, boxes_xyxy, objs)):
        # metin kaynağı: obj.txt -> OCR fallback
        try: obj_txt = getattr(obj,"txt", None)
        except: obj_txt = None
        if obj_txt is None and isinstance(obj, dict):
            obj_txt = obj.get("txt")
        text = obj_txt if (obj_txt and obj_txt.strip()) else ocr_text(lower_img, xywh)

        role, rscore = best_role(text)

        cands = strict_candidates(text)
        final=[]
        for c in cands:
            p = promote_and_format(c, text)
            if p and all(tr_upper(w) not in ROLE_WORDS for w in p.split()):
                final.append(p)
        final = dedupe_by_canon(final)

        # imza teması (hafif overlap yeter)
        sig_hit = any(
            (max(xyxy[0], s[0]) < min(xyxy[2], s[2]) and max(xyxy[1], s[1]) < min(xyxy[3], s[3]))
            for s in sigs
        )

        rows.append({
            "i": i,
            "bbox": xywh,
            "sig": sig_hit,
            "role_best": role if rscore>=role_threshold else None,
            "role_score": float(rscore),
            "name_in_box": "; ".join(final) if final else None,
            "text_preview": norm_space(text)[:220]
        })

    per_box_df = pd.DataFrame(rows, columns=["i","bbox","sig","role_best","role_score","name_in_box","text_preview"])

    # ----------- sermaye ----------
    sermaye = None
    if "sermaye" in result and result["sermaye"] is not None:
        s_txt = getattr(result["sermaye"], "txt", None) if hasattr(result["sermaye"], "__dict__") else (result["sermaye"].get("txt") if isinstance(result["sermaye"], dict) else None)
        if s_txt:
            m = re.search(r"(\d{1,3}(?:\.\d{3})+)", s_txt)
            if m: sermaye = int(m.group(1).replace(".",""))
    if sermaye is None:
        previews = " ".join(per_box_df["text_preview"].fillna("").tolist())
        m = re.search(r"(\d{1,3}(?:\.\d{3})+)", previews)
        if m: sermaye = int(m.group(1).replace(".",""))
    if sermaye is None and "paylarin_toplam_itibari_degeri(tl)" in table_df_final.columns:
        try:
            sermaye = int(pd.to_numeric(table_df_final["paylarin_toplam_itibari_degeri(tl)"], errors="coerce").fillna(0).sum())
        except Exception:
            pass

    # ----------- bottom_df ----------
    out = {
        "sermaye_toplam_tl": sermaye,
        "toplanti_baskani_ad_soyad": None, "toplanti_baskani_imza_var_mi": None,
        "tutanak_yazmani_ad_soyad":  None, "tutanak_yazmani_imza_var_mi":  None,
        "bakanlik_temsilcisi_ad_soyad": None, "bakanlik_temsilcisi_imza_var_mi": None,
        "yk_uyesi_ad_soyad": None, "yk_uyesi_imza_var_mi": None,
        "yk_baskani_ad_soyad": None, "yk_baskani_imza_var_mi": None,
        "katip_ad_soyad": None, "katip_imza_var_mi": None,
        "divan_baskani_ad_soyad": None, "divan_baskani_imza_var_mi": None,
    }
    name_cols = {
        "toplanti_baskani":"toplanti_baskani_ad_soyad",
        "tutanak_yazmani":"tutanak_yazmani_ad_soyad",
        "bakanlik_temsilcisi":"bakanlik_temsilcisi_ad_soyad",
        "yk_uyesi":"yk_uyesi_ad_soyad",
        "yk_baskani":"yk_baskani_ad_soyad",
        "katip":"katip_ad_soyad",
        "divan_baskani":"divan_baskani_ad_soyad",
    }
    sig_cols = {k: v.replace("_ad_soyad","_imza_var_mi") for k,v in name_cols.items()}

    for _,r in per_box_df.iterrows():
        role=r.get("role_best")
        if not role: continue
        ncol=name_cols.get(role); scol=sig_cols.get(role)
        raw=r.get("name_in_box")
        parts=[p.strip() for p in raw.split(";")] if isinstance(raw,str) and ";" in raw else ([raw.strip()] if isinstance(raw,str) and raw.strip() else [])
        if not parts: continue
        if role=="yk_uyesi":
            out[ncol] = (out[ncol]+"; "+"; ".join(parts)) if out[ncol] else "; ".join(parts)
        else:
            if out[ncol] is None:
                out[ncol] = "; ".join(parts)
        if scol and out[scol] is None:
            out[scol] = bool(r.get("sig"))

    bottom_df = pd.DataFrame([out])

    if debug:
        print(f"[INFO] {len(per_box_df)} box")
        try:
            from IPython.display import display
            display(per_box_df)
            display(bottom_df)
        except Exception:
            pass

    return (lower_img, per_box_df, bottom_df)