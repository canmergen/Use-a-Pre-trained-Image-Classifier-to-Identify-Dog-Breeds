# -*- coding: utf-8 -*-
import os, base64, cv2, numpy as np, requests

TARGET_URL = "https://internalgw/neomediaoperationsinternal/api/clear-ocr/get/v1"
TOKEN_ENV  = "INTGW_ACCESS_KEY"

def _ensure_uint8(x):
    return np.clip(x, 0, 255).astype(np.uint8) if x.dtype != np.uint8 else x

def _to_bgr(img):
    img = _ensure_uint8(img)
    if img.ndim == 2:
        return cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
    if img.ndim == 3 and img.shape[2] == 3:
        return img
    if img.ndim == 3 and img.shape[2] == 4:
        return cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
    raise ValueError(f"Unsupported image shape {img.shape}")

def _encode_png_b64(img_bgr):
    ok, buf = cv2.imencode(".png", img_bgr)
    if not ok:
        raise RuntimeError("PNG encoding failed")
    return base64.b64encode(buf).decode("utf-8")

def _auto_resize(img, max_mb=4.5, min_side=600, debug=False):
    bgr = _to_bgr(img)
    h, w = bgr.shape[:2]
    b64 = _encode_png_b64(bgr)
    mb = len(b64)/1_000_000.0
    if debug: print(f"[OCR] initial size={mb:.2f} MB, shape={h}x{w}")
    if mb <= max_mb: return bgr
    scale = 0.90
    while mb > max_mb and min(h, w) > min_side:
        h, w = int(h*scale), int(w*scale)
        bgr = cv2.resize(bgr, (w, h), interpolation=cv2.INTER_AREA)
        b64 = _encode_png_b64(bgr); mb = len(b64)/1_000_000.0
        if debug: print(f"[OCR] rescaled -> {mb:.2f} MB, shape={h}x{w}")
        scale *= 0.92
    return bgr

def _headers():
    return {
        "Access-Token": os.environ[TOKEN_ENV],
        "Content-Type": "application/json",
    }

def _base_fields():
    # Your exact business fields; only the image-related toggles change
    return {
        "requestHeader": {
            "info": {"correlationPair": [{"key": "AppName", "value": "Postman"}]}
        },
        "customerNo": "10651337",
        "branchCode": "936",
        "channelInfo": "Branch",
        "language": "tr-TR",
        "transactionCode": "",
        "clientIP": "1.1.1.1",
        "clientPort": "0",
        "registrationNo": "49001",
        "userInfo": {
            "userID": "153", "userCode": "49001", "userBranchCode": "936",
            "roles": [{"roleID": "1501"}]
        },
        "performerUserInfo": {
            "userID": "153", "userCode": "49001", "userBranchCode": "936",
            "roles": [{"roleID": "1501"}]
        },
    }

def _try_one(image_b64, *, include_bbox, file_type, add_filename, add_content_type, content_key, debug=False):
    payload = dict(_base_fields())
    # image-related toggles
    payload["includeBbox"] = include_bbox
    if add_filename:
        payload["fileName"] = f"image.{file_type.lower()}"
    payload["fileType"] = file_type
    if add_content_type:
        payload["contentType"] = "image/png"
    payload[content_key] = image_b64

    resp = requests.post(TARGET_URL, headers=_headers(), json=payload, verify=False, timeout=45)
    if debug:
        print(f"HTTP {resp.status_code} :: includeBbox={include_bbox!r}, fileType={file_type}, "
              f"fileName={add_filename}, contentType={add_content_type}, key={content_key}")
        if resp.status_code != 200:
            print(resp.text[:400])
    if resp.status_code != 200:
        return None, (resp.status_code, resp.text[:400])

    data = resp.json()
    pages = (
        data.get("ocrPageResultList")
        or data.get("OcrPageResultList")
        or data.get("result", {}).get("ocrPageResultList")
        or []
    )
    text = "\n".join([(p.get("extractedText") or "") for p in pages]).strip()
    return text, None

def call_paddle_ocr_text_only_array_autoprobe(img, debug=False):
    bgr = _auto_resize(img, debug=debug)
    b64 = _encode_png_b64(bgr)

    include_bbox_opts = [False, "false"]          # bool vs string
    file_type_opts    = ["png", "PNG"]            # case differences
    filename_opts     = [True, False]             # with/without fileName
    content_type_opts = [True, False]             # with/without contentType
    content_keys      = ["content", "imageBase64"]# key name differences

    errors = []
    for ib in include_bbox_opts:
        for ft in file_type_opts:
            for fn in filename_opts:
                for ct in content_type_opts:
                    for ck in content_keys:
                        text, err = _try_one(
                            b64,
                            include_bbox=ib,
                            file_type=ft,
                            add_filename=fn,
                            add_content_type=ct,
                            content_key=ck,
                            debug=debug,
                        )
                        if text is not None:
                            print("\n[OK] schema:",
                                  f"includeBbox={ib!r}, fileType={ft}, fileName={fn}, contentType={ct}, key={ck}")
                            return text
                        else:
                            errors.append((ib, ft, fn, ct, ck, err[0]))
    # If all failed, show a short summary of status codes seen
    codes = sorted(set(code for *_, code in errors))
    print("[Fail] tried", len(errors), "schemas; status codes:", codes)
    return ""

def call_paddle_ocr_text_only_batch_autoprobe(imgs, debug_each=False):
    results = []
    for i, im in enumerate(imgs):
        if im is None:
            results.append(None); continue
        print(f"\n[OCR] Sending image {i} ...")
        txt = call_paddle_ocr_text_only_array_autoprobe(im, debug=debug_each)
        results.append(txt if txt else None)
        print(f"[{i}] result length:", len(txt or ""))
    return results

texts = call_paddle_ocr_text_only_batch_autoprobe(final_lower_imgs, debug_each=True)
for i, t in enumerate(texts):
    print(f"\n=== PAGE {i} ===\n", t or "(No text detected / OCR failed)")