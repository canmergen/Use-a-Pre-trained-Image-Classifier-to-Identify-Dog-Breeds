# doc_to_images.py
# -*- coding: utf-8 -*-

from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import numpy as np
import cv2
import fitz  # PyMuPDF
from PIL import Image
Image.MAX_IMAGE_PIXELS = None

try:
    import tifffile as tiff
    _HAS_TIFFFILE = True
except Exception:
    _HAS_TIFFFILE = False


def convert_document_to_images(
    path: Union[str, Path],
    *,
    pdf_dpi: int = 600,
    apply_orientation: bool = True,
    osd_tc: Any = None,           # TesseractClient benzeri; yoksa OSD atlanır
    osd_conf: float = 0.0,        # OSD güven eşiği
    estimate_skew: bool = True,   # residual skew tahmini
    skew_max_angle: float = 8.0,  # |açı| > bu değer outlier sayılır
    return_bgr: bool = True,      # görüntüyü BGR döndür (OCR için önerilir)
    debug: bool = False
) -> Dict[str, Any]:
    """
    PDF/TIFF dosyasını sayfa sayfa imajlara çevirir (kırpma yok) ve meta döndürür.
    Dönüş:
    {
      "doc_str": "pdf_doc"|"tiff_doc",
      "path": str,
      "page_count": int,
      "pages": [
        {
          "index": int,
          "dpi": (x_dpi, y_dpi) | (pdf_dpi, pdf_dpi) | None,
          "shape": (H, W, 3),
          "dtype": "uint8",
          "mode": "BGR"|"RGB",
          "colorspace": "BGR"|"RGB",
          "source": "pdf_raster"|"tifffile"|"pillow",
          "rotation_deg": float,         # OSD
          "osd_confidence": float|None,  # OSD
          "skew_deg": float|None,        # residual skew
          "image": np.ndarray (BGR veya RGB)
        }, ...
      ],
      "metas": [ {page_index, dpi, shape, rotation_deg, osd_confidence, skew_deg}, ... ]
    }
    """

    # ---------- yardımcılar ----------

    def _imshow(bgr: np.ndarray, title: str):
        if not debug:
            return
        import matplotlib.pyplot as plt
        plt.figure(figsize=(10, 10))
        plt.imshow(cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB))
        plt.title(title)
        plt.axis("off")
        plt.show()

    def _apply_exif_orientation(arr: np.ndarray, orient: Optional[int]) -> np.ndarray:
        # 1: normal, 3: 180, 6: 270 CW, 8: 90 CW
        if orient is None:
            return arr
        if orient == 3:
            return np.rot90(arr, 2)
        if orient == 6:
            return np.rot90(arr, 3)
        if orient == 8:
            return np.rot90(arr, 1)
        return arr

    def _normalize_dpi_tuple(dpi_xy) -> Optional[Tuple[int, int]]:
        if dpi_xy is None:
            return None
        try:
            x, y = int(dpi_xy[0]), int(dpi_xy[1])
            if x <= 1 and y <= 1:
                return None
            return (x, y)
        except Exception:
            return None

    def _rgba_to_bgr_on_white(rgba: np.ndarray) -> np.ndarray:
        # RGBA -> beyaz zemin üstüne kompozit -> BGR
        rgb = rgba[..., :3].astype(np.float32)
        alpha = rgba[..., 3:4].astype(np.float32) / 255.0
        out = rgb * alpha + 255.0 * (1.0 - alpha)
        out = np.clip(out, 0, 255).astype(np.uint8)
        return cv2.cvtColor(out, cv2.COLOR_RGB2BGR)

    def _to_uint8_gray_from_bool_or_u16(arr: np.ndarray, invert: bool = False) -> np.ndarray:
        # bool/16-bit'i güvenle 8-bit griye indir
        if arr.dtype == np.bool_:
            g = arr.astype(np.uint8) * 255
        elif arr.dtype == np.uint16:
            g = cv2.convertScaleAbs(arr, alpha=255.0 / 65535.0)
        else:
            g = arr.astype(np.uint8, copy=False)
        if invert:
            g = 255 - g
        return g

    def _ensure_bgr_safe(arr: np.ndarray, *, photometric: Optional[str] = None) -> np.ndarray:
        # Her türlü girişten BGR üret (bool/L/RGB/RGBA/CMYK/YCbCr/Palet/16-bit)
        if arr.dtype == np.bool_:
            inv = (photometric or "").upper() == "MINISWHITE"
            g = _to_uint8_gray_from_bool_or_u16(arr, invert=inv)
            return cv2.cvtColor(g, cv2.COLOR_GRAY2BGR)

        if arr.ndim == 2:
            inv = (photometric or "").upper() == "MINISWHITE"
            g = _to_uint8_gray_from_bool_or_u16(arr, invert=inv)
            return cv2.cvtColor(g, cv2.COLOR_GRAY2BGR)

        if arr.ndim == 3:
            c = arr.shape[2]
            if c == 3:
                return cv2.cvtColor(arr.astype(np.uint8, copy=False), cv2.COLOR_RGB2BGR)
            if c == 4:
                return _rgba_to_bgr_on_white(arr.astype(np.uint8, copy=False))
            if c > 4:
                return cv2.cvtColor(arr[..., :3].astype(np.uint8, copy=False), cv2.COLOR_RGB2BGR)

        arr = np.squeeze(arr)
        if arr.ndim == 2:
            g = _to_uint8_gray_from_bool_or_u16(arr)
            return cv2.cvtColor(g, cv2.COLOR_GRAY2BGR)
        raise ValueError(f"Unsupported array shape for BGR: {arr.shape}, dtype={arr.dtype}")

    def _osd_rotate_if_needed(bgr: np.ndarray) -> Tuple[np.ndarray, float, Optional[float]]:
        # Proje içinde rotate_img_using_osd varsa kullan; yoksa pas geç
        if osd_tc is None:
            return bgr, 0.0, None
        rotate_fn = None
        try:
            from rotate_utils import rotate_img_using_osd as _rot
            rotate_fn = _rot
        except Exception:
            try:
                rotate_fn = globals().get("rotate_img_using_osd", None)  # type: ignore
            except Exception:
                rotate_fn = None
        if rotate_fn is None:
            return bgr, 0.0, None
        try:
            after_bgr, deg, conf = rotate_fn(bgr, osd_tc=osd_tc, osd_conf=osd_conf)  # type: ignore
            return after_bgr, float(deg or 0.0), (None if conf is None else float(conf))
        except Exception:
            return bgr, 0.0, None

    def _robust_skew_deg(bgr: np.ndarray, max_angle: float = 8.0) -> Optional[float]:
        # Canny+Hough ve minAreaRect fallback ile residual skew tahmini
        try:
            gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
            g = cv2.GaussianBlur(gray, (3, 3), 0)
            edges = cv2.Canny(g, 50, 150)
            edges = cv2.dilate(edges, np.ones((3, 3), np.uint8), iterations=1)
            lines = cv2.HoughLinesP(edges, 1, np.pi / 1800, threshold=120,
                                    minLineLength=max(30, min(bgr.shape[:2]) // 15),
                                    maxLineGap=10)
            angles: List[float] = []
            if lines is not None:
                L = lines.squeeze(axis=1) if lines.ndim == 3 else lines
                for x1, y1, x2, y2 in L:
                    dx, dy = (x2 - x1), (y2 - y1)
                    ang = 90.0 if dx == 0 else np.degrees(np.arctan2(dy, dx))
                    while ang <= -90: ang += 180
                    while ang > 90:   ang -= 180
                    if abs(ang) <= max_angle:
                        angles.append(float(ang))
            if angles:
                a = np.array(angles, dtype=np.float32)
                med = float(np.median(a))
                mad = float(np.median(np.abs(a - med)) + 1e-6)
                keep = np.abs(a - med) <= (3.5 * mad)
                a2 = a[keep] if keep.any() else a
                return float(np.median(a2))

            # fallback
            _, bw = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
            bw = cv2.morphologyEx(bw, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8), iterations=1)
            cnts, _ = cv2.findContours(bw, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
            if not cnts:
                return None
            areas = [cv2.contourArea(c) for c in cnts]
            if not areas:
                return None
            thr = max(50.0, np.percentile(areas, 60))
            angs: List[float] = []
            for c in cnts:
                if cv2.contourArea(c) < thr:
                    continue
                rect = cv2.minAreaRect(c)
                ang = rect[-1]  # [-90,0)
                if ang < -45:
                    ang = 90 + ang
                if abs(ang) <= max_angle:
                    angs.append(float(ang))
            if angs:
                return float(np.median(np.array(angs, dtype=np.float32)))
            return None
        except Exception:
            return None

    # ---------- ana akış ----------

    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    out: Dict[str, Any] = {"doc_str": None, "path": str(p), "page_count": 0, "pages": [], "metas": []}

    # ---- PDF ----
    if ext == ".pdf":
        out["doc_str"] = "pdf_doc"
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                scale = pdf_dpi / 72.0
                # Alfa kapalı render -> siyah sayfa riski yok
                pix = page.get_pixmap(
                    matrix=fitz.Matrix(scale, scale),
                    alpha=False,
                    colorspace=fitz.csRGB
                )
                buf = np.frombuffer(pix.samples, dtype=np.uint8)
                if pix.n == 1:
                    arr = buf.reshape(pix.h, pix.w).copy()
                    arr = cv2.cvtColor(arr, cv2.COLOR_GRAY2RGB)
                elif pix.n == 3:
                    arr = buf.reshape(pix.h, pix.w, 3).copy()  # RGB
                else:
                    # Nadiren gelebilir; beyaz zemin kompoziti
                    rgba = buf.reshape(pix.h, pix.w, pix.n)[:, :, :4].copy()
                    bgr0 = _rgba_to_bgr_on_white(rgba)
                    bgr = bgr0
                    mode = "BGR"
                    source = "pdf_raster"
                    _imshow(bgr, f"PDF p{i} | dpi={pdf_dpi} | {bgr.shape} | RGBA→BGR")
                    # OSD
                    bgr_rot, rot_deg, conf = _osd_rotate_if_needed(bgr)
                    # Skew
                    skew_deg = _robust_skew_deg(bgr_rot, max_angle=skew_max_angle) if estimate_skew else None
                    page_meta = {
                        "index": i,
                        "dpi": (pdf_dpi, pdf_dpi),
                        "shape": tuple(bgr_rot.shape),
                        "dtype": str(bgr_rot.dtype),
                        "mode": mode,
                        "colorspace": mode,
                        "source": source,
                        "rotation_deg": rot_deg,
                        "osd_confidence": conf,
                        "skew_deg": skew_deg,
                    }
                    out["pages"].append({**page_meta, "image": bgr_rot})
                    out["metas"].append({"page_index": i, **{k: page_meta[k] for k in ("dpi", "shape", "rotation_deg", "osd_confidence", "skew_deg")}})
                    continue

                # RGB geldi; BGR'e çevir
                bgr = cv2.cvtColor(arr, cv2.COLOR_RGB2BGR) if return_bgr else arr
                _imshow(bgr if return_bgr else cv2.cvtColor(arr, cv2.COLOR_RGB2BGR),
                        f"PDF p{i} | dpi={pdf_dpi} | {bgr.shape if return_bgr else arr.shape}")

                # OSD
                bgr_rot, rot_deg, conf = _osd_rotate_if_needed(bgr if return_bgr else cv2.cvtColor(arr, cv2.COLOR_RGB2BGR))
                # Skew
                skew_deg = _robust_skew_deg(bgr_rot, max_angle=skew_max_angle) if estimate_skew else None

                page_meta = {
                    "index": i,
                    "dpi": (pdf_dpi, pdf_dpi),
                    "shape": tuple(bgr_rot.shape),
                    "dtype": str(bgr_rot.dtype),
                    "mode": "BGR" if return_bgr else "RGB",
                    "colorspace": "BGR" if return_bgr else "RGB",
                    "source": "pdf_raster",
                    "rotation_deg": rot_deg,
                    "osd_confidence": conf,
                    "skew_deg": skew_deg,
                }
                out["pages"].append({**page_meta, "image": bgr_rot})
                out["metas"].append({"page_index": i, **{k: page_meta[k] for k in ("dpi", "shape", "rotation_deg", "osd_confidence", "skew_deg")}})
        finally:
            doc.close()
        out["page_count"] = len(out["pages"])

    # ---- TIFF ----
    elif ext in (".tif", ".tiff"):
        out["doc_str"] = "tiff_doc"

        def _tiff_with_tifffile(pth: Path) -> List[Dict[str, Any]]:
            pages: List[Dict[str, Any]] = []
            with tiff.TiffFile(pth.as_posix()) as tf:
                for i, pg in enumerate(tf.pages):
                    # metadata
                    try:
                        photometric = str(getattr(pg, "photometric", "") or "")
                        compression = str(getattr(pg, "compression", "") or "")
                        spp = int(getattr(pg, "samplesperpixel", 1))
                    except Exception:
                        photometric, compression, spp = "", "", 1

                    # CCITT/garip renk uzayı/kanal sayısı: Pillow fallback
                    need_pillow = (
                        "CCITT" in compression.upper()
                        or ("RGB" not in photometric.upper() and "MINIS" not in photometric.upper())
                        or spp not in (1, 3, 4)
                    )

                    if need_pillow:
                        pil_img = pg.aspilimage().convert("RGB")
                        arr = np.array(pil_img)
                        bgr = _ensure_bgr_safe(arr, photometric=None)
                        src = "pillow"
                        dpi_xy = None  # Pillow ile tekil sayfa DPI'ını güvenilir almak zor
                    else:
                        arr = pg.asarray()
                        bgr = _ensure_bgr_safe(arr, photometric=photometric)
                        src = "tifffile"
                        # DPI bilgisi
                        dpi_xy = None
                        try:
                            xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
                            if xr and yr and ru:
                                def _rat(tag):
                                    num, den = tag.value
                                    return float(num) / float(den)
                                x, y = _rat(xr), _rat(yr)
                                ru_val = getattr(ru, "value", ru)
                                if ru_val == 3:  # cm
                                    x *= 2.54; y *= 2.54
                                dpi_xy = _normalize_dpi_tuple((int(round(x)), int(round(y))))
                        except Exception:
                            dpi_xy = None

                    _imshow(bgr, f"TIFF p{i} | {src} | {bgr.shape}")

                    # OSD
                    bgr_rot, rot_deg, conf = _osd_rotate_if_needed(bgr)
                    # Skew
                    skew_deg = _robust_skew_deg(bgr_rot, max_angle=skew_max_angle) if estimate_skew else None

                    page_meta = {
                        "index": i,
                        "dpi": dpi_xy,
                        "shape": tuple(bgr_rot.shape),
                        "dtype": str(bgr_rot.dtype),
                        "mode": "BGR",
                        "colorspace": "BGR",
                        "source": src,
                        "rotation_deg": rot_deg,
                        "osd_confidence": conf,
                        "skew_deg": skew_deg,
                    }
                    pages.append({**page_meta, "image": bgr_rot})
            return pages

        def _tiff_with_pillow(pth: Path) -> List[Dict[str, Any]]:
            pages: List[Dict[str, Any]] = []
            with Image.open(pth.as_posix()) as im:
                n = getattr(im, "n_frames", 1)
                for i in range(n):
                    im.seek(i)
                    frame = im.copy()
                    # mod normalize
                    if frame.mode in ("RGB", "RGBA", "L"):
                        safe = frame
                    elif frame.mode == "1":
                        safe = frame.convert("L")
                    else:
                        safe = frame.convert("RGB")
                    arr = np.array(safe)
                    bgr = _ensure_bgr_safe(arr, photometric=None)
                    _imshow(bgr, f"TIFF p{i} | pillow | {bgr.shape}")

                    bgr_rot, rot_deg, conf = _osd_rotate_if_needed(bgr)
                    skew_deg = _robust_skew_deg(bgr_rot, max_angle=skew_max_angle) if estimate_skew else None

                    page_meta = {
                        "index": i,
                        "dpi": _normalize_dpi_tuple(safe.info.get("dpi")) if isinstance(safe.info.get("dpi"), (tuple, list)) else None,
                        "shape": tuple(bgr_rot.shape),
                        "dtype": str(bgr_rot.dtype),
                        "mode": "BGR",
                        "colorspace": "BGR",
                        "source": "pillow",
                        "rotation_deg": rot_deg,
                        "osd_confidence": conf,
                        "skew_deg": skew_deg,
                    }
                    pages.append({**page_meta, "image": bgr_rot})
            return pages

        try:
            if _HAS_TIFFFILE:
                out["pages"] = _tiff_with_tifffile(p)
            else:
                out["pages"] = _tiff_with_pillow(p)
        except Exception:
            # tifffile hata verirse pillow'a düş
            out["pages"] = _tiff_with_pillow(p)

        out["page_count"] = len(out["pages"])
        for pg in out["pages"]:
            out["metas"].append({
                "page_index": pg["index"],
                "dpi": pg["dpi"],
                "shape": pg["shape"],
                "rotation_deg": pg["rotation_deg"],
                "osd_confidence": pg["osd_confidence"],
                "skew_deg": pg["skew_deg"],
            })

    else:
        raise ValueError(f"Unsupported extension: {ext}")

    return out