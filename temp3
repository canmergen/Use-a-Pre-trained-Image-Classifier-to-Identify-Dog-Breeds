from __future__ import annotations
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union
import numpy as np
import cv2
import fitz            # PyMuPDF
import tifffile as tiff

# -------- Helpers --------

def _cv_imdecode_exact(img_bytes: bytes) -> np.ndarray:
    """Bayttan görüntüyü yeniden kodlamadan NumPy'a aç (piksel 1:1)."""
    buf = np.frombuffer(img_bytes, dtype=np.uint8)
    img = cv2.imdecode(buf, cv2.IMREAD_UNCHANGED)
    if img is None:
        raise ValueError("cv2.imdecode başarısız: gömülü format desteklenmiyor.")
    return img  # dtype ve kanal sayısı korunur (örn. GRAY, RGB(A), vb.)

def _pixmap_to_numpy_bgr(pix: fitz.Pixmap) -> np.ndarray:
    """PyMuPDF Pixmap -> np.uint8 HxWxC (BGR)."""
    arr = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.h, pix.w, pix.n)
    if pix.n == 1:
        arr = cv2.cvtColor(arr, cv2.COLOR_GRAY2BGR)
    else:
        arr = arr[:, :, :3][:, :, ::-1]  # RGB -> BGR
    return arr

def _tiff_page_dpi(pg: tiff.TiffPage) -> Optional[Tuple[int, int]]:
    xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
    if not (xr and yr and ru):
        return None
    def rat(tag):
        num, den = tag.value
        return float(num) / float(den)
    x, y = rat(xr), rat(yr)
    if ru.value == 3:  # dpcm -> dpi
        x *= 2.54
        y *= 2.54
    return int(round(x)), int(round(y))

def _pdf_try_native_page_image(doc: fitz.Document, page: fitz.Page, cover_thresh: float = 0.97) -> Optional[np.ndarray]:
    """
    Sayfa tek/kaplayıcı gömülü raster içeriyorsa onu bayt düzeyinde çıkar.
    Bulamazsa None.
    """
    imgs = page.get_images(full=True)
    if len(imgs) == 1 and not page.get_text("blocks"):
        xref = imgs[0][0]
        data = doc.extract_image(xref)["image"]
        return _cv_imdecode_exact(data)

    page_area = page.rect.get_area()
    for info in page.get_image_info(xrefs=True):
        bbox = info.get("bbox")
        if not bbox:
            continue
        if (bbox.get_area() / page_area) >= cover_thresh:
            data = doc.extract_image(info["xref"])["image"]
            return _cv_imdecode_exact(data)
    return None

# -------- Main API --------

def load_document_lossless(
    path: Union[str, Path],
    *,
    mode: str = "auto",          # "auto" | "native_only" | "raster_only"
    raster_dpi: int = 600,       # PDF rasterizasyon DPI'ı (tek sefer)
    enforce_bgr: bool = False    # True -> renk uzayını BGR'a normalize et
) -> Dict[str, Any]:
    """
    Çok-sayfa PDF/TIFF'i sıfır kalite kaybıyla (mümkün olduğunda) veya tek-sefer rasterizasyonla oku.

    - TIFF: her sayfa 1:1 ham piksel (yeniden örnekleme yok), dtype korunur.
    - PDF:
        * mode="auto": mümkünse gömülü görüntüyü 1:1 çıkar; yoksa tek rasterizasyon (raster_dpi).
        * mode="native_only": yalnızca gömülü rasterı kabul et; yoksa hata fırlat.
        * mode="raster_only": her koşulda raster_dpi ile tek rasterizasyon yap.

    Returns:
      {
        "doc_str": "pdf_doc" | "tiff_doc",
        "path": "<abs path>",
        "page_count": N,
        "pages": [
           {"index": i, "dpi": int | (int,int) | None, "shape": (H,W[,C]), "dtype": str, "image": np.ndarray},
           ...
        ]
      }
    """
    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    out: Dict[str, Any] = {"doc_str": None, "path": str(p), "page_count": 0, "pages": []}

    if ext == ".pdf":
        out["doc_str"] = "pdf_doc"
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                img_np: Optional[np.ndarray] = None
                dpi_val: Optional[int] = None

                if mode in ("auto", "native_only"):
                    img_np = _pdf_try_native_page_image(doc, page)
                    if img_np is not None:
                        # Native çıkarım: piksel 1:1; DPI etiketi gömülü olmayabilir
                        dpi_val = None
                    elif mode == "native_only":
                        raise RuntimeError(
                            f"PDF sayfa {i}: Gömülü raster bulunamadı (native_only modunda vazgeçildi)."
                        )

                if img_np is None:  # raster zorunlu
                    scale = raster_dpi / 72.0
                    pix = page.get_pixmap(
                        matrix=fitz.Matrix(scale, scale),
                        alpha=False,
                        colorspace=fitz.csRGB
                    )
                    img_np = _pixmap_to_numpy_bgr(pix) if enforce_bgr else np.frombuffer(
                        pix.samples, dtype=np.uint8
                    ).reshape(pix.h, pix.w, pix.n if pix.n < 4 else 3)
                    if not enforce_bgr and img_np.ndim == 3 and img_np.shape[2] == 4:
                        img_np = img_np[:, :, :3]  # alfa at
                    dpi_val = raster_dpi  # üretilen piksel ızgarasının fiziksel ölçeği

                # Renk uzayı normalize etme (isteğe bağlı)
                if enforce_bgr and img_np.ndim == 3 and img_np.shape[2] == 3:
                    # Native image RGB geldiyse BGR'a çevir
                    # Heuristik: assume RGB -> BGR çevir
                    img_np = img_np[:, :, ::-1] if img_np.flags['C_CONTIGUOUS'] else img_np[..., ::-1]

                out["pages"].append({
                    "index": i,
                    "dpi": dpi_val,
                    "shape": tuple(img_np.shape),
                    "dtype": str(img_np.dtype),
                    "image": img_np
                })
        finally:
            doc.close()

    elif ext in (".tif", ".tiff"):
        out["doc_str"] = "tiff_doc"
        with tiff.TiffFile(p) as tf:
            for i, pg in enumerate(tf.pages):
                arr = pg.asarray()  # ham piksel (kayıpsız)
                dpi_xy = _tiff_page_dpi(pg)
                if enforce_bgr:
                    if arr.ndim == 2:
                        arr = cv2.cvtColor(arr, cv2.COLOR_GRAY2BGR)
                    elif arr.ndim == 3 and arr.shape[2] == 4:  # yaygın RGBA
                        arr = arr[:, :, :3]
                out["pages"].append({
                    "index": i,
                    "dpi": dpi_xy,
                    "shape": tuple(arr.shape),
                    "dtype": str(arr.dtype),
                    "image": arr
                })

    else:
        raise ValueError(f"Desteklenmeyen uzantı: {ext}")

    out["page_count"] = len(out["pages"])
    return out