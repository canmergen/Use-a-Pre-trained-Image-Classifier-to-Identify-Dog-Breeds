# -*- coding: utf-8 -*-
from __future__ import annotations
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import numpy as np
import cv2
import fitz  # PyMuPDF
from PIL import Image
Image.MAX_IMAGE_PIXELS = None

try:
    import tifffile as tiff
    _HAS_TIFF = True
except Exception:
    _HAS_TIFF = False


def convert_document_with_rotation_and_keywords(
    path: Union[str, Path],
    *,
    pdf_dpi: int = 600,
    # OSD: .get_osd_ocr(PIL, ..., output_type='dict') -> {'rotate': 0/90/180/270, 'orientation_conf': ...}
    osd_tc: Any = None,
    # Keyword self-check OCR client (opsiyonel). Aşağıdaki parametrelerle çağrılır.
    tc_new: Any = None,
    keywords: Optional[List[str]] = None,
    enable_keyword_rotation: bool = True,   # <-- İSTEDİĞİN BAYRAK
    tc_new_lang: str = "tur",
    tc_new_psm: Optional[int] = None,
    tc_new_oem: Optional[int] = None,
    tc_new_config: Optional[str] = None,
    # Performans / görselleştirme
    angle_estimation_max_side: int = 1600,  # OSD/OCR preview küçük kopya uzun kenar
    return_bgr: bool = True,
    debug: bool = False
) -> Dict[str, Any]:
    """
    PDF/TIFF -> raster -> EXIF (TIFF) -> OSD (0/90/180/270) -> (opsiyonel) keyword self-check (tc_new)
               -> skew (küçük açı, ±10°) -> kırpmasız döndürme.

    Dönüş:
      {
        "path": str, "doc_str": "pdf_doc"|"tiff_doc", "page_count": int,
        "images": List[np.ndarray (BGR)],
        "metas": [ { ... rotasyon kararları ve skorlar ... }, ... ]
      }
    """

    # ---------------- image helpers ----------------
    def _rgba_to_bgr_on_white(rgba: np.ndarray) -> np.ndarray:
        rgb = rgba[..., :3].astype(np.float32)
        alpha = rgba[..., 3:4].astype(np.float32) / 255.0
        out = rgb * alpha + 255.0 * (1.0 - alpha)
        return cv2.cvtColor(np.clip(out, 0, 255).astype(np.uint8), cv2.COLOR_RGB2BGR)

    def _ensure_bgr(arr: np.ndarray) -> np.ndarray:
        if arr.ndim == 2:
            return cv2.cvtColor(arr.astype(np.uint8, copy=False), cv2.COLOR_GRAY2BGR)
        if arr.ndim == 3 and arr.shape[2] == 3:
            return arr.astype(np.uint8, copy=False)
        if arr.ndim == 3 and arr.shape[2] == 4:
            return arr[:, :, :3].astype(np.uint8, copy=False)
        s = np.squeeze(arr)
        if s.ndim == 2:
            return cv2.cvtColor(s.astype(np.uint8, copy=False), cv2.COLOR_GRAY2BGR)
        if s.ndim == 3 and s.shape[2] >= 3:
            return s[:, :, :3].astype(np.uint8, copy=False)
        raise ValueError(f"Unsupported array shape for BGR: {arr.shape}")

    def _apply_exif_orientation(bgr: np.ndarray, orient: Optional[int]) -> Tuple[np.ndarray, int]:
        # 1: normal, 3: 180, 6: 270 CW(== +90 CCW), 8: 90 CW(== -90 CCW)
        deg = 0
        if orient == 3:   return np.rot90(bgr, 2).copy(), 180
        if orient == 6:   return np.rot90(bgr, 1).copy(),  90
        if orient == 8:   return np.rot90(bgr, 3).copy(), -90
        return bgr, deg

    def _rotate_full_canvas(bgr: np.ndarray, angle_ccw: float) -> np.ndarray:
        # kırpmasız döndürme (canvas genişletilir)
        if abs(angle_ccw) < 1e-6:
            return bgr
        (h, w) = bgr.shape[:2]
        c = (w / 2.0, h / 2.0)
        M = cv2.getRotationMatrix2D(c, angle_ccw, 1.0)
        cos = abs(M[0, 0]); sin = abs(M[0, 1])
        nW = int((h * sin) + (w * cos))
        nH = int((h * cos) + (w * sin))
        M[0, 2] += (nW / 2) - c[0]
        M[1, 2] += (nH / 2) - c[1]
        return cv2.warpAffine(bgr, M, (nW, nH), flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REPLICATE)

    def _apply_right_angle_ccw(bgr: np.ndarray, ra_deg: int) -> np.ndarray:
        if ra_deg == 0:   return bgr
        if ra_deg == 90:  return np.rot90(bgr, 1).copy()
        if ra_deg == 180: return np.rot90(bgr, 2).copy()
        if ra_deg == -90: return np.rot90(bgr, 3).copy()
        return _rotate_full_canvas(bgr, float(ra_deg))

    def _make_small(bgr: np.ndarray) -> np.ndarray:
        h, w = bgr.shape[:2]
        m = max(h, w)
        if m <= angle_estimation_max_side:
            return bgr
        scale = angle_estimation_max_side / float(m)
        return cv2.resize(bgr, (int(w * scale), int(h * scale)), interpolation=cv2.INTER_AREA)

    # ---------------- OCR helpers ----------------
    def _osd_detect_deg_cw(bgr_small: np.ndarray) -> Tuple[Optional[int], Optional[float]]:
        if osd_tc is None:
            return None, None
        try:
            pil = Image.fromarray(cv2.cvtColor(bgr_small, cv2.COLOR_BGR2RGB))
            raw = osd_tc.get_osd_ocr(pil, config='', model='best', output_type='dict')
            if not isinstance(raw, dict):
                return None, None
            d = raw.get('dict', raw)
            deg = int(d.get('rotate', d.get('rotation', d.get('rot', 0))) or 0) % 360
            conf = float(d.get('orientation_conf', d.get('conf', d.get('confidence', 0.0))) or 0.0)
            return deg, conf
        except Exception:
            return None, None

    def _tc_new_text(bgr_small: np.ndarray) -> str:
        if tc_new is None:
            return ""
        pil = Image.fromarray(cv2.cvtColor(bgr_small, cv2.COLOR_BGR2RGB))
        # parametreleri hazırla
        kwargs: Dict[str, Any] = {}
        if tc_new_config:
            kwargs["config"] = tc_new_config
        else:
            cfg = []
            if tc_new_psm is not None: cfg.append(f"--psm {int(tc_new_psm)}")
            if tc_new_oem is not None: cfg.append(f"--oem {int(tc_new_oem)}")
            if cfg: kwargs["config"] = " ".join(cfg)
        if tc_new_lang:
            kwargs["lang"] = tc_new_lang

        for name in ["ocr", "run_ocr", "predict", "infer", "get_text", "__call__"]:
            fn = getattr(tc_new, name, None)
            if callable(fn):
                try:
                    txt = fn(pil, **kwargs)
                    if isinstance(txt, dict): txt = txt.get("text", "")
                    if not isinstance(txt, str): txt = str(txt)
                    return txt
                except TypeError:
                    try:
                        txt = fn(pil, output_type='text', **kwargs)
                        if isinstance(txt, dict): txt = txt.get("text", "")
                        if not isinstance(txt, str): txt = str(txt)
                        return txt
                    except Exception:
                        pass
                except Exception:
                    pass
        return ""

    def _keyword_score(text: str, kws: List[str]) -> int:
        t = text.lower()
        return sum(1 for kw in kws if kw.strip() and kw.lower() in t)

    # ---------------- angle helpers ----------------
    def _osd_cw_to_ccw_deg(osd_deg_cw: Optional[int]) -> int:
        if osd_deg_cw is None: return 0
        d = int(osd_deg_cw) % 360
        # OSD rotate (CW) -> bizim uygulayacağımız CCW
        if d == 0:   return 0
        if d == 90:  return -90
        if d == 180: return 180
        if d == 270: return 90
        return 0

    def _robust_skew_small(bgr_small: np.ndarray) -> float:
        # ±10° küçük açı tahmini
        try:
            gray = cv2.cvtColor(bgr_small, cv2.COLOR_BGR2GRAY)
            g = cv2.GaussianBlur(gray, (3, 3), 0)
            edges = cv2.Canny(g, 50, 150)
            edges = cv2.dilate(edges, np.ones((3, 3), np.uint8), iterations=1)
            lines = cv2.HoughLinesP(edges, 1, np.pi / 1800, threshold=120,
                                    minLineLength=max(30, min(bgr_small.shape[:2]) // 15),
                                    maxLineGap=10)
            angs: List[float] = []
            if lines is not None:
                L = lines.squeeze(axis=1) if lines.ndim == 3 else lines
                for x1, y1, x2, y2 in L:
                    dx, dy = x2 - x1, y2 - y1
                    ang = 90.0 if dx == 0 else np.degrees(np.arctan2(dy, dx))
                    while ang <= -90: ang += 180
                    while ang > 90:   ang -= 180
                    if abs(ang) <= 10.0:
                        angs.append(float(ang))
            if angs:
                a = np.array(angs, dtype=np.float32)
                med = float(np.median(a))
                mad = float(np.median(np.abs(a - med)) + 1e-6)
                keep = np.abs(a - med) <= (3.5 * mad)
                a2 = a[keep] if keep.any() else a
                return float(np.median(a2))
            return 0.0
        except Exception:
            return 0.0

    def _imshow_before_after(before: np.ndarray, after: np.ndarray, title: str):
        if not debug: return
        import matplotlib.pyplot as plt
        plt.figure(figsize=(12, 6))
        ax1 = plt.subplot(1, 2, 1); ax1.imshow(cv2.cvtColor(before, cv2.COLOR_BGR2RGB)); ax1.set_title("Before"); ax1.axis("off")
        ax2 = plt.subplot(1, 2, 2); ax2.imshow(cv2.cvtColor(after,  cv2.COLOR_BGR2RGB)); ax2.set_title("After");  ax2.axis("off")
        plt.suptitle(title); plt.tight_layout(); plt.show()

    def _normalize_dpi_tuple(dpi_xy) -> Optional[Tuple[int, int]]:
        if dpi_xy is None: return None
        try:
            x, y = int(dpi_xy[0]), int(dpi_xy[1])
            if x <= 1 and y <= 1: return None
            return (x, y)
        except Exception:
            return None

    # ---------------- raster: PDF / TIFF ----------------
    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    pages_raw: List[Tuple[int, np.ndarray, Optional[Tuple[int, int]], str, Optional[int]]] = []
    # (index, BGR, dpi_xy, source, tiff_orientation_tag)

    if ext == ".pdf":
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                scale = pdf_dpi / 72.0
                pix = page.get_pixmap(matrix=fitz.Matrix(scale, scale), alpha=False, colorspace=fitz.csRGB)
                buf = np.frombuffer(pix.samples, dtype=np.uint8)
                if pix.n == 3:
                    arr = buf.reshape(pix.h, pix.w, 3).copy()
                elif pix.n == 1:
                    arr = cv2.cvtColor(buf.reshape(pix.h, pix.w), cv2.COLOR_GRAY2RGB)
                else:
                    rgba = buf.reshape(pix.h, pix.w, pix.n)[:, :, :4].copy()
                    bgr = _rgba_to_bgr_on_white(rgba)
                    pages_raw.append((i, bgr, (pdf_dpi, pdf_dpi), "pdf_raster", None))
                    continue
                bgr = cv2.cvtColor(arr, cv2.COLOR_RGB2BGR) if return_bgr else arr
                pages_raw.append((i, bgr, (pdf_dpi, pdf_dpi), "pdf_raster", None))
        finally:
            doc.close()
        doc_str = "pdf_doc"

    elif ext in (".tif", ".tiff"):
        doc_str = "tiff_doc"
        if _HAS_TIFF:
            with tiff.TiffFile(p.as_posix()) as tf:
                for i, pg in enumerate(tf.pages):
                    try:
                        comp = getattr(pg, "compression", None)
                        if comp is not None and "CCITT" in str(comp):
                            raise NotImplementedError("CCITT -> Pillow fallback")
                        arr = pg.asarray()
                        bgr = _ensure_bgr(arr)
                        # DPI
                        dpi_xy = None
                        try:
                            xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
                            if xr and yr and ru:
                                def _rat(tag): num, den = tag.value; return float(num)/float(den)
                                x, y = _rat(xr), _rat(yr)
                                if getattr(ru, "value", ru) == 3: x *= 2.54; y *= 2.54
                                dpi_xy = _normalize_dpi_tuple((int(round(x)), int(round(y))))
                        except Exception:
                            dpi_xy = None
                        # Orientation
                        orient = None
                        try: orient = (pg.tags.get("Orientation") or {}).value
                        except Exception: pass
                        pages_raw.append((i, bgr, dpi_xy, "tifffile", orient))
                    except Exception:
                        # Pillow fallback
                        with Image.open(p.as_posix()) as im:
                            im.seek(i)
                            pil = im.convert("RGB")
                            arr = np.array(pil)
                            bgr = cv2.cvtColor(arr, cv2.COLOR_RGB2BGR)
                            dpi_xy = _normalize_dpi_tuple(pil.info.get("dpi")) if isinstance(pil.info.get("dpi"), (tuple, list)) else None
                            pages_raw.append((i, bgr, dpi_xy, "pillow", None))
        else:
            with Image.open(p.as_posix()) as im:
                n = getattr(im, "n_frames", 1)
                for i in range(n):
                    im.seek(i)
                    pil = im.convert("RGB")
                    arr = np.array(pil)
                    bgr = cv2.cvtColor(arr, cv2.COLOR_RGB2BGR)
                    dpi_xy = _normalize_dpi_tuple(pil.info.get("dpi")) if isinstance(pil.info.get("dpi"), (tuple, list)) else None
                    pages_raw.append((i, bgr, dpi_xy, "pillow", None))
    else:
        raise ValueError(f"Unsupported extension: {ext}")

    # ---------------- process: EXIF -> OSD -> (optional) keywords -> skew ----------------
    images: List[np.ndarray] = []
    metas: List[Dict[str, Any]] = []

    kw_enabled = (
        enable_keyword_rotation and
        tc_new is not None and
        isinstance(keywords, list) and
        any(isinstance(k, str) and k.strip() for k in keywords)
    )
    kw_list = [k for k in (keywords or []) if isinstance(k, str) and k.strip()]

    for (i, bgr0, dpi_xy, source, orient_tag) in pages_raw:
        # EXIF (TIFF) – kayıpsız
        exif_deg = 0
        if orient_tag is not None:
            bgr1, exif_deg = _apply_exif_orientation(bgr0, orient_tag)
        else:
            bgr1 = bgr0

        # OSD (küçük kopya) ve mapping
        small1 = _make_small(bgr1)
        osd_deg_cw, osd_conf = _osd_detect_deg_cw(small1)
        osd_to_ccw = _osd_cw_to_ccw_deg(osd_deg_cw)

        # OSD right-angle uygula (kayıpsız)
        bgr2 = _apply_right_angle_ccw(bgr1, osd_to_ccw)

        # (OPSİYONEL) Keyword self-check
        best_ra = 0
        best_score = 0
        best_img = bgr2

        if kw_enabled:
            candidate_ras = [0, 90, 180, -90]
            best_score = -1
            for ra in candidate_ras:
                prev_img = _apply_right_angle_ccw(bgr2, ra) if ra != 0 else bgr2
                txt = _tc_new_text(_make_small(prev_img))
                score = _keyword_score(txt, kw_list)
                if score > best_score:
                    best_score = score
                    best_ra = ra
                    best_img = prev_img
        # değilse: best_ra=0, best_img=bgr2

        # Skew (küçük açı, ±10°) – kırpmasız
        skew_deg = _robust_skew_small(_make_small(best_img))
        bgr3 = _rotate_full_canvas(best_img, float(skew_deg))

        total_deg = float(exif_deg + osd_to_ccw + best_ra + float(skew_deg))

        _imshow_before_after(bgr0, bgr3, f"Page {i} | total={total_deg:.2f}°")

        images.append(bgr3)
        metas.append({
            "page_index": i,
            "dpi": dpi_xy,
            "shape": tuple(bgr3.shape),
            "source": source,
            "exif_orientation_applied_deg": int(exif_deg),
            "osd_raw_deg_cw": (None if osd_deg_cw is None else int(osd_deg_cw)),
            "osd_confidence": (None if osd_conf is None else float(osd_conf)),
            "osd_to_ccw_deg": int(osd_to_ccw),
            "keyword_rotation_enabled": bool(kw_enabled),
            "keyword_best_ccw_deg": int(best_ra),
            "keyword_match_score": int(best_score if kw_enabled else 0),
            "skew_deg": float(skew_deg),
            "deskew_applied_deg": float(skew_deg),
            "total_rotation_applied_deg": total_deg
        })

    return {
        "path": str(p),
        "doc_str": "pdf_doc" if ext == ".pdf" else "tiff_doc",
        "page_count": len(images),
        "images": images,   # sayfa sayfa BGR
        "metas": metas
    }