def convert_document_to_images(
    path,
    *,
    pdf_dpi: int = 600,             # PDF raster DPI
    cover_thresh: float = 0.97,     # PDF: sayfayı kaplayan görsel eşiği
    apply_orientation: bool = True, # TIFF/EXIF Orientation uygula
    debug: bool = False
):
    """
    Çok sayfalı PDF/TIFF'i 'görüldüğü gibi' image'lara çevirir (renk/kanal/dtype'e dokunmadan).
    CCITT gibi TIFF sıkıştırmaları tifffile+imagecodecs yoksa otomatik Pillow fallback.
    Dönen:
      {"doc_str","path","page_count","pages":[{"index","dpi","shape","dtype","mode","colorspace","source","image"},...]}
    """
    # ---- imports (tek fonksiyon için içeri alındı) ----
    from pathlib import Path
    from typing import Optional
    import numpy as np
    import cv2, fitz  # PyMuPDF
    from PIL import Image
    Image.MAX_IMAGE_PIXELS = None
    try:
        import tifffile as tiff
        _HAS_TIFFFILE = True
    except Exception:
        _HAS_TIFFFILE = False

    # ---- helpers ----
    def _imshow(img, title: str):
        if not debug: return
        import matplotlib.pyplot as plt
        plt.figure()
        if img.ndim == 2: plt.imshow(img, cmap='gray')
        else:             plt.imshow(img)
        plt.title(title); plt.axis('off'); plt.show()

    def _apply_exif_orientation(arr: np.ndarray, orient: Optional[int]) -> np.ndarray:
        if orient is None: return arr
        if orient == 3:  return np.rot90(arr, 2)  # 180°
        if orient == 6:  return np.rot90(arr, 3)  # 90° CW
        if orient == 8:  return np.rot90(arr, 1)  # 90° CCW
        return arr

    def _decode_image_bytes_lossless(b: bytes):
        buf = np.frombuffer(b, dtype=np.uint8)
        im = cv2.imdecode(buf, cv2.IMREAD_UNCHANGED)
        if im is None:
            raise ValueError("cv2.imdecode failed.")
        if im.ndim == 2:
            return im, "GRAY"
        if im.shape[2] == 3:
            return cv2.cvtColor(im, cv2.COLOR_BGR2RGB), "RGB"
        return cv2.cvtColor(im, cv2.COLOR_BGRA2RGBA), "RGBA"

    def _pdf_try_native_cover(doc, page, cover_thresh: float):
        imgs = page.get_images(full=True)
        if len(imgs) == 1 and not page.get_text("blocks"):
            return doc.extract_image(imgs[0][0])["image"]
        page_area = float(page.rect.get_area())
        covers = []
        for info in page.get_image_info(xrefs=True):
            bbox = info.get("bbox")
            if bbox and (bbox.get_area() / page_area) >= cover_thresh:
                covers.append(info["xref"])
        if len(covers) == 1:
            return doc.extract_image(covers[0])["image"]
        return None

    def _tiff_with_tifffile(p: Path):
        """tifffile yolu; decode hatasında ValueError fırlatır."""
        pages = []
        with tiff.TiffFile(p.as_posix()) as tf:
            for i, pg in enumerate(tf.pages):
                arr = pg.asarray()  # CCITT/LZW/J2K için imagecodecs gerekir
                # Orientation
                orient = None
                if apply_orientation:
                    try:
                        ori_tag = pg.tags.get("Orientation")
                        if ori_tag is not None:
                            orient = int(ori_tag.value)
                    except Exception:
                        orient = None
                if apply_orientation and orient in (3, 6, 8):
                    arr = _apply_exif_orientation(arr, orient)
                # DPI
                dpi_xy = None
                xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
                if xr and yr and ru:
                    def _rat(tag):
                        num, den = tag.value
                        return float(num)/float(den)
                    x, y = _rat(xr), _rat(yr)
                    if ru.value == 3: x *= 2.54; y *= 2.54
                    dpi_xy = (int(round(x)), int(round(y)))
                # mode bilgisi
                if arr.ndim == 2:
                    mode = "1BIT" if arr.dtype == np.bool_ else "GRAY"
                elif arr.ndim == 3 and arr.shape[2] == 3:
                    mode = "RGB"
                elif arr.ndim == 3 and arr.shape[2] == 4:
                    mode = "RGBA"
                else:
                    mode = f"NDIM{arr.ndim}_C{arr.shape[2] if arr.ndim==3 else 1}"
                pages.append({
                    "index": i, "dpi": dpi_xy, "shape": tuple(arr.shape),
                    "dtype": str(arr.dtype), "mode": mode, "colorspace": mode, "source": "tifffile",
                    "image": arr
                })
        return pages

    def _tiff_with_pillow(p: Path):
        """Pillow fallback; dönüşüm yapmadan numpy’a çevirir; EXIF Orientation uygular."""
        pages = []
        with Image.open(p.as_posix()) as im:
            n = getattr(im, "n_frames", 1)
            for i in range(n):
                im.seek(i)
                frame = im.copy()
                orient = None
                if apply_orientation:
                    try:
                        exif = frame.getexif()
                        orient = int(exif.get(274) or 1) if exif else 1  # 274=Orientation
                    except Exception:
                        orient = 1
                arr = np.array(frame)  # mode/dtype aynen
                if apply_orientation and orient in (3, 6, 8):
                    arr = _apply_exif_orientation(arr, orient)
                dpi_xy = frame.info.get("dpi")
                if not (isinstance(dpi_xy, (tuple, list)) and len(dpi_xy) >= 2):
                    dpi_xy = None
                mode = frame.mode
                pages.append({
                    "index": i, "dpi": dpi_xy, "shape": tuple(arr.shape),
                    "dtype": str(arr.dtype), "mode": mode, "colorspace": mode, "source": "pillow",
                    "image": arr
                })
        return pages

    # ---- core ----
    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    out = {"doc_str": None, "path": str(p), "page_count": 0, "pages": []}

    if ext == ".pdf":
        out["doc_str"] = "pdf_doc"
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                nb = _pdf_try_native_cover(doc, page, cover_thresh=cover_thresh)
                if nb is not None:
                    img, cs = _decode_image_bytes_lossless(nb)
                    src = "native"; dpi_val = None
                else:
                    scale = pdf_dpi / 72.0
                    pix = page.get_pixmap(matrix=fitz.Matrix(scale, scale), alpha=True, colorspace=fitz.csRGB)
                    buf = np.frombuffer(pix.samples, dtype=np.uint8)
                    if pix.n == 1:
                        img = buf.reshape(pix.h, pix.w).copy(); cs = "GRAY"
                    elif pix.n == 3:
                        img = buf.reshape(pix.h, pix.w, 3).copy(); cs = "RGB"
                    else:
                        img = buf.reshape(pix.h, pix.w, pix.n)[:, :, :4].copy(); cs = "RGBA"
                    src = "raster"; dpi_val = pdf_dpi
                _imshow(img, f"PDF p{i} | {src} | {cs} | dpi={dpi_val} | {img.shape}")
                out["pages"].append({
                    "index": i, "dpi": dpi_val, "shape": tuple(img.shape),
                    "dtype": str(img.dtype), "mode": cs, "colorspace": cs, "source": src, "image": img
                })
        finally:
            doc.close()
        out["page_count"] = len(out["pages"])

    elif ext in (".tif", ".tiff"):
        out["doc_str"] = "tiff_doc"
        if _HAS_TIFFFILE:
            try:
                out["pages"] = _tiff_with_tifffile(p)
            except Exception as e:
                # Örn: ValueError("<COMPRESSION.CCITT ...> not supported")
                # veya imagecodecs/decoder yokluğu → Pillow fallback
                # print(f"tifffile decode failed, falling back to Pillow: {e}")
                out["pages"] = _tiff_with_pillow(p)
        else:
            out["pages"] = _tiff_with_pillow(p)
        out["page_count"] = len(out["pages"])

    else:
        raise ValueError(f"Unsupported extension: {ext}")

    if debug:
        print(f"\nBelge: {out['path']}\nTür: {out['doc_str']}\nSayfa: {out['page_count']}")
        for pg in out["pages"]:
            print(f"p{pg['index']:>3}  shape={pg['shape']}  dtype={pg['dtype']}  mode={pg['mode']}  dpi={pg['dpi']}  src={pg['source']}")
    return out