# -*- coding: utf-8 -*-
import os
import json
import base64
from io import BytesIO
from typing import Optional, Union, Sequence, List, Dict, Any

import numpy as np
import cv2
from PIL import Image
import requests


TARGET_URL = "https://internalgw/neomediaoperationsinternal/api/clear-ocr/get/v1"
TOKEN_ENV  = "INTGW_ACCESS_KEY"  # <- your environment variable name (do not hardcode token)


# -------------------------- helpers --------------------------
def _ensure_uint8(x: np.ndarray) -> np.ndarray:
    if x.dtype != np.uint8:
        x = np.clip(x, 0, 255).astype(np.uint8)
    return x

def _np_to_bgr(img: np.ndarray) -> np.ndarray:
    """Return BGR/GRAY uint8 for cv2.imencode (no disk I/O)."""
    img = _ensure_uint8(img)
    if img.ndim == 2:  # GRAY
        return img
    if img.ndim == 3 and img.shape[2] == 3:
        # If your arrays are RGB, flip: return img[:, :, ::-1]
        return img
    if img.ndim == 3 and img.shape[2] == 4:
        return cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
    raise ValueError(f"Unsupported image shape: {img.shape}")

def _resize_max(img: np.ndarray, max_w: int = 2000, max_h: int = 2000) -> np.ndarray:
    h, w = img.shape[:2]
    s = min(max_w / w, max_h / h, 1.0)
    if s < 1.0:
        img = cv2.resize(img, (int(w * s), int(h * s)), interpolation=cv2.INTER_AREA)
    return img

def _encode_np_to_b64(img: np.ndarray, fmt: str = "jpg", jpg_quality: int = 85) -> str:
    """Encode NumPy image to base64 entirely in memory."""
    bgr = _np_to_bgr(img)
    ext = ".jpg" if fmt.lower() in ("jpg", "jpeg") else ".png"
    params = []
    if ext == ".jpg":
        params = [int(cv2.IMWRITE_JPEG_QUALITY), int(jpg_quality)]
    ok, buf = cv2.imencode(ext, bgr, params)
    if not ok:
        raise RuntimeError("cv2.imencode failed")
    return base64.b64encode(buf).decode("utf-8")

def _encode_path_to_b64(image_path: str) -> str:
    """Path → PIL → base64 (keeps your original behavior)."""
    img = Image.open(image_path)
    bio = BytesIO()
    fmt = (img.format or "PNG").upper()
    img.save(bio, format=fmt)
    return base64.b64encode(bio.getvalue()).decode("utf-8")

def _build_headers() -> Dict[str, str]:
    token = os.environ[TOKEN_ENV]
    return {
        "Access-Token": token,
        "Content-Type": "application/json",
    }

def _build_payload_base(image_str: str) -> Dict[str, Any]:
    """
    Your payload, with correct top-level placement (not nested under requestHeader).
    Only 'content' is injected; everything else stays as you provided.
    """
    return {
        "requestHeader": {
            "info": {
                "correlationPair": [
                    {"key": "AppName", "value": "Postman"}
                ]
            }
        },
        "customerNo": 10651337,
        "branchCode": 936,
        "channelInfo": "Branch",
        "language": "tr-TR",
        "transactionCode": "",
        "clientIP": "1.1.1.1",
        "clientPort": "0",
        "registrationNo": 49001,
        "userInfo": {
            "userID": 153,
            "userCode": "49001",
            "userBranchCode": "936",
            "roles": [{"roleID": "1501"}]
        },
        "performerUserInfo": {
            "userID": 153,
            "userCode": "49001",
            "userBranchCode": "936",
            "roles": [{"roleID": "1501"}]
        },
        "includeBbox": False,
        "content": image_str
    }

def _post_ocr(headers: Dict[str, str], payload: Dict[str, Any], *, timeout: int = 30) -> str:
    resp = requests.post(
        TARGET_URL,
        headers=headers,
        json=payload,
        verify=False,
        timeout=timeout,
    )
    # Show more context if the backend fails
    try:
        resp.raise_for_status()
    except requests.HTTPError as e:
        # print first chars of server response for diagnostics
        try:
            print("HTTP", resp.status_code, "-", resp.text[:600])
        except Exception:
            pass
        raise e

    data = resp.json()
    # Be defensive about response shape/casing
    pages = (
        data.get("ocrPageResultList")
        or data.get("OcrPageResultList")
        or data.get("result", {}).get("ocrPageResultList")
        or []
    )
    parts: List[str] = []
    for p in pages:
        t = p.get("extractedText") or ""
        if isinstance(t, str):
            parts.append(t)
    return "\n".join(parts).strip()


# -------------------------- public API --------------------------
def call_paddle_ocr_text_only(image_path: str) -> str:
    """Path-based version (kept for compatibility)."""
    image_str = _encode_path_to_b64(image_path)
    headers = _build_headers()
    payload = _build_payload_base(image_str)
    return _post_ocr(headers, payload)


def call_paddle_ocr_text_only_array(
    img: np.ndarray,
    *,
    fmt: str = "jpg",          # use "png" if your backend insists on PNG
    max_w: int = 2000,
    max_h: int = 2000,
    jpg_quality: int = 85
) -> str:
    """
    NumPy-array version (preferred). No disk I/O.
    Accepts GRAY/BGR/RGB/RGBA arrays; downscales large pages to avoid 500s.
    """
    if img is None:
        return ""
    img = _resize_max(img, max_w=max_w, max_h=max_h)
    image_str = _encode_np_to_b64(img, fmt=fmt, jpg_quality=jpg_quality)
    headers = _build_headers()
    payload = _build_payload_base(image_str)
    return _post_ocr(headers, payload)


def call_paddle_ocr_text_only_batch(
    imgs: Sequence[Optional[np.ndarray]],
    *,
    fmt: str = "jpg",
    max_w: int = 2000,
    max_h: int = 2000,
    jpg_quality: int = 85
) -> List[Optional[str]]:
    """Batch over a list such as final_lower_imgs; returns list[str|None] aligned with input."""
    out: List[Optional[str]] = []
    for i, im in enumerate(imgs):
        try:
            out.append(call_paddle_ocr_text_only_array(
                im, fmt=fmt, max_w=max_w, max_h=max_h, jpg_quality=jpg_quality
            ) if im is not None else None)
        except Exception as e:
            print(f"[{i}] OCR failed:", e)
            out.append(None)
    return out


from importlib import reload
import your_module_name  # replace with the filename of the script above (without .py)
reload(your_module_name)

# Single image
# text0 = your_module_name.call_paddle_ocr_text_only_array(final_lower_imgs[0])

# Batch
texts = your_module_name.call_paddle_ocr_text_only_batch(final_lower_imgs)
for i, t in enumerate(texts):
    print(f"\n=== PAGE {i} ===")
    print(t or "(No text detected / OCR failed)")