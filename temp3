# -*- coding: utf-8 -*-
from __future__ import annotations
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import numpy as np, cv2, fitz
from PIL import Image
Image.MAX_IMAGE_PIXELS = None

try:
    import tifffile as tiff
    _HAS_TIFFFILE = True
except Exception:
    _HAS_TIFFFILE = False


def doc_to_images_autorotate_deskew(
    path: Union[str, Path],
    *,
    pdf_dpi: int = 600,
    apply_orientation: bool = True,
    osd_tc: Any = None,          # TesseractClient: .get_osd_ocr(PIL, ...) -> dict
    osd_conf: float = 0.0,       # OSD güven eşiği (CW derece)
    estimate_skew: bool = True,
    skew_max_angle: float = 8.0,
    return_bgr: bool = True,
    debug: bool = False
) -> Dict[str, Any]:

    def _imshow(bgr: np.ndarray, title: str):
        if not debug: return
        import matplotlib.pyplot as plt
        plt.figure(figsize=(8, 8)); plt.imshow(cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB))
        plt.title(title); plt.axis("off"); plt.show()

    def _normalize_dpi_tuple(dpi_xy) -> Optional[Tuple[int, int]]:
        if dpi_xy is None: return None
        try:
            x, y = int(dpi_xy[0]), int(dpi_xy[1])
            if x <= 1 and y <= 1: return None
            return (x, y)
        except Exception:
            return None

    def _rgba_to_bgr_on_white(rgba: np.ndarray) -> np.ndarray:
        rgb = rgba[..., :3].astype(np.float32)
        alpha = rgba[..., 3:4].astype(np.float32) / 255.0
        out = rgb * alpha + 255.0 * (1.0 - alpha)
        return cv2.cvtColor(np.clip(out, 0, 255).astype(np.uint8), cv2.COLOR_RGB2BGR)

    def _to_uint8_gray(arr: np.ndarray) -> np.ndarray:
        if arr.dtype == np.bool_: return (arr.astype(np.uint8) * 255)
        if arr.dtype == np.uint16: return cv2.convertScaleAbs(arr, alpha=255.0/65535.0)
        return arr.astype(np.uint8, copy=False)

    def _ensure_bgr_safe(arr: np.ndarray, *, photometric: Optional[str] = None) -> np.ndarray:
        if arr.ndim == 2:
            g = _to_uint8_gray(arr)
            if (photometric or "").upper() == "MINISWHITE": g = 255 - g
            return cv2.cvtColor(g, cv2.COLOR_GRAY2BGR)
        if arr.ndim == 3:
            c = arr.shape[2]
            if c == 3: return cv2.cvtColor(arr.astype(np.uint8, copy=False), cv2.COLOR_RGB2BGR)
            if c == 4: return _rgba_to_bgr_on_white(arr.astype(np.uint8, copy=False))
            if c > 4:  return cv2.cvtColor(arr[..., :3].astype(np.uint8, copy=False), cv2.COLOR_RGB2BGR)
        arr = np.squeeze(arr)
        if arr.ndim == 2: return cv2.cvtColor(_to_uint8_gray(arr), cv2.COLOR_GRAY2BGR)
        raise ValueError(f"Unsupported array: {arr.shape}, {arr.dtype}")

    def _apply_exif_orientation(bgr: np.ndarray, orient: Optional[int]) -> Tuple[np.ndarray, int]:
        # 1: normal, 3: 180, 6: 270 CW (== +90 CCW), 8: 90 CW (== -90 CCW)
        deg = 0
        if orient is None: return bgr, 0
        if orient == 3:   bgr, deg = np.rot90(bgr, 2).copy(), 180
        elif orient == 6: bgr, deg = np.rot90(bgr, 1).copy(),  90
        elif orient == 8: bgr, deg = np.rot90(bgr, 3).copy(), -90
        return bgr, deg

    def _osd_estimate_angle_cw(bgr: np.ndarray) -> Tuple[Optional[float], Optional[float]]:
        # Tesseract OSD rotate: CW derece (metin dik olsun diye)
        if osd_tc is None: return None, None
        try:
            pil = Image.fromarray(cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB))
            raw = osd_tc.get_osd_ocr(pil, config='', model='best', output_type='dict')
        except Exception:
            return None, None
        if not isinstance(raw, dict) or 'error' in raw: return None, None
        d = raw.get('dict', raw)
        deg_cw  = d.get('rotate', d.get('rotation', d.get('rot', None)))
        conf    = d.get('orientation_conf', d.get('conf', d.get('confidence', None)))
        return (None if deg_cw is None else float(deg_cw)), (None if conf is None else float(conf))

    # --- DÜZELTME: OSD (CW) → right-angle (CCW) eşleme
    def _snap_90k_cw(deg_cw: float) -> int:
        cand = np.array([0, 90, 180, 270], dtype=np.int32)
        return int(cand[np.argmin(np.abs(cand - (deg_cw % 360)))])  # CW

    def _cw_to_ccw_right_angle(nearest_cw: int) -> int:
        # CW→CCW dönüşümü: 0->0, 90->-90, 180->180, 270->+90
        if nearest_cw == 0:   return 0
        if nearest_cw == 90:  return -90
        if nearest_cw == 180: return 180
        if nearest_cw == 270: return 90
        return 0

    def _apply_right_angle(bgr: np.ndarray, ra_ccw: int) -> np.ndarray:
        if ra_ccw == 0:   return bgr.copy()
        if ra_ccw == 90:  return np.rot90(bgr, 1).copy()   # +90 CCW
        if ra_ccw == 180: return np.rot90(bgr, 2).copy()
        if ra_ccw == -90: return np.rot90(bgr, 3).copy()   # -90 CCW == 90 CW
        # beklenmeyen durum
        return _rotate_keep_bounds(bgr, float(ra_ccw))

    def _rotate_keep_bounds(bgr: np.ndarray, angle_deg_ccw: float) -> np.ndarray:
        if abs(angle_deg_ccw) < 1e-3: return bgr.copy()
        (h, w) = bgr.shape[:2]; c = (w/2.0, h/2.0)
        M = cv2.getRotationMatrix2D(c, angle_deg_ccw, 1.0)  # CCW +
        cos, sin = abs(M[0,0]), abs(M[0,1])
        nW, nH = int(h*sin + w*cos), int(h*cos + w*sin)
        M[0,2] += (nW/2) - c[0]; M[1,2] += (nH/2) - c[1]
        return cv2.warpAffine(bgr, M, (nW, nH), flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REPLICATE)

    def _robust_skew_deg(bgr: np.ndarray, max_angle: float = 8.0) -> Optional[float]:
        try:
            gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
            g = cv2.GaussianBlur(gray, (3,3), 0)
            edges = cv2.Canny(g, 50, 150)
            edges = cv2.dilate(edges, np.ones((3,3), np.uint8), iterations=1)
            lines = cv2.HoughLinesP(edges, 1, np.pi/1800, threshold=120,
                                    minLineLength=max(30, min(bgr.shape[:2])//15),
                                    maxLineGap=10)
            angs: List[float] = []
            if lines is not None:
                L = lines.squeeze(axis=1) if lines.ndim == 3 else lines
                for x1,y1,x2,y2 in L:
                    dx, dy = (x2-x1), (y2-y1)
                    ang = 90.0 if dx == 0 else np.degrees(np.arctan2(dy, dx))
                    while ang <= -90: ang += 180
                    while ang >   90: ang -= 180
                    if abs(ang) <= max_angle: angs.append(float(ang))
            if angs:
                a = np.array(angs, dtype=np.float32)
                med = float(np.median(a)); mad = float(np.median(np.abs(a-med))+1e-6)
                keep = np.abs(a-med) <= 3.5*mad
                a2 = a[keep] if keep.any() else a
                return float(np.median(a2))
            # fallback: minAreaRect
            _, bw = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)
            bw = cv2.morphologyEx(bw, cv2.MORPH_OPEN, np.ones((3,3), np.uint8), iterations=1)
            cnts,_ = cv2.findContours(bw, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
            if not cnts: return None
            areas = [cv2.contourArea(c) for c in cnts]; 
            if not areas: return None
            thr = max(50.0, np.percentile(areas, 60))
            angs2 = []
            for c in cnts:
                if cv2.contourArea(c) < thr: continue
                rect = cv2.minAreaRect(c)
                ang = rect[-1]  # [-90,0)
                if ang < -45: ang = 90 + ang
                if abs(ang) <= max_angle: angs2.append(float(ang))
            if angs2: return float(np.median(np.array(angs2, dtype=np.float32)))
            return None
        except Exception:
            return None

    # ---- ana akış ----
    p = Path(path).expanduser().resolve()
    ext = p.suffix.lower()
    images: List[np.ndarray] = []
    metas: List[Dict[str, Any]] = []
    doc_str = None

    if ext == ".pdf":
        doc_str = "pdf_doc"
        doc = fitz.open(p.as_posix())
        try:
            for i in range(doc.page_count):
                page = doc.load_page(i)
                scale = pdf_dpi / 72.0
                pix = page.get_pixmap(matrix=fitz.Matrix(scale, scale), alpha=False, colorspace=fitz.csRGB)
                buf = np.frombuffer(pix.samples, dtype=np.uint8)
                if pix.n == 1:
                    arr = buf.reshape(pix.h, pix.w).copy()
                    arr = cv2.cvtColor(arr, cv2.COLOR_GRAY2RGB)
                elif pix.n == 3:
                    arr = buf.reshape(pix.h, pix.w, 3).copy()
                else:
                    rgba = buf.reshape(pix.h, pix.w, pix.n)[:, :, :4].copy()
                    bgr0 = _rgba_to_bgr_on_white(rgba)
                if pix.n in (1,3):
                    bgr0 = cv2.cvtColor(arr, cv2.COLOR_RGB2BGR) if return_bgr else arr

                # EXIF yok
                exif_deg = 0

                # OSD (CW) -> RA (CCW)
                osd_deg_cw, osd_c = _osd_estimate_angle_cw(bgr0)
                if osd_deg_cw is not None and (osd_c or 0) >= osd_conf:
                    nearest_cw = _snap_90k_cw(osd_deg_cw)
                    ra_ccw = _cw_to_ccw_right_angle(nearest_cw)
                else:
                    nearest_cw, ra_ccw = None, 0

                bgr1 = _apply_right_angle(bgr0, ra_ccw)

                skew_deg = _robust_skew_deg(bgr1, max_angle=skew_max_angle) if estimate_skew else None
                deskew_deg = float(skew_deg or 0.0)
                bgr2 = _rotate_keep_bounds(bgr1, deskew_deg) if abs(deskew_deg) > 0.01 else bgr1

                _imshow(bgr2, f"PDF p{i} | RA(CCW)={ra_ccw}°, deskew={deskew_deg:.2f}°")

                images.append(bgr2)
                metas.append({
                    "page_index": i,
                    "dpi": (pdf_dpi, pdf_dpi),
                    "shape": tuple(bgr2.shape),
                    "mode": "BGR" if return_bgr else "RGB",
                    "source": "pdf_raster",
                    "exif_orientation_applied_deg": int(exif_deg),
                    "osd_raw_deg_cw": (None if osd_deg_cw is None else float(osd_deg_cw)),
                    "osd_confidence": (None if osd_c is None else float(osd_c)),
                    "right_angle_applied_deg": int(ra_ccw),         # CCW (+CCW / -CCW)
                    "skew_deg": (None if skew_deg is None else float(skew_deg)),
                    "deskew_applied_deg": float(deskew_deg),
                    "total_rotation_applied_deg": float(exif_deg + ra_ccw + deskew_deg),
                })
        finally:
            doc.close()

    elif ext in (".tif", ".tiff"):
        doc_str = "tiff_doc"

        def _proc_with_tifffile(pth: Path):
            with tiff.TiffFile(pth.as_posix()) as tf:
                for i, pg in enumerate(tf.pages):
                    arr = pg.asarray()
                    bgr0 = _ensure_bgr_safe(arr, photometric=str(getattr(pg, "photometric","") or ""))

                    dpi_xy = None
                    try:
                        xr, yr, ru = pg.tags.get("XResolution"), pg.tags.get("YResolution"), pg.tags.get("ResolutionUnit")
                        if xr and yr and ru:
                            def _rat(tag): num, den = tag.value; return float(num)/float(den)
                            x, y = _rat(xr), _rat(yr)
                            if getattr(ru, "value", ru) == 3: x*=2.54; y*=2.54
                            dpi_xy = _normalize_dpi_tuple((int(round(x)), int(round(y))))
                    except Exception:
                        dpi_xy = None

                    exif_orient = None
                    try: exif_orient = (pg.tags.get("Orientation") or {}).value
                    except Exception: pass

                    bgr1, exif_deg = ( _apply_exif_orientation(bgr0, exif_orient) if apply_orientation else (bgr0,0) )

                    osd_deg_cw, osd_c = _osd_estimate_angle_cw(bgr1)
                    if osd_deg_cw is not None and (osd_c or 0) >= osd_conf:
                        nearest_cw = _snap_90k_cw(osd_deg_cw)
                        ra_ccw = _cw_to_ccw_right_angle(nearest_cw)
                    else:
                        nearest_cw, ra_ccw = None, 0
                    bgr2 = _apply_right_angle(bgr1, ra_ccw)

                    skew_deg = _robust_skew_deg(bgr2, max_angle=skew_max_angle) if estimate_skew else None
                    deskew_deg = float(skew_deg or 0.0)
                    bgr3 = _rotate_keep_bounds(bgr2, deskew_deg) if abs(deskew_deg) > 0.01 else bgr2

                    _imshow(bgr3, f"TIFF p{i} | EXIF={exif_deg}°, RA(CCW)={ra_ccw}°, deskew={deskew_deg:.2f}°")

                    images.append(bgr3)
                    metas.append({
                        "page_index": i,
                        "dpi": dpi_xy,
                        "shape": tuple(bgr3.shape),
                        "mode": "BGR",
                        "source": "tifffile",
                        "exif_orientation_applied_deg": int(exif_deg),
                        "osd_raw_deg_cw": (None if osd_deg_cw is None else float(osd_deg_cw)),
                        "osd_confidence": (None if osd_c is None else float(osd_c)),
                        "right_angle_applied_deg": int(ra_ccw),
                        "skew_deg": (None if skew_deg is None else float(skew_deg)),
                        "deskew_applied_deg": float(deskew_deg),
                        "total_rotation_applied_deg": float(exif_deg + ra_ccw + deskew_deg),
                    })

        def _proc_with_pillow(pth: Path):
            with Image.open(pth.as_posix()) as im:
                n = getattr(im, "n_frames", 1)
                for i in range(n):
                    im.seek(i)
                    frame = im.copy()
                    exif_orient = None
                    try: exif_orient = frame.getexif().get(274)
                    except Exception: pass

                    if frame.mode in ("RGB","RGBA","L"): safe = frame
                    elif frame.mode == "1":            safe = frame.convert("L")
                    else:                               safe = frame.convert("RGB")
                    arr = np.array(safe)
                    bgr0 = _ensure_bgr_safe(arr, photometric=None)

                    bgr1, exif_deg = ( _apply_exif_orientation(bgr0, exif_orient) if apply_orientation else (bgr0,0) )

                    osd_deg_cw, osd_c = _osd_estimate_angle_cw(bgr1)
                    if osd_deg_cw is not None and (osd_c or 0) >= osd_conf:
                        nearest_cw = _snap_90k_cw(osd_deg_cw)
                        ra_ccw = _cw_to_ccw_right_angle(nearest_cw)
                    else:
                        nearest_cw, ra_ccw = None, 0
                    bgr2 = _apply_right_angle(bgr1, ra_ccw)

                    skew_deg = _robust_skew_deg(bgr2, max_angle=skew_max_angle) if estimate_skew else None
                    deskew_deg = float(skew_deg or 0.0)
                    bgr3 = _rotate_keep_bounds(bgr2, deskew_deg) if abs(deskew_deg) > 0.01 else bgr2

                    _imshow(bgr3, f"TIFF p{i} | EXIF={exif_deg}°, RA(CCW)={ra_ccw}°, deskew={deskew_deg:.2f}°")

                    dpi_xy = _normalize_dpi_tuple(safe.info.get("dpi")) if isinstance(safe.info.get("dpi"), (tuple, list)) else None

                    images.append(bgr3)
                    metas.append({
                        "page_index": i,
                        "dpi": dpi_xy,
                        "shape": tuple(bgr3.shape),
                        "mode": "BGR",
                        "source": "pillow",
                        "exif_orientation_applied_deg": int(exif_deg),
                        "osd_raw_deg_cw": (None if osd_deg_cw is None else float(osd_deg_cw)),
                        "osd_confidence": (None if osd_c is None else float(osd_c)),
                        "right_angle_applied_deg": int(ra_ccw),
                        "skew_deg": (None if skew_deg is None else float(skew_deg)),
                        "deskew_applied_deg": float(deskew_deg),
                        "total_rotation_applied_deg": float(exif_deg + ra_ccw + deskew_deg),
                    })

        try:
            if _HAS_TIFFFILE: _proc_with_tifffile(p)
            else:             _proc_with_pillow(p)
        except Exception:
            _proc_with_pillow(p)
    else:
        raise ValueError(f"Unsupported extension: {ext}")

    return {
        "path": str(p),
        "doc_str": doc_str,
        "page_count": len(images),
        "images": images,   # Sayfa sayfa BGR
        "metas": metas
    }