# -*- coding: utf-8 -*-
import cv2, re, unicodedata
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def extract_top_info_from_doc_images_fuzzy_strict(
    doc_images,
    *,
    ocr_fn,                          # img_bgr -> str  (senin HTTP/PyTesseract wrapper'ın)
    debug: bool = False,
    show_fig: bool = False,
    table_top_shift_ratio: float = 0.02,
) -> pd.DataFrame:
    """
    - Tablo üstünü bulur, üst bandı OCR eder.
    - Tarih (dd/mm/yyyy) çıkarır.
    - Şirket adı + tür: SADECE tür bulunursa adı çıkarır; tür yoksa şirket_adı=None bırakır.
    - Tür bulunduğunda, türün BAŞLANGICINA kadar olan ham metin şirket adıdır (kırpma limiti yok).
    """

    # ---------- yardımcılar ----------
    def _normalize_line(s: str) -> str:
        s = unicodedata.normalize("NFKC", s or "")
        s = s.replace("\u00A0"," ").replace("\u200B"," ")
        trans = str.maketrans({"İ":"i","I":"ı","Ç":"ç","Ğ":"ğ","Ö":"ö","Ş":"ş","Ü":"ü"})
        s = s.translate(trans).lower()
        s = re.sub(r"\s+"," ", s).strip()
        return s

    def _upper_tr(s: str) -> str:
        rep={"i":"İ","ı":"I","ğ":"Ğ","ü":"Ü","ş":"Ş","ö":"Ö","ç":"Ç"}
        return "".join(rep.get(c,c.upper()) for c in (s or "").lower())

    def _detect_table_top(gray: np.ndarray):
        if gray.ndim == 3:
            gray = cv2.cvtColor(gray, cv2.COLOR_BGR2GRAY)
        H, W = gray.shape[:2]
        blur = cv2.GaussianBlur(gray, (3,3), 0)
        _, bw = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)
        if np.mean(bw) > 127: bw = cv2.bitwise_not(bw)
        kx = max(10, W//80); ky = max(10, H//80)
        horiz = cv2.morphologyEx(bw, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_RECT,(kx,1)), iterations=2)
        vert  = cv2.morphologyEx(bw, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_RECT,(1,ky)), iterations=2)
        mask = cv2.add(horiz, vert)
        cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if not cnts: return None
        x,y,w,h = cv2.boundingRect(max(cnts, key=cv2.contourArea))
        y_top = int(y + max(1, round(table_top_shift_ratio*h)))
        return max(0, min(H-1, y_top)), (x,y,w,h), gray

    def _extract_upper(img, y_top):
        return img[:y_top,:] if y_top is not None else None

    def _extract_date(text: str):
        t = unicodedata.normalize("NFKC", text or "")
        t = t.replace("⁄","/").replace("–","/").replace("-","/")
        t = re.sub(r"\s+"," ", t)
        pat = re.compile(r"(?<!\d)(\d{1,2})[/.](\d{1,2})[/.](\d{2,4})(?!\d)")
        for m in pat.finditer(t):
            d, mo, yy = m.group(1), m.group(2), m.group(3)
            try: d_i, m_i = int(d), int(mo)
            except: continue
            yy = re.sub(r"^\D+","",yy)
            if len(yy)==2: y_i = int("20"+yy)
            elif len(yy)>4: y_i = int(yy[-4:])
            else:
                try: y_i = int(yy)
                except: continue
            if 1<=d_i<=31 and 1<=m_i<=12 and 1900<=y_i<=2100:
                return f"{d_i:02d}/{m_i:02d}/{y_i:04d}"
        # brute force
        digits = re.sub(r"\D","",t)
        if len(digits) >= 8:
            best=None
            for i in range(len(digits)-7):
                try:
                    d_i=int(digits[i:i+2]); m_i=int(digits[i+2:i+4]); y_i=int(digits[i+4:i+8])
                except: continue
                if 1<=d_i<=31 and 1<=m_i<=12 and 1900<=y_i<=2100:
                    tup=(y_i,i,d_i,m_i)
                    if best is None or tup>best: best=tup
            if best:
                y_i,_,d_i,m_i=best
                return f"{d_i:02d}/{m_i:02d}/{y_i:04d}"
        return None

    # ---------- TÜRLER: ham satır üzerinde sağlam yakalama ----------
    # A.Ş. / AŞ / AS (OCR varyantları) + Limited/LTD. ŞTİ. + diğerleri
    RAW_TYPE_PATTERNS = [
        # Anonim Şirket
        (r"(?i)\bA\s*\.?\s*Ş\b\.?",                      "anonim şirketi"),
        (r"(?i)\bAŞ\b\.?",                               "anonim şirketi"),
        (r"(?i)\bAS\b\.?",                               "anonim şirketi"),
        (r"(?i)\bANON[İI]M\s+Ş[İI]RKET[İI]?\b\.?",       "anonim şirketi"),
        # Limited Şirket
        (r"(?i)\bLTD\s*\.?\s*ŞT[İI]\b\.?",               "limited şirketi"),
        (r"(?i)\bLTD\s*\.?\s*ST[İI]\b\.?",               "limited şirketi"),
        (r"(?i)\bL[İI]M[İI]TED\s+Ş[İI]RKET[İI]?\b\.?",   "limited şirketi"),
        # Holding / Kooperatif
        (r"(?i)\bHOLD[İI]NG\b\.?",                       "holding"),
        (r"(?i)\bKOOPERAT[İI]F\b\.?",                    "kooperatif"),
        # Kolektif / Komandit
        (r"(?i)\bKOLEKT[İI]F\s+Ş[İI]RKET[İI]?\b\.?",     "kolektif şirket"),
        (r"(?i)\bAD[İI]\s+KOMAND[İI]T\s+Ş[İI]RKET[İI]?\b\.?", "adi komandit şirket"),
        (r"(?i)\bSERMAYES[İI]\s+PAYLARA\s+B[ÖO]L[ÜU]NM[ÜU]Ş\s+KOMAND[İI]T\s+Ş[İI]RKET[İI]?\b\.?",
                                                         "sermayesi paylara bölünmüş komandit şirket"),
        (r"(?i)\bKOMAND[İI]T\s+Ş[İI]RKET[İI]?\b\.?",     "komandit şirket"),
        # İsteğe bağlı: Vakıf/Dernek
        (r"(?i)\bVAK(F[İI]|[İI]F)\b",                    "vakıf"),
        (r"(?i)\bDERNEK\b",                              "dernek"),
    ]
    RAW_TYPE_REGEX = [(re.compile(pat), label) for pat, label in RAW_TYPE_PATTERNS]

    def _extract_company_strict(lines: list[str]) -> tuple[str|None, str|None]:
        """
        Tür bulunursa: şirket adını türün BAŞLANGICINA kadar ham metinden alır.
        Tür bulunmazsa: (None, None) döner (ismi tahmin etmeye kalkmaz).
        """
        best = None
        for raw in lines:
            if not raw or not raw.strip():
                continue
            for creg, label in RAW_TYPE_REGEX:
                m = creg.search(raw)   # <- HAM SATIRDA arıyoruz
                if m:
                    name_part = raw[:m.start()].strip()
                    # Sonda tırnak/noktalama/çizgi artıkları varsa hafif temizle (metni kesmeden)
                    name_part = re.sub(r"[\"'’\-–—\s]+$", "", name_part)
                    # Çok kısa/boş ise atla
                    if len(name_part) < 2:
                        continue
                    # TR büyük harfe çevir + fazla boşlukları sadeleştir
                    cname = _upper_tr(re.sub(r"\s+", " ", name_part))
                    score = (len(cname), sum(ch.isupper() for ch in cname))
                    cand = (score, cname, label)
                    if (best is None) or (cand > best):
                        best = cand
        if best:
            _, cname, ctype = best
            return cname, ctype
        return None, None

    # ---------- ana akış ----------
    out_rows = []

    for idx, img in enumerate(doc_images):
        probe = _detect_table_top(img)
        if not probe:
            if debug: print(f"[p{idx}] No table found.")
            continue
        y_top, (x,y,w,h), gray = probe
        upper = _extract_upper(img, y_top)
        if upper is None or upper.size == 0:
            if debug: print(f"[p{idx}] Empty upper region.")
            continue

        if debug and show_fig:
            vis = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
            cv2.rectangle(vis,(x,y),(x+w,y+h),(0,255,0),2)
            cv2.line(vis,(0,y_top),(gray.shape[1]-1,y_top),(255,0,0),2)
            plt.figure(figsize=(9,4))
            plt.imshow(cv2.cvtColor(upper, cv2.COLOR_BGR2RGB))
            plt.title(f"[p{idx}] Upper section")
            plt.axis("off"); plt.show()

        # OCR (senin fonksiyonun)
        text = ocr_fn(upper) or ""
        lines = [ln for ln in (text.splitlines() if text else []) if ln and ln.strip()]
        if debug:
            print(f"[p{idx}] OCR chars={len(text)} lines={len(lines)}")

        # Tarih
        date = None
        for ln in lines:
            date = _extract_date(ln)
            if date: break

        # Şirket adı + tür (STRICT: tür bulunmazsa şirket_adı=None)
        company_name, company_type = _extract_company_strict(lines)

        out_rows.append({
            "page_index": idx,
            "tarih": date,
            "şirket_adı": company_name,   # tür yoksa None
            "şirket_türü": company_type
        })

    return pd.DataFrame(out_rows)