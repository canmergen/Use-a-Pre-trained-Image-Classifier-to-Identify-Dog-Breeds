# ==================== Yardımcı Yapılar ====================

from dataclasses import dataclass
from typing import List, Tuple, Optional, Dict
import numpy as np
from difflib import SequenceMatcher

@dataclass(frozen=True)
class TextBox:
    x:int; y:int; w:int; h:int

def xywh(b: TextBox) -> Tuple[int,int,int,int]:
    return int(b.x), int(b.y), int(b.w), int(b.h)

def union(a: TextBox, b: TextBox) -> TextBox:
    x1 = min(a.x, b.x); y1 = min(a.y, b.y)
    x2 = max(a.x+a.w, b.x+b.w); y2 = max(a.y+a.h, b.y+b.h)
    return TextBox(x1, y1, x2-x1, y2-y1)

# metin normalize + fuzzy
_TR_TABLE = str.maketrans("çğıöşüÇĞİÖŞÜâÂêÊîÎôÔûÛ", "CGIOSUCGIOSUAAEEIIOOUU")
def _norm_text(s: str) -> str:
    s = (s or "").upper().translate(_TR_TABLE)
    s = s.replace("\n", " ")
    return " ".join(s.split())

def _fuzzy(a: str, b: str) -> float:
    return SequenceMatcher(None, _norm_text(a), _norm_text(b)).ratio()

# alias puanı (token tabanlı ortalama)
def _alias_score(text_u: str, alias: str) -> float:
    t = _norm_text(text_u); a = _norm_text(alias)
    toks_t = t.split(); toks_a = a.split()
    if not toks_t or not toks_a: return 0.0
    bests = []
    for ta in toks_t:
        bests.append(max((_fuzzy(ta, tb) for tb in toks_a), default=0.0))
    return float(np.mean(bests))

# metin için en iyi rol
def _best_role(text: str, role_aliases: Dict[str, List[str]], thr: float) -> Optional[Tuple[str,float]]:
    best_role, best_sc = None, 0.0
    for role, syns in role_aliases.items():
        sc = max((_alias_score(text, s) for s in syns), default=0.0)
        if sc > best_sc:
            best_sc, best_role = sc, role
    return (best_role, best_sc) if best_sc >= thr else None

# imza heuristiği
def _looks_like_signature(box: TextBox, text: str, h_char: float) -> bool:
    # az karakter -> imza ihtimali
    letters_digits = sum(c.isalnum() for c in (text or "")) if text else 0
    if letters_digits > 8:  # yazı fazlaysa imza değil
        return False
    # en-boy oranı: daha yatay
    if box.h <= 0: return False
    asp = box.w / max(1.0, box.h)
    return 1.8 <= asp <= 12.0  # geniş ama aşırı değil; damga-kutu kombinlerini dışarıda bırakma

# en yakın üst kutu index (dikey mesafe: b.y - (top.y+top.h))
def _nearest_above_index(boxes: List[TextBox], i: int) -> Optional[int]:
    b = boxes[i]
    best_j, best_gap = None, None
    for j, top in enumerate(boxes):
        if j == i: continue
        if top.y + top.h <= b.y:  # üstte olanlar
            gap = b.y - (top.y + top.h)
            if (best_gap is None) or (gap < best_gap):
                best_gap, best_j = gap, j
    return best_j

# kutu listesinden tek bir birleşik kutu üret
def _union_many(boxes: List[TextBox]) -> TextBox:
    out = boxes[0]
    for b in boxes[1:]:
        out = union(out, b)
    return out

# ==================== Ana Grup Fonksiyonu ====================

def build_final_boxes(
    merged_boxes: List[TextBox],
    ocr_texts: List[str],
    role_aliases: Dict[str, List[str]],
    role_priority: List[str],
    thr: float = 0.72,
    include_sermaye: bool = False,
    dbg: bool = False
) -> List[TextBox]:
    """
    - Label kutusu grup başlatır (sermaye opsiyonel).
    - Aşağı doğru imza dahil olana kadar kutuları ekler, başka rol görürse durur.
    - Tek kalan imzayı her durumda yukarıdaki en yakın kutuya zorla bağlar.
    - Her grup tek bir role aittir (karışmaz).
    """
    assert len(merged_boxes) == len(ocr_texts), "kutu ve OCR uzunlukları eşit olmalı"

    n = len(merged_boxes)
    if n == 0:
        return []

    # karakter yüksekliği ~ medyan kutu yüksekliği
    hs = [b.h for b in merged_boxes if b.h > 0]
    h_char = float(np.median(hs)) if hs else 20.0

    # kutuları yukarıdan aşağıya sırala
    order = list(range(n))
    order.sort(key=lambda i: (merged_boxes[i].y, merged_boxes[i].x))

    # her kutunun rolü
    roles: List[Optional[str]] = [None]*n
    role_scores: List[float] = [0.0]*n
    for i in range(n):
        br = _best_role(ocr_texts[i], role_aliases, thr)
        if br is not None:
            r, s = br
            if (r == "sermaye") and not include_sermaye:
                continue
            roles[i] = r
            role_scores[i] = s

    used = [False]*n
    groups: List[List[int]] = []

    # bir role ait görünen ilk kutulara role_priority sırasını uygula
    def role_rank(r: Optional[str]) -> int:
        if r is None: return 10**6
        try:
            return role_priority.index(r)
        except ValueError:
            return 10**5

    # sırayı, önce y sonra role önceliğine göre hafifçe düzenle
    order.sort(key=lambda i: (merged_boxes[i].y, role_rank(roles[i])))

    # 1) label tabanlı gruplar
    for i in order:
        if used[i]: continue
        if roles[i] is None:
            continue  # label yoksa burada grup başlatmıyoruz (alttaki adım imzaya bağlayacak)

        role_here = roles[i]
        members = [i]
        used[i] = True

        # aşağı kayarak ekle
        k = order.index(i)+1
        while k < len(order):
            j = order[k]
            if used[j]:
                k += 1
                continue

            # başka role görüldü -> dur
            if roles[j] is not None and roles[j] != role_here:
                break

            members.append(j)
            used[j] = True

            # imza geldiyse, burada bitir
            if _looks_like_signature(merged_boxes[j], ocr_texts[j], h_char):
                break

            k += 1

        groups.append(members)

    # 2) geriye kalan imzaları en yakın üste zorla bağla
    for i in order:
        if used[i]: continue
        # imza değilse görmezden gel
        if not _looks_like_signature(merged_boxes[i], ocr_texts[i], h_char):
            continue

        top_j = _nearest_above_index(merged_boxes, i)
        if top_j is None:
            # en üstte tek başına imza kaldıysa tek kutu olarak bırak
            groups.append([i]); used[i] = True
            if dbg: print("[DBG] üstte kutu yok, imza tek bırakıldı:", i)
            continue

        # top_j hangi grubun içinde? o gruba ekle; yoksa kendi grubu yap
        appended = False
        for g in groups:
            if top_j in g:
                g.append(i)
                used[i] = True
                appended = True
                if dbg: print(f"[DBG] imza yukarıya zorla bağlandı: i={i} -> top_j={top_j}")
                break
        if not appended:
            # top_j henüz bir grupta değilse, yeni grup: [top_j, imza]
            groups.append([top_j, i])
            used[i] = True
            used[top_j] = True
            if dbg: print(f"[DBG] yeni grup(top+imza): [{top_j}, {i}]")

    # 3) hala kullanılmayan metin kutuları tek başına ekle
    for i in order:
        if not used[i]:
            groups.append([i])
            used[i] = True

    # 4) gruptaki kutuları birleşik tek kutuya çevir
    final_boxes: List[TextBox] = []
    for g in groups:
        g_boxes = [merged_boxes[idx] for idx in sorted(set(g))]
        final_boxes.append(_union_many(g_boxes))

    # görsel tutarlılık: soldan-sağa, yukarıdan-aşağı sırala
    final_boxes.sort(key=lambda b: (b.y, b.x))
    return final_boxes