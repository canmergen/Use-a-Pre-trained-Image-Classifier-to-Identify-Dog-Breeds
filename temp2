def build_per_box_df_onecall_v2(
    lower_img,
    final_boxes,
    *,
    sig_boxes,
    role_blocks,
    sermaye_boxes,
    known_names,
    ocr_url: str,
    lang: str = "tur+eng+lat",
    role_threshold: float = 0.80,
    name_sim_threshold: float = 0.82,
):
    """
    Tek fonksiyon: OCR (remote) + kutu analizi + per_box_df üretimi.
    Geliştirmeler:
      - known_names için ad+(kısmi)soyad bileşik eşleme
      - sermaye kutusunda name_in_box = tutar
    Dönüş: DataFrame[i, bbox, loc, sig, role_best, role_score, name_in_box, text_preview]
    """
    # ---- imports ----
    import re, json, base64, unicodedata
    from typing import Any, Tuple, List, Dict, Optional
    import numpy as np
    import pandas as pd
    import cv2, requests
    from rapidfuzz import fuzz, process, utils as rf_utils

    # ---------- geometry ----------
    def _to_xywh(b: Any) -> Optional[Tuple[int,int,int,int]]:
        if isinstance(b, (tuple, list, np.ndarray)) and len(b)==4:
            x,y,w,h = [int(round(float(v))) for v in b]; return (x,y,w,h)
        if isinstance(b, dict):
            if all(k in b for k in ("x","y","w","h")):
                return int(b["x"]), int(b["y"]), int(b["w"]), int(b["h"])
            if all(k in b for k in ("x0","y0","x1","y1")):
                return int(b["x0"]), int(b["y0"]), int(b["x1"]-b["x0"]), int(b["y1"]-b["y0"])
            if all(k in b for k in ("left","top","right","bottom")):
                return int(b["left"]), int(b["top"]), int(b["right"]-b["left"]), int(b["bottom"]-b["top"])
        return None

    def _to_xyxy(b: Any) -> Tuple[int,int,int,int]:
        x,y,w,h = _to_xywh(b); return (x, y, x+w, y+h)

    def _iou(a, b) -> float:
        ax1,ay1,ax2,ay2 = a; bx1,by1,bx2,by2 = b
        ix1,iy1 = max(ax1,bx1), max(ay1,by1)
        ix2,iy2 = min(ax2,bx2), min(ay2,by2)
        iw, ih = max(0, ix2-ix1), max(0, iy2-iy1)
        inter = iw * ih
        if inter == 0: return 0.0
        aarea = (ax2-ax1)*(ay2-ay1); barea = (bx2-bx1)*(by2-by1)
        return inter / (aarea + barea - inter + 1e-9)

    def _contains(outer, inner, pad=2) -> bool:
        ox1,oy1,ox2,oy2 = outer; ix1,iy1,ix2,iy2 = inner
        return (ix1 >= ox1-pad) and (iy1 >= oy1-pad) and (ix2 <= ox2+pad) and (iy2 <= oy2+pad)

    def _any_overlap(a, group) -> bool:
        for g in group:
            if _iou(a, g) > 0 or _contains(a, g) or _contains(g, a): return True
        return False

    # ---------- text / roles / names ----------
    def _strip_diac(s: str) -> str:
        return "".join(c for c in unicodedata.normalize("NFKD", s) if not unicodedata.combining(c))
    def _U(s: str) -> str:
        s = (s or "").upper(); return re.sub(r"\s+"," ",_strip_diac(s)).strip()

    ROLE_ALIASES: Dict[str, List[str]] = {
        "toplanti_baskani":    ["TOPLANTI BAŞKANI","TOPLANTI BASKANI"],
        "yk_baskani":          ["YÖNETİM KURULU BAŞKANI","YONETIM KURULU BASKANI","YK BAŞKANI","YK BASKANI"],
        "yk_uyesi":            ["YÖNETİM KURULU ÜYESİ","YONETIM KURULU UYESI","YK ÜYESİ","YK UYESI","YÖNETİM KURULU ÜYELERİ"],
        "bakanlik_temsilcisi": ["BAKANLIK TEMSİLCİSİ","TİCARET BAKANLIĞI TEMSİLCİSİ","TICARET BAKANLIGI TEMSILCISI"],
        "katip":               ["KÂTİP","KATİP","OY TOPLAMA MEMURU","OY TOPLAYICI"],
        "divan_baskani":       ["DİVAN BAŞKANI","DIVAN BASKANI"],
        "tutanak_yazmani":     ["TUTANAK YAZMANI","YAZMAN"],
    }
    ROLE_PRIORITY = ["toplanti_baskani","yk_baskani","yk_uyesi","bakanlik_temsilcisi","katip","divan_baskani","tutanak_yazmani"]
    ROLE_TOKENS = set(sum([a.split() for v in ROLE_ALIASES.values() for a in v], [])) | {
        "YÖNETİM","KURULU","ÜYE","ÜYELERİ","ÜYELER","ÜYESİ","BAŞKAN","BAŞKANI","KATİP","KÂTİP",
        "DİVAN","OY","TOPLAMA","MEMURU","TEMSİLCİSİ","BAKANLIK","YAZMAN","İMZA","IMZA","KAŞE","MÜHÜR","STAMP"
    }

    def best_role_for_text(text: str):
        tU = _U(text)
        def _score(alias: str) -> float: return fuzz.token_set_ratio(tU, _U(alias)) / 100.0
        best_role, best_score = None, 0.0
        for rk, aliases in ROLE_ALIASES.items():
            sc = max(_score(a) for a in aliases)
            if (sc > best_score) or (abs(sc-best_score) < 1e-6 and (best_role is None or ROLE_PRIORITY.index(rk) < ROLE_PRIORITY.index(best_role))):
                best_role, best_score = rk, sc
        return best_role, best_score

    def remove_role_words(text: str) -> str:
        toks = re.findall(r"[A-Za-zÇĞİÖŞÜçğıöşü’']+", text)
        toks = [t for t in toks if _U(t) not in ROLE_TOKENS]
        return " ".join(toks)

    def raw_name_candidates(text: str) -> List[str]:
        t = text.replace("\n"," ")
        segs = [p.strip() for p in re.split(r"\s*(?:[,;/]| ve )\s*", t, flags=re.IGNORECASE) if p.strip()]
        out: List[str] = []
        for seg in segs:
            toks = re.findall(r"[A-Za-zÇĞİÖŞÜçğıöşü’']+", seg)
            if not toks: continue
            n = len(toks)
            for L in (3,2):
                for i in range(max(0, n-L+1)): out.append(" ".join(toks[i:i+L]))
            if n == 1: out.append(toks[0])
        return list(dict.fromkeys(out))

    # --- yeni: ad + kısmi soyad ile known map ---
    def map_by_first_and_partial_last(text: str, pool: List[str]) -> Optional[str]:
        if not pool: return None
        toks = [t for t in re.findall(r"[A-Za-zÇĞİÖŞÜçğıöşü’']+", remove_role_words(text)) if len(t) >= 2]
        if not toks: return None
        # metinden muhtemel "ad" tokenları
        first_tokens = toks[:3]  # ilk birkaç kelime en kuvvetli sinyal olur
        best_name, best_combo = None, 0.0
        for kn in pool:
            parts = [p for p in kn.split() if p]
            if not parts: continue
            k_first, k_last = parts[0], parts[-1]
            # ad skoru: token set içinde en iyi eş *yüksek* olmalı
            ad_scores = [fuzz.token_set_ratio(_U(ft), _U(k_first))/100.0 for ft in first_tokens]
            ad_score = max(ad_scores) if ad_scores else 0.0
            # soyad skoru: partial (prefix/substring) toleranslı
            # örn. BOZGEYIK vs BOZGEYIK, BOZGEY gibi
            last_score = fuzz.partial_ratio(_U(" ".join(toks)), _U(k_last))/100.0
            combo = 0.7*ad_score + 0.3*last_score
            if ad_score >= 0.85 and last_score >= 0.60 and combo > best_combo:
                best_combo, best_name = combo, kn
        return best_name

    def map_to_known_fallback(name: str, pool: List[str], thr: float) -> Optional[str]:
        if not pool: return None
        best = process.extractOne(name, pool, scorer=fuzz.token_set_ratio)
        if best and best[1] >= thr*100: return best[0]
        return None

    def pick_name_from_text(text: str, pool: List[str]) -> Optional[str]:
        # 1) güçlü kural: ad + kısmi soyad
        direct = map_by_first_and_partial_last(text, pool)
        if direct: return direct
        # 2) adaylardan fuzzy
        cands = raw_name_candidates(remove_role_words(text))
        seen, chosen = set(), []
        for c in cands:
            mapped = map_to_known_fallback(c, pool, name_sim_threshold)
            name = mapped or c
            if name not in seen:
                seen.add(name); chosen.append(name)
        return "; ".join(chosen) if chosen else None

    def find_tckn(text: str) -> Optional[str]:
        m = re.findall(r"(?<!\d)(\d{10,11})(?!\d)", text.replace(" ", ""))
        return "; ".join(list(dict.fromkeys(m))) if m else None

    # --- sermaye tutar çıkarımı ---
    _NUM_RE = re.compile(r"(?<!\d)(\d{1,3}(?:[.,]\d{3})+|\d+)(?:[.,]\d{2})?(?!\d)")
    def extract_amount(text: str) -> Optional[str]:
        # para ile ilgili kelimeleri taşıyan satırlar daha ağırlıklı kabul edilir
        t = _U(text)
        nums = _NUM_RE.findall(text)
        if not nums: return None
        # sayıları normalize et → saf sayı kıyaslaması
        def _to_float(s):
            s = s.replace(" ", "")
            # 1.234.567,89 veya 1,234,567.89
            if s.count(",") > 0 and s.count(".") > 0:
                if s.rfind(",") > s.rfind("."):
                    s = s.replace(".", "").replace(",", ".")
                else:
                    s = s.replace(",", "")
            else:
                # tek ayraç varsa: binlik mi ondalık mı heuristik
                if s.count(",") == 1 and len(s.split(",")[-1]) == 2:
                    s = s.replace(",", ".")
                else:
                    s = s.replace(",", "")
            try:
                return float(s)
            except Exception:
                return None
        pairs = [(n, _to_float(n)) for n in nums]
        pairs = [(raw, val) for (raw,val) in pairs if val is not None]
        if not pairs: return None
        # en büyük değer genelde toplamdır
        raw, _ = max(pairs, key=lambda x: x[1])
        return raw

    # ---------- OCR (endpoint payload: image + config) ----------
    def _ocr_remote_png(img_gray, *, psm: int, oem: int) -> str:
        ok, buf = cv2.imencode(".png", img_gray)
        if not ok: return ""
        payload = {"image": base64.b64encode(buf.tobytes()).decode("ascii"),
                   "lang": lang,
                   "config": f"-psm {int(psm)} -oem {int(oem)}"}
        try:
            r = requests.post(ocr_url, data=json.dumps(payload), headers={"Content-Type":"application/json"}, timeout=60)
            r.raise_for_status()
            j = r.json()
            return (j.get("text") or "").strip()
        except Exception:
            return ""

    def ocr_box(lower_img, xywh: Tuple[int,int,int,int], psm: int, oem: int) -> str:
        x,y,w,h = xywh
        crop = lower_img[max(0,y):y+h, max(0,x):x+w]
        if crop is None or getattr(crop, "size", 0) == 0: return ""
        gray = cv2.cvtColor(crop, cv2.COLOR_BGR2GRAY)
        gray = cv2.fastNlMeansDenoising(gray, None, 15, 7, 21)
        _, bw = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)
        return _ocr_remote_png(bw, psm=psm, oem=oem)

    # ---------- kutular ----------
    final_xywh = [b for b in (_to_xywh(b) for b in final_boxes) if b is not None and b[2]>0 and b[3]>0]
    final_xyxy = [_to_xyxy(b) for b in final_xywh]
    sig_xyxy   = [_to_xyxy(b) for b in (sig_boxes or [])]
    role_xyxy  = [_to_xyxy(b) for b in (role_blocks or [])]
    serm_xyxy  = [_to_xyxy(b) for b in (sermaye_boxes or [])]
    known_pool = list(dict.fromkeys(known_names or []))

    def decide_psm_oem(loc: str) -> Tuple[int,int]:
        if loc == "sermaye": return 1, 1
        if loc == "roles":   return 11, 1
        return 11, 1

    # ---------- ana döngü ----------
    rows = []
    for i, (b_wh, b_xyxy) in enumerate(zip(final_xywh, final_xyxy)):
        loc = "roles" if _any_overlap(b_xyxy, role_xyxy) else ("sermaye" if _any_overlap(b_xyxy, serm_xyxy) else "other")
        sig = any(_contains(b_xyxy, s, pad=2) or _iou(b_xyxy, s) >= 0.02 for s in sig_xyxy)

        psm0, oem0 = decide_psm_oem(loc)
        text0 = ocr_box(lower_img, b_wh, psm=psm0, oem=oem0)
        text_preview = re.sub(r"\s+"," ",text0)[:200]

        role_key, role_score = best_role_for_text(text0)
        role_best = role_key if (role_score >= role_threshold or loc=="roles") else None

        # --- sermaye: amount yakala ve direkt yaz ---
        if loc == "sermaye":
            amount = extract_amount(text0)
            # fallback: okunmadıysa (1,1) ile tekrar dene
            if not amount:
                text1 = ocr_box(lower_img, b_wh, psm=1, oem=1)
                if len(text1) > len(text0): text_preview = re.sub(r"\s+"," ",text1)[:200]
                amount = extract_amount(text1)
            name_in_box = amount
        else:
            # --- kişi adı çıkarımı + TCKN
            name1 = pick_name_from_text(text0, known_pool)
            tckn0 = find_tckn(text0)

            # Fallback OCR (isim zayıf/boş)
            need_fallback = (not name1) or (name1 and known_pool and max((fuzz.token_set_ratio(name1, k) for k in known_pool), default=0) < name_sim_threshold*100)
            if need_fallback:
                text1 = ocr_box(lower_img, b_wh, psm=1, oem=1)
                if text1 and (len(text1) > len(text0) or not name1):
                    role_key2, role_score2 = best_role_for_text(text1)
                    if role_score2 > role_score:
                        role_key, role_score = role_key2, role_score2
                        role_best = role_key if (role_score >= role_threshold or loc=="roles") else role_best
                    name2 = pick_name_from_text(text1, known_pool)
                    if name2: name1 = name2
                    tckn1 = find_tckn(text1)
                    if tckn1: tckn0 = tckn0 + ("; "+tckn1 if tckn0 else tckn1)
                    if len(text1) > len(text0):
                        text_preview = re.sub(r"\s+"," ",text1)[:200]

            name_in_box = (name1 + " | " + tckn0) if (name1 and tckn0) else (tckn0 or name1)

        rows.append({
            "i": i,
            "bbox": b_wh,
            "loc": loc,
            "sig": bool(sig),
            "role_best": role_best,
            "role_score": float(role_score),
            "name_in_box": name_in_box,
            "text_preview": text_preview
        })

    return pd.DataFrame(rows, columns=["i","bbox","loc","sig","role_best","role_score","name_in_box","text_preview"])