from difflib import SequenceMatcher
from typing import List, Dict, Any, Tuple
import numpy as np


def mark_signatures_on_imza_column(
    table_dfs: List["pd.DataFrame"],
    page_cells_all: List[List[Dict[str, Any]]],
    sig_boxes: List[Dict[str, Any]],
    signature_header_target: str = "IMZA",   # veya "İMZA"
    fuzzy_min_score: float = 0.7,
    sig_cover_threshold: float = 0.25,       # imzanın en az %25'i hücre içinde
    cell_cover_threshold: float = 0.15,      # hücrenin en az %15'i imza ile kaplı
):
    """
    Mantık:
    - Her sayfa için, her İMZA hücresi bazında bak:
        * Bu hücreye giren tüm imza kutularının overlap alanını hesapla.
        * Eğer bu overlap, imza alanının belirli oranından (sig_cover_threshold)
          veya hücre alanının belirli oranından (cell_cover_threshold) fazlaysa
          o satırı 1 yap.
    - Aynı YOLO kutusu birden fazla hücreyi yeterince kaplıyorsa, o satırların
      hepsi 1 olur (tek kutuda iki imza sorunu çözülür).
    """

    # 1) YOLO çıktısını normalize et: (image_index, x_min, y_min, x_max, y_max)
    norm_sigs: List[Dict[str, Any]] = []

    for sb in sig_boxes:
        img_idx = sb.get("image_index", 0)
        boxes = sb.get("boxes", [])

        for b in boxes:
            # b: {"xyxy":[x1,y1,x2,y2], ...} vb.
            xyxy = (
                b.get("xyxy")
                or b.get("bbox")
                or b.get("xxyy")
                or b
            )
            if xyxy is None or len(xyxy) != 4:
                continue

            x1, y1, x2, y2 = map(float, xyxy)

            norm_sigs.append(
                {
                    "image_index": int(img_idx),
                    "x_min": x1,
                    "y_min": y1,
                    "x_max": x2,
                    "y_max": y2,
                }
            )

    # 2) Overlap ölçüleri
    def overlap_measures(cell: Dict[str, Any], sig: Dict[str, Any]) -> Tuple[float, float, float]:
        """
        return (intersection_area, frac_sig, frac_cell)
            intersection_area: kesişim alanı
            frac_sig         : imza alanının yüzde kaçı hücre içinde
            frac_cell        : hücre alanının yüzde kaçı imza ile kaplı
        """
        xA = max(float(cell["x"]), sig["x_min"])
        yA = max(float(cell["y"]), sig["y_min"])
        xB = min(float(cell["x"]) + float(cell["w"]), sig["x_max"])
        yB = min(float(cell["y"]) + float(cell["h"]), sig["y_max"])

        inter_w = max(0.0, xB - xA)
        inter_h = max(0.0, yB - yA)
        inter_area = inter_w * inter_h

        if inter_area <= 0:
            return 0.0, 0.0, 0.0

        area_cell = float(cell["w"]) * float(cell["h"])
        area_sig = (sig["x_max"] - sig["x_min"]) * (sig["y_max"] - sig["y_min"])

        frac_sig = inter_area / area_sig if area_sig > 0 else 0.0
        frac_cell = inter_area / area_cell if area_cell > 0 else 0.0

        return inter_area, frac_sig, frac_cell

    # 3) Kolon adını fuzzy ile bul
    def fuzzy_best_col(columns, target: str):
        best_col = None
        best_score = 0.0
        t = target.upper()

        for col in columns:
            s = SequenceMatcher(None, str(col).upper(), t).ratio()
            if s > best_score:
                best_score = s
                best_col = col
        return best_col, best_score

    # 4) Her sayfa için imza kolonunu 0/1 olarak doldur
    result_dfs: List["pd.DataFrame"] = []

    for page_index, df in enumerate(table_dfs):
        if df is None or df.empty:
            result_dfs.append(df)
            continue

        # "page_index" hariç kolonlar
        data_cols = [c for c in df.columns if c != "page_index"]

        sig_col_name, score = fuzzy_best_col(data_cols, signature_header_target)

        # imza başlığı yoksa olduğu gibi bırak
        if sig_col_name is None or score < fuzzy_min_score:
            result_dfs.append(df)
            continue

        sig_col_pos = data_cols.index(sig_col_name)

        # İMZA kolonunu 0 ile başlat
        df[sig_col_name] = 0

        # Sayfanın hücreleri ve imzaları
        cells = page_cells_all[page_index]
        page_sigs = [s for s in norm_sigs if s["image_index"] == page_index]

        if not cells or not page_sigs:
            result_dfs.append(df)
            continue

        # Sadece imza kolonundaki hücreler
        imza_cells = [c for c in cells if c["col"] == sig_col_pos]
        if not imza_cells:
            result_dfs.append(df)
            continue

        # Her hücre için en iyi overlap'i bul
        for cell in imza_cells:
            best_frac_sig = 0.0
            best_frac_cell = 0.0

            for sig in page_sigs:
                inter_area, frac_sig, frac_cell = overlap_measures(cell, sig)
                if inter_area <= 0:
                    continue

                if frac_sig > best_frac_sig:
                    best_frac_sig = frac_sig
                if frac_cell > best_frac_cell:
                    best_frac_cell = frac_cell

            # Herhangi bir imza bu hücreyi "yeterince" kaplıyorsa 1 yap
            if (best_frac_sig >= sig_cover_threshold) or (best_frac_cell >= cell_cover_threshold):
                row_idx = cell["row"]
                if row_idx in df.index:
                    df.at[row_idx, sig_col_name] = 1

        result_dfs.append(df)

    return result_dfs

table_dfs_marked = mark_signatures_on_imza_column(
    table_dfs=table_df,
    page_cells_all=page_cells_all,
    sig_boxes=sig_boxes,
    signature_header_target="İMZA",
    fuzzy_min_score=0.7,
    sig_cover_threshold=0.25,     # istersen 0.2 yap
    cell_cover_threshold=0.15,    # istersen 0.1–0.2 aralığında oynayabilirsin
)

for df in table_dfs_marked:
    display(df)