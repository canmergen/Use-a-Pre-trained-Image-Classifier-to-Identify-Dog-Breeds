# -*- coding: utf-8 -*-
import cv2, re, unicodedata
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# --- Fuzzy helper (RapidFuzz varsa onu kullan, yoksa difflib) ---
try:
    from rapidfuzz import fuzz, process
    def _fuzzy_ratio(a, b): return float(fuzz.partial_ratio(a, b)) / 100.0
except Exception:
    import difflib
    def _fuzzy_ratio(a, b): return difflib.SequenceMatcher(None, a, b).ratio()

def extract_top_info_from_doc_images_fuzzy(
    doc_images,
    *,
    ocr_fn,                          # <- SENİN fonksiyonun: img_bgr -> str
    debug: bool = False,
    show_fig: bool = False,          # debug görsellerini göstermek için
    table_top_shift_ratio: float = 0.02,
    fuzzy_type_thresh: float = 0.82, # şirket türü fuzzy eşiği
    fuzzy_join_lines: bool = True,   # satır birleştirip ek fuzzy denemesi
) -> pd.DataFrame:
    """
    doc_images: List[np.ndarray (BGR)]
    ocr_fn: callable(img_bgr) -> str  (örn. pytesseract_ocr_text)
    """

    # ---- yardımcılar ----
    def _normalize_line(s: str) -> str:
        s = unicodedata.normalize("NFKC", s or "")
        s = s.replace("\u00A0"," ").replace("\u200B"," ")
        s = s.replace("’","'").replace("“","\"").replace("”","\"")
        tr = str.maketrans({"İ":"i","I":"ı","Ç":"ç","Ğ":"ğ","Ö":"ö","Ş":"ş","Ü":"ü"})
        s = s.translate(tr).lower()
        s = re.sub(r"\s+", " ", s).strip()
        return s

    def _upper_tr(s: str) -> str:
        rep={"i":"İ","ı":"I","ğ":"Ğ","ü":"Ü","ş":"Ş","ö":"Ö","ç":"Ç"}
        return "".join(rep.get(c,c.upper()) for c in (s or "").lower())

    def _detect_table_top(gray: np.ndarray):
        if gray.ndim == 3:
            gray = cv2.cvtColor(gray, cv2.COLOR_BGR2GRAY)
        H, W = gray.shape[:2]
        blur = cv2.GaussianBlur(gray, (3,3), 0)
        _, bw = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)
        if np.mean(bw) > 127: bw = cv2.bitwise_not(bw)
        kx = max(10, W//80); ky = max(10, H//80)
        horiz = cv2.morphologyEx(bw, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_RECT,(kx,1)), iterations=2)
        vert  = cv2.morphologyEx(bw, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_RECT,(1,ky)), iterations=2)
        mask = cv2.add(horiz, vert)
        cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if not cnts: return None
        x,y,w,h = cv2.boundingRect(max(cnts, key=cv2.contourArea))
        y_top = int(y + max(1, round(table_top_shift_ratio*h)))
        return max(0, min(H-1, y_top)), (x,y,w,h), gray

    def _extract_upper(img, y_top): 
        return img[:y_top,:] if y_top is not None else None

    def _extract_date(text: str):
        t = unicodedata.normalize("NFKC", text or "")
        t = t.replace("⁄","/").replace("–","/").replace("-","/")
        t = re.sub(r"\s+"," ",t)
        pat = re.compile(r"(?<!\d)(\d{1,2})[/.](\d{1,2})[/.](\d{2,4})(?!\d)")
        for m in pat.finditer(t):
            d, mo, yy = m.group(1), m.group(2), m.group(3)
            try: d_i, m_i = int(d), int(mo)
            except: continue
            yy = re.sub(r"^\D+","",yy)
            if len(yy) == 2: y_i = int("20"+yy)
            elif len(yy) > 4: y_i = int(yy[-4:])
            else:
                try: y_i = int(yy)
                except: continue
            if 1<=d_i<=31 and 1<=m_i<=12 and 1900<=y_i<=2100:
                return f"{d_i:02d}/{m_i:02d}/{y_i:04d}"
        # brute-force
        digits = re.sub(r"\D","",t)
        if len(digits) >= 8:
            best=None
            for i in range(len(digits)-7):
                try:
                    d_i=int(digits[i:i+2]); m_i=int(digits[i+2:i+4]); y_i=int(digits[i+4:i+8])
                except: continue
                if 1<=d_i<=31 and 1<=m_i<=12 and 1900<=y_i<=2100:
                    tup=(y_i,i,d_i,m_i)
                    if best is None or tup>best: best=tup
            if best:
                y_i,_,d_i,m_i=best
                return f"{d_i:02d}/{m_i:02d}/{y_i:04d}"
        return None

    # --- şirket türü sözlüğü + regex + fuzzy varyantlar ---
    CANON_TYPES = {
        "anonim şirketi": [
            "a.ş", "as", "aş", "anonim şirket", "anonim sirket", "an0nım s1rket", "anonım sirkett"
        ],
        "limited şirketi": [
            "ltd. şti", "ltd şti", "ltd sti", "limited şirket", "limited sirket", "ltd. sti.", "ltd. şti."
        ],
        "holding": ["holding"],
        "kooperatif": ["kooperatif"],
        "kolektif şirket": ["kolektif şirket", "kolektif sirket"],
        "adi komandit şirket": ["adi komandit şirket", "adi komandit sirket"],
        "sermayesi paylara bölünmüş komandit şirket": [
            "sermayesi paylara bölünmüş komandit şirket",
            "sermayesi paylara bolunmus komandit sirket"
        ],
        "komandit şirket": ["komandit şirket", "komandit sirket"],
        "vakıf": ["vakıf", "vakif"],
        "dernek": ["dernek"]
    }

    # tür regex’leri (yüksek kesinlik)
    TYPE_PATTERNS = [
        (r"\ba\s*\.?\s*ş\b", "anonim şirketi"),
        (r"\bas\b", "anonim şirketi"),
        (r"\banonim\s+şirket[iı]?\b", "anonim şirketi"),
        (r"\bltd\s*\.?\s*şt[iı]\b", "limited şirketi"),
        (r"\bltd\s*\.?\s*st[iı]\b", "limited şirketi"),
        (r"\blimited\s+şirket[iı]?\b", "limited şirketi"),
        (r"\bholding\b", "holding"),
        (r"\bkooperatif\b", "kooperatif"),
        (r"\bkolektif\s+şirket[iı]?\b", "kolektif şirket"),
        (r"\badi\s+komandit\s+şirket[iı]?\b", "adi komandit şirket"),
        (r"\bsermayesi\s+paylara\s+bölünmüş\s+komandit\s+şirket[iı]?\b", "sermayesi paylara bölünmüş komandit şirket"),
        (r"\bkomandit\s+şirket[iı]?\b", "komandit şirket"),
        (r"\bvakf[ıi]\b|\bvakif\b", "vakıf"),
        (r"\bdernek\b", "dernek"),
    ]
    TYPE_REGEX = [(re.compile(pat, re.IGNORECASE), label) for pat, label in TYPE_PATTERNS]

    def _find_company(lines: list[str]):
        # 1) regex ile tür bul (yüksek kesinlik)
        best = None
        for raw in lines:
            norm = _normalize_line(raw)
            for creg, label in TYPE_REGEX:
                m = creg.search(norm)
                if m:
                    name_left = raw[:m.start()].strip()
                    name_clean = re.sub(r"[,\.\-_'’\"\s]+$","", name_left)
                    name_up = _upper_tr(re.sub(r"\s+"," ", name_clean))
                    score = (len(name_up), sum(c.isupper() for c in name_up))
                    cand = (score, name_up, label)
                    if best is None or cand > best: best = cand
        if best:
            _, cname, ctype = best
            return cname if cname else None, ctype

        # 2) fuzzy: her satırda canonical tür varyantlarına en iyi eşleşme
        for raw in lines:
            norm = _normalize_line(raw)
            for canonical, variants in CANON_TYPES.items():
                local_best = 0.0; hit_span = None
                for v in variants:
                    sc = _fuzzy_ratio(v, norm)
                    if sc > local_best:
                        local_best = sc
                if local_best >= fuzzy_type_thresh:
                    # ad: satırın tür kısmından önceki bölümü (yaklaşık)
                    # heuristik: tür anahtar kelimesinin ilk kelimesini ara
                    key = variants[0].split()[0]
                    pos = norm.find(key.split('.')[0])  # kaba arama
                    name_left = raw[:max(0,pos)].strip() if pos>0 else raw
                    name_clean = re.sub(r"[,\.\-_'’\"\s]+$","", name_left)
                    cname = _upper_tr(re.sub(r"\s+"," ", name_clean))
                    return (cname if cname else None), canonical

        # 3) satırları birleştirip fuzzy dene (başlık/satır kırılması durumları)
        if fuzzy_join_lines and lines:
            joined_raw = " ".join(lines)
            joined_norm = _normalize_line(joined_raw)
            for canonical, variants in CANON_TYPES.items():
                if max(_fuzzy_ratio(v, joined_norm) for v in variants) >= fuzzy_type_thresh:
                    # adı ilk satırdan al (fallback)
                    cname = _upper_tr(re.sub(r"\s+"," ", lines[0]))
                    return (cname if cname else None), canonical

        return None, None

    # ---- ana akış ----
    rows = []

    for idx, img in enumerate(doc_images):
        y_top_bbox = _detect_table_top(img)
        if not y_top_bbox:
            if debug: print(f"[p{idx}] No table found.")
            continue
        y_top, (x,y,w,h), gray = y_top_bbox

        upper = _extract_upper(img, y_top)
        if upper is None or upper.size == 0:
            if debug: print(f"[p{idx}] Empty upper region.")
            continue

        if debug and show_fig:
            vis = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
            cv2.rectangle(vis,(x,y),(x+w,y+h),(0,255,0),2)
            cv2.line(vis,(0,y_top),(gray.shape[1]-1,y_top),(255,0,0),2)
            plt.figure(figsize=(9,4))
            plt.imshow(cv2.cvtColor(upper, cv2.COLOR_BGR2RGB))
            plt.title(f"[p{idx}] Upper section")
            plt.axis("off"); plt.show()

        # OCR (senin fonksiyonun)
        text = ocr_fn(upper) or ""
        lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
        if debug:
            print(f"[p{idx}] OCR chars={len(text)} lines={len(lines)}")

        # Tarih
        date = None
        for ln in lines:
            date = _extract_date(ln)
            if date: break

        # Şirket adı + türü (regex + fuzzy)
        cname, ctype = _find_company(lines)

        row = {
            "page_index": idx,
            "tarih": date,
            "şirket_adı": cname,
            "şirket_türü": ctype
        }
        if debug: row["debug_text"] = text[:400]
        rows.append(row)

    return pd.DataFrame(rows)