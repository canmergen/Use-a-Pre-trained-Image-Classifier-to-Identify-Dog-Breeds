from typing import Any, List, Tuple, Optional

def link_and_build_final(
    role_blocks: List[Tuple[int,int,int,int]],
    sig_boxes: List[Tuple[int,int,int,int]],
    sermaye_boxes: Optional[List[Tuple[int,int,int,int]]] = None,
    *,
    near_px: int = 3,
    band_pad_scale: float = 0.35,
    band_center_scale: float = 1.0,
    corridor_pad_px: int = 8,
    forbid_crossing: bool = True,
    dbg: bool = False
):
    """
    role_blocks, sig_boxes, sermaye_boxes -> (x,y,w,h) formatında kutular.
    Dönen: dict {"pairs","final","roles","sigs","sermaye"}
    """
    Box = Tuple[int,int,int,int]  # (l,t,r,b)

    def to_ltrb(b: Tuple[int,int,int,int]) -> Box:
        # Giriş her zaman (x,y,w,h)
        x,y,w,h = b
        return (x, y, x+w, y+h)

    def to_xywh(bb: Box) -> Tuple[int,int,int,int]:
        l,t,r,b = bb
        return (l,t, r-l, b-t)

    def union(a: Box, b: Box) -> Box:
        return (min(a[0],b[0]), min(a[1],b[1]), max(a[2],b[2]), max(a[3],b[3]))

    def expand(bb: Box, pad: int) -> Box:
        l,t,r,b = bb
        return (l-pad, t-pad, r+pad, b+pad)

    def intersects(a: Box, b: Box) -> bool:
        return not (a[2] < b[0] or b[2] < a[0] or a[3] < b[1] or b[3] < a[1])

    def center(bb: Box) -> Tuple[float,float]:
        l,t,r,b = bb
        return ((l+r)/2.0, (t+b)/2.0)

    # --- Normalize inputs ---
    roles_ltrb   = [to_ltrb(b) for b in role_blocks]
    sigs_ltrb    = [to_ltrb(b) for b in sig_boxes]
    sermaye_ltrb = [to_ltrb(b) for b in (sermaye_boxes or [])]

    if near_px>0:
        sigs_grown = [expand(s, near_px) for s in sigs_ltrb]
    else:
        sigs_grown = list(sigs_ltrb)

    # --- Role-Sig eşleşmesi ---
    used_roles, used_sigs = set(), set()
    pairs: List[Tuple[int,int]] = []

    for ri, rb in enumerate(roles_ltrb):
        if ri in used_roles: 
            continue
        rl,rt,rr,rbottom = rb
        rh = rbottom - rt
        rcx, rcy = center(rb)
        band_top = int(rcy - (rh*band_pad_scale))
        band_bot = int(rcy + (rh*band_pad_scale))
        band_l   = int(rl - (rr-rl)*band_center_scale)
        band_r   = int(rr + (rr-rl)*band_center_scale)
        band = (band_l, band_top, band_r, band_bot)

        best = None
        for si, sb in enumerate(sigs_grown):
            if si in used_sigs: 
                continue
            if not intersects(band, sb):
                continue

            blocked = False
            if forbid_crossing:
                sl,st,sr,sbtt = sigs_ltrb[si]
                cl = min(rl, sl) - corridor_pad_px
                cr = max(rr, sr) + corridor_pad_px
                ct = min(rbottom, st)
                cb = max(rbottom, st)
                corridor = (cl, ct, cr, cb)
                for oj, ob in enumerate(roles_ltrb):
                    if oj==ri: continue
                    if intersects(corridor, ob): blocked=True; break
                if not blocked:
                    for oj, ob in enumerate(sigs_ltrb):
                        if oj==si: continue
                        if intersects(corridor, ob): blocked=True; break
            if blocked:
                if dbg: print(f"[SKIP] ri={ri} si={si} -> corridor blocked")
                continue

            scx, scy = center(sigs_ltrb[si])
            gap = abs(scy - rcy) + 1e-6
            score = 1.0 / gap
            if (best is None) or (score > best[0]):
                best = (score, si)

        if best is not None:
            si = best[1]
            pairs.append((ri, si))
            used_roles.add(ri)
            used_sigs.add(si)

    # --- Final kutular ---
    final_boxes_ltrb = [union(roles_ltrb[ri], sigs_ltrb[si]) for ri,si in pairs]

    return {
        "pairs": pairs,
        "final": [to_xywh(bb) for bb in final_boxes_ltrb],
        "roles": [to_xywh(bb) for bb in roles_ltrb],
        "sigs":  [to_xywh(bb) for bb in sigs_ltrb],
        "sermaye": [to_xywh(bb) for bb in sermaye_ltrb],
    }