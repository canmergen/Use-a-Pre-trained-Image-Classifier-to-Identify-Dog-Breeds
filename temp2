from dataclasses import dataclass
from typing import Any, Iterable, List, Optional, Tuple
import re

def expand_sermaye_boxes_if_no_amount(
    sermaye_boxes: Iterable[Any],
    all_boxes: Iterable[Any],
    ocr_texts: Optional[Iterable[Any]] = None,   # str listesi veya (x,y,w,h,txt) nesneleri
    *,
    keep_all_numbered: bool = True,
    max_steps_right: int = 3,
    max_steps_down: int = 2,
    v_min: float = 0.40,
    h_min: float = 0.55,
    gap_right_max: int = 700,
    gap_down_max: int = 320,
    allow_right_fallback: bool = True,
    dbg: bool = False,
) -> List[Any]:
    @dataclass(frozen=True)
    class Box:
        x: int; y: int; w: int; h: int
        txt: str = ""
        role: Optional[str] = None

    # --- regexler (metinli mod için) ---
    _num_pat      = re.compile(r"\d")
    _amount_pat   = re.compile(r"(?:^|[^%])(?:(\d{1,3}(?:[.\s’’,]\d{3})+(?:,\d+)?)|\d{5,})")
    _currency_pat = re.compile(r"\b(?:TL|TRY|₺)\b", re.IGNORECASE)
    _percent_pat  = re.compile(r"%\s*\d+")

    # --- yardımcılar ---
    def _get_txt(obj):
        for k in ("txt","text","string"):
            if hasattr(obj, k):
                return str(getattr(obj, k) or "")
        if isinstance(obj, (tuple, list)) and len(obj) >= 5:
            return str(obj[4] or "")
        return ""  # koordinatlar metin sanılmasın

    def _to_box(obj):
        if isinstance(obj, Box): return obj
        if isinstance(obj, (tuple, list)) and len(obj) >= 4:
            return Box(int(obj[0]), int(obj[1]), int(obj[2]), int(obj[3]), _get_txt(obj))
        if all(hasattr(obj, k) for k in ("x","y","w","h")):
            return Box(int(obj.x), int(obj.y), int(obj.w), int(obj.h), _get_txt(obj))
        return None  # str vb. ise None

    def _xyxy(b): return b.x, b.y, b.x+b.w, b.y+b.h
    def _overlap_1d(a1,a2,b1,b2): return max(0, min(a2,b2)-max(a1,b1))
    def _v_overlap_ratio(a,b): return _overlap_1d(a.y,a.y+a.h,b.y,b.y+b.h)/max(1,min(a.h,b.h))
    def _h_overlap_ratio(a,b): return _overlap_1d(a.x,a.x+a.w,b.x,b.x+b.w)/max(1,min(a.w,b.w))
    def _gap_right(a,b): return b.x-(a.x+a.w)
    def _gap_down(a,b):  return b.y-(a.y+a.h)

    def _merge(a,b):
        ax1,ay1,ax2,ay2=_xyxy(a); bx1,by1,bx2,by2=_xyxy(b)
        nx1,ny1,nx2,ny2=min(ax1,bx1),min(ay1,by1),max(ax2,bx2),max(ay2,by2)
        return Box(nx1,ny1,nx2-nx1,ny2-ny1,(a.txt+" "+b.txt).strip(), a.role or b.role)

    def has_number(s): return bool(_num_pat.search(s or ""))

    def amount_score(s):
        sc=0.0
        if _amount_pat.search(s): sc+=2.0
        if _currency_pat.search(s): sc+=2.0
        if _percent_pat.search(s): sc-=1.5
        sc+=min(1.0, sum(c.isdigit() for c in (s or ""))/8.0)
        return sc

    def contains_amount(s,thr=2.0): return amount_score(s)>=thr

    # --- metni olan OCR box havuzu (varsa) ---
    strings_only_mode = bool(ocr_texts) and all(isinstance(t, str) for t in ocr_texts)
    if dbg and strings_only_mode:
        print("[MODE] strings_only_mode=True (ocr_texts koordinatsız) → geometriye göre genişleteceğim.")

    ocr_pool: List[Box] = []
    if ocr_texts and not strings_only_mode:
        tmp = [_to_box(t) for t in ocr_texts]
        ocr_pool = [b for b in tmp if b and b.txt]

    # metin zenginleştirme sadece koordinatlı OCR varsa yapılır
    def _augment_text(b: Box) -> Box:
        if not ocr_pool or b.txt: 
            return b
        # IOU/center-in ile en iyi metni bul
        best = b; best_sc = amount_score(b.txt)
        bx1,by1,bx2,by2=_xyxy(b)
        for tb in ocr_pool:
            tx1,ty1,tx2,ty2=_xyxy(tb)
            ix=_overlap_1d(bx1,bx2,tx1,tx2); iy=_overlap_1d(by1,by2,ty1,ty2)
            if ix<=0 or iy<=0: 
                continue
            sc = amount_score(tb.txt)
            if sc>best_sc:
                best = Box(b.x,b.y,b.w,b.h,(b.txt+" "+tb.txt).strip(), b.role)
                best_sc = sc
        if best is not b and dbg:
            print(f"[AUGMENT] +txt '{best.txt[:60]}'")
        return best

    # --- komşu seçiciler (yakınlık → overlap → skor) ---
    def _best_right_neighbor(cur, pool):
        cand=[]
        for b in pool:
            if b.x <= cur.x+cur.w: 
                continue
            vovl=_v_overlap_ratio(cur,b); gap=_gap_right(cur,b)
            if vovl<v_min or gap<0 or gap>gap_right_max:
                if dbg: print(f"[RIGHT-REJECT] gap={gap} vovl={vovl:.2f} txt='{(b.txt or '')[:40]}'")
                continue
            bx = _augment_text(b)
            sc = amount_score(bx.txt) if not strings_only_mode else 0.0
            cand.append((gap, -vovl, -sc, bx))
        if cand:
            cand.sort()
            g,ov,ns,box=cand[0]
            if dbg: print(f"[RIGHT-PICK] gap={g} vovl={-ov:.2f} txt='{(box.txt or '')[:60]}'")
            return box
        if allow_right_fallback:
            fb=[]
            for b in pool:
                if b.x <= cur.x+cur.w: 
                    continue
                gap=_gap_right(cur,b)
                if gap<0 or gap>gap_right_max: 
                    continue
                fb.append((gap, b))
            if fb:
                fb.sort()
                if dbg: print(f"[RIGHT-FALLBACK] gap={fb[0][0]} (overlap yok) txt='{(fb[0][1].txt or '')[:60]}'")
                return fb[0][1]
        return None

    def _best_down_neighbor(cur, pool):
        cand=[]
        for b in pool:
            if b.y <= cur.y+cur.h: 
                continue
            hovl=_h_overlap_ratio(cur,b); gap=_gap_down(cur,b)
            if hovl<h_min or gap<0 or gap>gap_down_max:
                if dbg: print(f"[DOWN-REJECT] gap={gap} hovl={hovl:.2f} txt='{(b.txt or '')[:40]}'")
                continue
            bx = _augment_text(b)
            sc = amount_score(bx.txt) if not strings_only_mode else 0.0
            cand.append((gap, -hovl, -sc, bx))
        if not cand:
            return None
        cand.sort()
        g,ov,ns,box=cand[0]
        if dbg: print(f"[DOWN-PICK] gap={g} hovl={-ov:.2f} txt='{(box.txt or '')[:60]}'")
        return box

    # --- havuz ---
    pool=[_to_box(b) for b in all_boxes]; pool=[b for b in pool if b]
    uniq={(b.x,b.y,b.w,b.h,b.txt):b for b in pool}
    pool=list(uniq.values())

    out=[]
    for s in sermaye_boxes:
        base=_to_box(s)
        if not base: 
            continue
        base=_augment_text(base)

        # strings_only_mode'da amount şartı aramayacağız
        def _done(txt): 
            return contains_amount(txt) if not strings_only_mode else False

        if _done(base.txt):
            out.append(base)
            if dbg: print("[SERMAYE] already has amount ::", base.txt[:120])
            continue

        cur=base; used=set()

        # RIGHT zinciri
        steps=0
        while (not _done(cur.txt)) and steps<max_steps_right:
            nb=_best_right_neighbor(cur, [b for b in pool if (b.x,b.y,b.w,b.h) not in used])
            if not nb:
                break
            if dbg: print(f"[EXPAND] RIGHT -> '{(nb.txt or '')[:80]}'")
            used.add((nb.x,nb.y,nb.w,nb.h))
            cur=_augment_text(_merge(cur,nb))
            steps+=1

        # DOWN zinciri
        steps=0
        while (not _done(cur.txt)) and steps<max_steps_down:
            nb=_best_down_neighbor(cur, [b for b in pool if (b.x,b.y,b.w,b.h) not in used])
            if not nb:
                break
            if dbg: print(f"[EXPAND] DOWN -> '{(nb.txt or '')[:80]}'")
            used.add((nb.x,nb.y,nb.w,nb.h))
            cur=_augment_text(_merge(cur,nb))
            steps+=1

        if not strings_only_mode:
            # metinli mod: amount bulunduysa al, yoksa koru/drop
            if _done(cur.txt):
                if dbg: print("[EXPAND] success (amount found)")
                out.append(cur)
            else:
                if dbg: print("[EXPAND] DROP (no amount) ::", base.txt[:120])
                if keep_all_numbered or has_number(base.txt):
                    out.append(base)
        else:
            # strings_only_mode: amaç doğru GEOMETRİK kapsama; zincir sonucu her durumda dön
            if dbg: print("[EXPAND] strings-only: returning merged geometry.")
            out.append(cur)

    return out