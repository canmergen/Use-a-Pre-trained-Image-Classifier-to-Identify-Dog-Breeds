def expand_sermaye_boxes_if_no_amount(
    sermaye_boxes: List[Box],
    all_boxes: List[Any],        # detected_boxes (geometri için)
    ocr_texts: Iterable[Any],    # (x,y,w,h, txt) veya TextBox
    dbg: bool = False,
) -> List[Box]:
    import re
    from typing import Tuple, Optional, List

    num_pat = re.compile(r"\d")

    # ---------- temel yardımcılar ----------
    def _has_number(s: str) -> bool:
        return bool(num_pat.search(s or ""))

    def _to_box(obj: Any) -> Box:
        if isinstance(obj, Box):
            return obj
        if isinstance(obj, (tuple, list)):
            return as_box(obj)
        if hasattr(obj, "x") and hasattr(obj, "y"):
            return as_box(obj)
        raise TypeError(f"cannot convert {type(obj)} to Box")

    def _xyxy(b: Box) -> Tuple[int,int,int,int]:
        return b.x, b.y, b.x + b.w, b.y + b.h

    def _overlap_1d(a1: int, a2: int, b1: int, b2: int) -> int:
        return max(0, min(a2, b2) - max(a1, b1))

    def _union(a: Box, b: Box) -> Box:
        ax1, ay1, ax2, ay2 = _xyxy(a)
        bx1, by1, bx2, by2 = _xyxy(b)
        x1, y1, x2, y2 = min(ax1, bx1), min(ay1, by1), max(ax2, bx2), max(ay2, by2)
        txt = ((a.txt or "") + " " + (b.txt or "")).strip()
        return Box(x1, y1, x2 - x1, y2 - y1, txt, a.role or b.role)

    # OCR metinlerini Box'a çevir
    text_boxes: List[Box] = []
    for t in ocr_texts:
        if hasattr(t, "x") and hasattr(t, "y"):
            txt = getattr(t, "txt", "") or getattr(t, "text", "") or ""
            text_boxes.append(Box(int(t.x), int(t.y), int(t.w), int(t.h), str(txt)))
        elif isinstance(t, (tuple, list)) and len(t) >= 5:
            x, y, w, h, txt = t[:5]
            text_boxes.append(Box(int(x), int(y), int(w), int(h), str(txt or "")))

    # detected_boxes -> Box (txt’siz de olabilir)
    geom_boxes: List[Box] = [_to_box(b) for b in all_boxes]

    # belirli bir geometriyi (x,y,w,h) key olarak kullan (id yerine)
    def _gkey(b: Box) -> Tuple[int,int,int,int]:
        return (b.x, b.y, b.w, b.h)

    # ---------- yalnızca OCR metinlerinden komşu arayan seçiciler ----------
    def _nearest_right_text_with_digits(cur: Box, used_keys: set) -> Optional[Box]:
        cx1, cy1, cx2, cy2 = _xyxy(cur)
        cand: List[Tuple[int, Box]] = []
        for tb in text_boxes:
            if _gkey(tb) in used_keys:
                continue
            if not _has_number(tb.txt):
                continue
            tx1, ty1, tx2, ty2 = _xyxy(tb)
            if tx1 <= cx1:
                continue
            if _overlap_1d(cy1, cy2, ty1, ty2) <= 0:  # satır örtüşmesi yok
                continue
            dist = max(0, tx1 - cx2)
            cand.append((dist, tb))
        cand.sort(key=lambda t: (t[0], t[1].x))
        return cand[0][1] if cand else None

    def _nearest_down_text_with_digits(cur: Box, used_keys: set) -> Optional[Box]:
        cx1, cy1, cx2, cy2 = _xyxy(cur)
        cand: List[Tuple[int, Box]] = []
        for tb in text_boxes:
            if _gkey(tb) in used_keys:
                continue
            if not _has_number(tb.txt):
                continue
            tx1, ty1, tx2, ty2 = _xyxy(tb)
            if ty1 <= cy1:
                continue
            if _overlap_1d(cx1, cx2, tx1, tx2) <= 0:  # sütun örtüşmesi yok
                continue
            dist = max(0, ty1 - cy2)
            cand.append((dist, tb))
        cand.sort(key=lambda t: (t[0], t[1].y))
        return cand[0][1] if cand else None

    kept: List[Box] = []
    dropped = 0
    max_steps = max(1, len(text_boxes))  # güvenlik

    for sb in sermaye_boxes:
        base = _to_box(sb)

        # base'in txt'sini OCR textlerinden doldurmaya çalış
        # (aynı satır ve en yakın sağ/alt metin "SERMAYE" gibi sinyal içeriyorsa)
        # ama şart değil; amount aramasını komşuda yapıyoruz
        if dbg:
            print(f"[EXPAND] start :: {base.txt[:70]!r}")

        if _has_number(base.txt):
            kept.append(base)
            if dbg:
                print("[EXPAND] keep-as-is (already has amount)")
            continue

        # ---- 1) SAĞA doğru zincir: yalnızca RAKAM içeren OCR metinleriyle ilerle ----
        cur = base
        used_keys = {_gkey(base)}
        success = False
        steps = 0
        while steps < max_steps:
            nb = _nearest_right_text_with_digits(cur, used_keys)
            if not nb:
                if dbg: print("[EXPAND] RIGHT -> ∅")
                break
            if dbg: print(f"[EXPAND] RIGHT + {nb.txt[:40]!r}")
            used_keys.add(_gkey(nb))
            cur = _union(cur, nb)  # nb zaten txt’li
            steps += 1
            # nb.txt zaten rakamlı; direkt başarı
            kept.append(cur)
            success = True
            if dbg: print("[EXPAND] success via RIGHT chain")
            break

        if success:
            continue

        # ---- 2) AŞAĞI doğru zincir (ORİJİNAL bazla) ----
        cur = base
        used_keys = {_gkey(base)}
        steps = 0
        while steps < max_steps:
            nb = _nearest_down_text_with_digits(cur, used_keys)
            if not nb:
                if dbg: print("[EXPAND] DOWN  -> ∅")
                break
            if dbg: print(f"[EXPAND] DOWN  + {nb.txt[:40]!r}")
            used_keys.add(_gkey(nb))
            cur = _union(cur, nb)
            steps += 1
            kept.append(cur)
            if dbg: print("[EXPAND] success via DOWN chain")
            success = True
            break

        if success:
            continue

        # ---- 3) yoksa drop ----
        dropped += 1
        if dbg:
            print("[EXPAND] DROP (no amount)")

    if dbg:
        print(f"[EXPAND] kept={len(kept)} dropped={dropped}")
    return kept