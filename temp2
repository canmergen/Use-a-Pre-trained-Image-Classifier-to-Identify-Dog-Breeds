from dataclasses import dataclass
from typing import Any, Iterable, List, Optional, Tuple
import re

def expand_sermaye_boxes_if_no_amount(
    sermaye_boxes: Iterable[Any],
    all_boxes: Iterable[Any],
    ocr_texts: Optional[Iterable[Any]] = None,   # str listesi (indis eşli) veya (x,y,w,h,txt) nesneleri
    *,
    keep_all_numbered: bool = True,
    max_steps_right: int = 3,
    max_steps_down: int = 2,
    v_min: float = 0.40,
    h_min: float = 0.55,
    gap_right_max: int = 700,
    gap_down_max: int = 320,
    allow_right_fallback: bool = True,
    dbg: bool = False,
) -> List[Any]:
    @dataclass(frozen=True)
    class Box:
        x: int; y: int; w: int; h: int
        txt: str = ""
        role: Optional[str] = None

    # ----- regexler -----
    _num_pat      = re.compile(r"\d")
    _amount_pat   = re.compile(r"(?:^|[^%])(?:(\d{1,3}(?:[.\s’’,]\d{3})+(?:,\d+)?)|\d{5,})")
    _currency_pat = re.compile(r"\b(?:TL|TRY|₺)\b", re.IGNORECASE)
    _percent_pat  = re.compile(r"%\s*\d+")

    # ----- yardımcılar -----
    def _get_txt(obj: Any) -> str:
        for k in ("txt","text","string"):
            if hasattr(obj, k):
                return str(getattr(obj, k) or "")
        if isinstance(obj, (tuple, list)) and len(obj) >= 5:
            return str(obj[4] or "")
        return ""  # koordinatlar metin sanılmasın

    def _to_box(obj: Any) -> Optional[Box]:
        if isinstance(obj, Box): return obj
        if isinstance(obj, (tuple, list)) and len(obj) >= 4:
            return Box(int(obj[0]), int(obj[1]), int(obj[2]), int(obj[3]), _get_txt(obj))
        if all(hasattr(obj, k) for k in ("x","y","w","h")):
            return Box(int(obj.x), int(obj.y), int(obj.w), int(obj.h), _get_txt(obj))
        return None

    def _xyxy(b: Box) -> Tuple[int,int,int,int]: return b.x, b.y, b.x+b.w, b.y+b.h
    def _overlap_1d(a1,a2,b1,b2): return max(0, min(a2,b2)-max(a1,b1))
    def _v_overlap_ratio(a: Box,b: Box) -> float:
        return _overlap_1d(a.y,a.y+a.h,b.y,b.y+b.h)/max(1,min(a.h,b.h))
    def _h_overlap_ratio(a: Box,b: Box) -> float:
        return _overlap_1d(a.x,a.x+a.w,b.x,b.x+b.w)/max(1,min(a.w,b.w))
    def _gap_right(a: Box,b: Box) -> int: return b.x-(a.x+a.w)
    def _gap_down(a: Box,b: Box) -> int:  return b.y-(a.y+a.h)

    def _merge(a: Box,b: Box) -> Box:
        ax1,ay1,ax2,ay2=_xyxy(a); bx1,by1,bx2,by2=_xyxy(b)
        nx1,ny1,nx2,ny2=min(ax1,bx1),min(ay1,by1),max(ax2,bx2),max(ay2,by2)
        return Box(nx1,ny1,nx2-nx1,ny2-ny1,(a.txt+" "+b.txt).strip(), a.role or b.role)

    def has_number(s: str) -> bool: return bool(_num_pat.search(s or ""))

    def amount_score(s: str) -> float:
        sc=0.0
        if _amount_pat.search(s): sc+=2.0
        if _currency_pat.search(s): sc+=2.0
        if _percent_pat.search(s): sc-=1.5
        sc+=min(1.0, sum(c.isdigit() for c in (s or ""))/8.0)
        return sc

    def contains_amount(s: str, thr: float = 2.0) -> bool:
        return amount_score(s) >= thr

    # ----- 1) Havuzu sırayı koruyarak oluştur -----
    raw_list = list(all_boxes)                      # indis korunsun
    pool = [_to_box(b) for b in raw_list]
    pool = [b for b in pool if b is not None]

    # ----- 2) İndis bazlı harita (location -> text) -----
    index_pair_mode = bool(ocr_texts) and all(isinstance(t, str) for t in ocr_texts)
    text_by_loc = {}
    if index_pair_mode:
        N = min(len(pool), len(ocr_texts))
        for i in range(N):
            b = pool[i]
            t = (ocr_texts[i] or "").strip()
            if t:
                text_by_loc[(b.x, b.y, b.w, b.h)] = t
        if dbg:
            print(f"[INDEX-PAIR] mapped {len(text_by_loc)}/{len(pool)} boxes by index.")
    else:
        # koordinatlı OCR kutuları varsa ileride IOU ile kullanılacak
        pass

    # ----- 3) Koordinatlı OCR havuzu (varsa) -----
    ocr_pool: List[Box] = []
    if ocr_texts and not index_pair_mode:
        tmp = [_to_box(t) for t in ocr_texts]
        ocr_pool = [b for b in tmp if b and b.txt]

    # ----- 4) Metni enjekte et: önce index-map, sonra IOU fallback -----
    def _ensure_text(b: Box) -> Box:
        if not b.txt:
            key = (b.x, b.y, b.w, b.h)
            if key in text_by_loc:
                txt = text_by_loc[key]
                if dbg: print(f"[INJECT-INDEX] ({key}) -> '{txt[:50]}'")
                return Box(b.x,b.y,b.w,b.h,txt,b.role)
        # IOU fallback (yalnızca koordinatlı OCR varsa)
        if not b.txt and ocr_pool:
            bx1,by1,bx2,by2=_xyxy(b)
            best = None
            best_iou = 0.0
            for tb in ocr_pool:
                tx1,ty1,tx2,ty2=_xyxy(tb)
                ix=_overlap_1d(bx1,bx2,tx1,tx2); iy=_overlap_1d(by1,by2,ty1,ty2)
                inter = ix*iy
                if inter<=0: 
                    continue
                area = b.w*b.h + tb.w*tb.h - inter
                iou = inter/max(1,area)
                if iou > best_iou:
                    best_iou = iou; best = tb
            if best:
                if dbg: print(f"[INJECT-IOU] iou={best_iou:.2f} txt='{best.txt[:50]}'")
                return Box(b.x,b.y,b.w,b.h,(b.txt+" "+best.txt).strip(), b.role)
        return b

    # ----- 5) Komşu seçiciler -----
    def _best_right_neighbor(cur: Box, candidates: List[Box]) -> Optional[Box]:
        cand=[]
        for b in candidates:
            if b.x <= cur.x+cur.w:
                continue
            vovl=_v_overlap_ratio(cur,b); gap=_gap_right(cur,b)
            if vovl<v_min or gap<0 or gap>gap_right_max:
                if dbg: print(f"[RIGHT-REJECT] gap={gap} vovl={vovl:.2f}")
                continue
            bx=_ensure_text(b)
            cand.append((gap, -vovl, -amount_score(bx.txt), bx))
        if cand:
            cand.sort()
            if dbg: 
                g,ov,ns,bb=cand[0]
                print(f"[RIGHT-PICK] gap={g} vovl={-ov:.2f} txt='{bb.txt[:60]}'")
            return cand[0][-1]
        if allow_right_fallback:
            fb=[]
            for b in candidates:
                if b.x <= cur.x+cur.w: 
                    continue
                gap=_gap_right(cur,b)
                if gap<0 or gap>gap_right_max: 
                    continue
                fb.append((gap,b))
            if fb:
                fb.sort()
                b=fb[0][1]
                b=_ensure_text(b)
                if dbg: print(f"[RIGHT-FALLBACK] gap={fb[0][0]} txt='{b.txt[:60]}'")
                return b
        return None

    def _best_down_neighbor(cur: Box, candidates: List[Box]) -> Optional[Box]:
        cand=[]
        for b in candidates:
            if b.y <= cur.y+cur.h:
                continue
            hovl=_h_overlap_ratio(cur,b); gap=_gap_down(cur,b)
            if hovl<h_min or gap<0 or gap>gap_down_max:
                if dbg: print(f"[DOWN-REJECT] gap={gap} hovl={hovl:.2f}")
                continue
            bx=_ensure_text(b)
            cand.append((gap, -hovl, -amount_score(bx.txt), bx))
        if not cand:
            return None
        cand.sort()
        if dbg:
            g,ov,ns,bb=cand[0]
            print(f"[DOWN-PICK] gap={g} hovl={-ov:.2f} txt='{bb.txt[:60]}'")
        return cand[0][-1]

    # ----- 6) Tekrarlı kutuları at -----
    uniq={(b.x,b.y,b.w,b.h,b.txt):b for b in pool}
    pool=list(uniq.values())

    # ----- 7) Ana döngü -----
    out=[]
    for s in sermaye_boxes:
        base=_to_box(s)
        if not base: 
            continue
        base=_ensure_text(base)

        if contains_amount(base.txt):
            out.append(base)
            if dbg: print("[SERMAYE] already has amount ::", base.txt[:120])
            continue

        cur=base; used=set()

        # RIGHT zinciri
        steps=0
        while not contains_amount(cur.txt) and steps<max_steps_right:
            nb=_best_right_neighbor(cur, [b for b in pool if (b.x,b.y,b.w,b.h) not in used])
            if not nb:
                break
            if dbg: print(f"[EXPAND] RIGHT -> '{nb.txt[:80]}'")
            used.add((nb.x,nb.y,nb.w,nb.h))
            cur=_ensure_text(_merge(cur,nb))
            steps+=1

        if contains_amount(cur.txt):
            if dbg: print("[EXPAND] success via RIGHT chain")
            out.append(cur)
            continue

        # DOWN zinciri
        steps=0
        while not contains_amount(cur.txt) and steps<max_steps_down:
            nb=_best_down_neighbor(cur, [b for b in pool if (b.x,b.y,b.w,b.h) not in used])
            if not nb:
                break
            if dbg: print(f"[EXPAND] DOWN -> '{nb.txt[:80]}'")
            used.add((nb.x,nb.y,nb.w,nb.h))
            cur=_ensure_text(_merge(cur,nb))
            steps+=1

        if contains_amount(cur.txt):
            if dbg: print("[EXPAND] success via DOWN chain")
            out.append(cur)
        else:
            if dbg: print("[EXPAND] DROP (no amount) ::", base.txt[:120])
            if keep_all_numbered or has_number(base.txt):
                out.append(base)

    return out