from typing import Any, List, Tuple, Optional

def link_and_build_final(
    role_blocks: List[Any],
    sig_boxes: List[Any],
    sermaye_boxes: Optional[List[Any]] = None,
    *,
    near_px: int = 3,            # "yakınsa birleştir" eşiği (rol∪imza union yapılırken kullanılır)
    band_pad_scale: float = 0.35, # dikey bant genişliği: rol yüksekliğinin şu oranı
    band_center_scale: float = 1.0, # merkez ofset toleransı
    corridor_pad_px: int = 8,     # dikey koridora sağ/sol pay
    forbid_crossing: bool = True, # koridor başka kutuya çarpıyorsa o eşleşmeyi iptal et
    dbg: bool = False
):
    """
    Girdi kutu formatı esnek: (x,y,w,h) | (l,t,r,b) | .rect/.bbox attr'lı objeler.
    Çıktı: dict(keys: pairs, final, roles, sigs, sermaye)
    """
    # ---------- Helpers ----------
    Box = Tuple[int,int,int,int]  # (l,t,r,b)

    def _as_int(v): return int(round(float(v)))

    def _to_ltrb(b: Any) -> Box:
        # tuple/list (x,y,w,h) veya (l,t,r,b)
        if hasattr(b, "rect"):
            x,y,w,h = b.rect
            return (_as_int(x), _as_int(y), _as_int(x+w), _as_int(y+h))
        if hasattr(b, "bbox"):
            bb = b.bbox
            if len(bb) == 4:
                # hem (x,y,w,h) hem (l,t,r,b) olabilir; karar ver
                x,y,z,w = map(_as_int, bb)
                # w/h negatif olmayacağı varsayımıyla sez: (l,t,r,b) ise r>l & b>t zaten sağlanır
                if z > x and w > y:
                    # bu (l,t,r,b) de olabilir; ama (x,y,w,h) de olabilir. Heuristik:
                    # genişlik/yükseklik gibi görünen son iki değeri r/b'ye dönüştürelim.
                    # Eğer (x,y,w,h) ise w/h genelde küçük olur; (l,t,r,b) ise r,b çok büyük olabilir.
                    # Deterministik yapmak için "genişlik/yükseklik" yorumlamayı deneyelim:
                    if (z - x) <= 0 or (w - y) <= 0:  # güvenlik
                        return (x,y,z,w)
                    # İki yorumu da geçerli; tercih: eğer (z<=x or w<=y) değilse ve
                    # (z-x, w-y) tipik w,h aralığında: yine de (l,t,r,b) kabul et
                    # Basit ve sağlam: önce (l,t,r,b) olarak dene
                    return (x,y,z,w)
            # dizi/tuple değilse aşağı devam
        if isinstance(b, (tuple, list)) and len(b) == 4:
            a,b2,c,d = b
            a,b2,c,d = map(_as_int, (a,b2,c,d))
            # (x,y,w,h) mi?
            if c >= 0 and d >= 0 and (a <= c and b2 <= d) and (c - a) < 50000 and (d - b2) < 50000:
                # karışmasın diye, ikisini de normalize et
                # Eğer (l,t,r,b) verildiyse w/h negatif çıkar; o zaman aşağıdaki clamp düzeltir.
                pass
            # Heuristik: (x,y,w,h) ise r=a+c, b=b2+d yap
            if (a <= c and b2 <= d) and (c - a) > 0 and (d - b2) > 0:
                # bu haliyle (l,t,r,b) olabilir; yine de emin olmak için iki yorum:
                # 1) (l,t,r,b) olarak geç
                # 2) Eğer "c-a" veya "d-b2" çok küçükse (x,y,w,h) olabilir
                # Basitleştirelim: önce (x,y,w,h) kabul et, r/b'yi hesapla; eğer r<b gibi saçma olursa (l,t,r,b) kal.
                x,y,w,h = a,b2,c,d
                r,b3 = x+w, y+h
                if r > x and b3 > y:
                    return (x,y,r,b3)
                else:
                    return (a,b2,c,d)
        # Objede named attr
        for names in (("left","top","right","bottom"), ("l","t","r","b")):
            if all(hasattr(b, n) for n in names):
                l,t,r,b3 = (getattr(b, n) for n in names)
                return (_as_int(l), _as_int(t), _as_int(r), _as_int(b3))
        # Son çare: .x,.y,.w,.h
        if all(hasattr(b, n) for n in ("x","y","w","h")):
            x,y,w,h = b.x,b.y,b.w,b.h
            return (_as_int(x), _as_int(y), _as_int(x+w), _as_int(y+h))
        raise TypeError(f"Desteklenmeyen box tipi: {type(b)}")

    def _to_xywh(bb: Box) -> Tuple[int,int,int,int]:
        l,t,r,b = bb
        return (l,t, max(0, r-l), max(0, b-t))

    def _union(a: Box, b: Box) -> Box:
        return (min(a[0],b[0]), min(a[1],b[1]), max(a[2],b[2]), max(a[3],b[3]))

    def _expand(bb: Box, pad: int) -> Box:
        l,t,r,b = bb
        return (l-pad, t-pad, r+pad, b+pad)

    def _intersects(a: Box, b: Box) -> bool:
        return not (a[2] < b[0] or b[2] < a[0] or a[3] < b[1] or b[3] < a[1])

    def _center(bb: Box) -> Tuple[float,float]:
        l,t,r,b = bb
        return ((l+r)/2.0, (t+b)/2.0)

    # ---------- Normalize inputs ----------
    roles_ltrb = [_to_ltrb(b) for b in role_blocks]
    sigs_ltrb  = [_to_ltrb(b) for b in sig_boxes]
    sermaye_ltrb = [_to_ltrb(b) for b in (sermaye_boxes or [])]

    # ---------- Pairing (dikey bant + koridor) ----------
    used_roles = set()
    used_sigs  = set()
    pairs: List[Tuple[int,int]] = []

    # Sig kutularını olası yakın birleşim ile hafifçe büyüt (near_px)
    if near_px > 0:
        sigs_grown = [_expand(s, near_px) for s in sigs_ltrb]
    else:
        sigs_grown = list(sigs_ltrb)

    for ri, rb in enumerate(roles_ltrb):
        if ri in used_roles: 
            continue
        rl,rt,rr,rbottom = rb
        rh = rbottom - rt
        # rol merkezine göre dikey bant
        rcx, rcy = _center(rb)
        band_top = int(rcy - (rh*band_pad_scale))
        band_bot = int(rcy + (rh*band_pad_scale))
        band_l   = int(rl - (rr-rl)*band_center_scale)
        band_r   = int(rr + (rr-rl)*band_center_scale)
        band = (band_l, band_top, band_r, band_bot)

        best = None  # (score, si)
        for si, sb in enumerate(sigs_grown):
            if si in used_sigs:
                continue
            # sadece dikey hizalı/aynı bantta olanlar
            if not _intersects(band, sb):
                continue

            # İsteğe bağlı: koridor kontrolü (rol.bottom → sig.top arası dikey dikdörtgen)
            blocked = False
            if forbid_crossing:
                sl,st,sr,sbtt = sigs_ltrb[si]
                # koridoru oluştur
                cl = min(rl, sl) - corridor_pad_px
                cr = max(rr, sr) + corridor_pad_px
                ct = min(rbottom, st)
                cb = max(rbottom, st)
                corridor = (cl, ct, cr, cb)
                # diğer kutularla çarpışma testi
                for oj, ob in enumerate(roles_ltrb):
                    if oj == ri: 
                        continue
                    if _intersects(corridor, ob):
                        blocked = True
                        break
                if not blocked:
                    for oj, ob in enumerate(sigs_ltrb):
                        if oj == si: 
                            continue
                        if _intersects(corridor, ob):
                            blocked = True
                            break
            if blocked:
                if dbg: 
                    print(f"[SKIP] ri={ri} si={si} -> corridor blocked")
                continue

            # basit skor: merkez mesafesi (yakın olan daha iyi)
            scx, scy = _center(sigs_ltrb[si])
            gap = abs(scy - rcy) + 1e-6
            score = 1.0 / gap
            if (best is None) or (score > best[0]):
                best = (score, si)

        if best is not None:
            si = best[1]
            pairs.append((ri, si))
            used_roles.add(ri)
            used_sigs.add(si)

    # ---------- Final kutuları oluştur (rol ∪ imza) ----------
    final_boxes_ltrb: List[Box] = []
    for ri, si in pairs:
        u = _union(roles_ltrb[ri], sigs_ltrb[si])
        final_boxes_ltrb.append(u)

    # ---------- Sonuç ----------
    result = {
        "pairs": pairs,
        "final": [_to_xywh(bb) for bb in final_boxes_ltrb],
        "roles": [_to_xywh(bb) for bb in roles_ltrb],
        "sigs":  [_to_xywh(bb) for bb in sigs_ltrb],
        "sermaye": [_to_xywh(bb) for bb in sermaye_ltrb],
    }
    return result