import re, copy, unicodedata
from typing import List, Any, Tuple, Optional

def split_roles_in_role_blocks(
    role_blocks: List[Any],
    *,
    ROLE_ALIASES: Optional[dict] = None,
    ROLE_WORDS: Optional[List[str]] = None,
) -> List[Any]:
    """
    Input : role_blocks -> (x,y,w,h,txt[,role]) alanlarına sahip kutular listesi (obj veya dict)
    Output: role_blocks -> Çoklu rol içeren kutular ayrılmış halde döner.

    Davranış:
      - Aynı kutuda 2+ rol başlığı yakalanırsa, rol başlıklarının yatay merkezlerinin
        ortasına kesim çizgileri koyar ve N parçaya böler.
      - Rol başlıkları regex ile alias’lı ve aksansız/harf normalizasyonlu aranır.
      - Yine de 1 rol yakalandıysa fakat metin iki farklı rol ailesinden ipucu içeriyorsa,
        güvenli yedek olarak kutuyu tam geometrik ortadan ikiye böler.
      - Her parçanın role alanı, parçadaki ilk rol başlığıdır (yoksa None).
    """

    # ---------- yardımcılar ----------
    def tr_upper(s: str) -> str:
        return (s or "").replace("i","İ").replace("ı","I").upper()

    def strip_diac(s: str) -> str:
        return "".join(c for c in unicodedata.normalize("NFKD", s) if not unicodedata.combining(c))

    def canon_text(s: str) -> str:
        # Türkçe büyük + aksansız + sade boşluk
        s2 = tr_upper(strip_diac(s))
        s2 = re.sub(r"\s+", " ", s2).strip()
        return s2

    def getf(b, k, default=None):
        if isinstance(b, dict): return b.get(k, default)
        return getattr(b, k, default)

    def setf(b, k, v):
        if isinstance(b, dict): b[k] = v
        else: setattr(b, k, v)

    def new_like(b):
        return dict(b) if isinstance(b, dict) else copy.deepcopy(b)

    def xyxy(b) -> Tuple[int,int,int,int]:
        x, y, w, h = int(getf(b,"x")), int(getf(b,"y")), int(getf(b,"w")), int(getf(b,"h"))
        return x, y, x+w, y+h

    # ---------- rol sözlüğü ----------
    if ROLE_ALIASES is None:
        ROLE_ALIASES = {
            "toplanti_baskani": ["TOPLANTI BAŞKANI","TOPLANTI BASKANI","TOPLANTI BAŞI"],
            "tutanak_yazmani":  ["TUTANAK YAZMANI","YAZMAN"],
            "bakanlik_temsilcisi":["BAKANLIK TEMSİLCİSİ","TİCARET BAKANLIĞI TEMSİLCİSİ","TICARET BAKANLIGI TEMSILCISI"],
            "yk_baskani":       ["YÖNETİM KURULU BAŞKANI","YONETIM KURULU BASKANI","YK BAŞKANI","YK BASKANI"],
            "yk_uyesi":         ["YÖNETİM KURULU ÜYESİ","YONETIM KURULU UYESI","YK ÜYESİ","YK UYESI","YÖNETİM KURULU ÜYELERİ"],
            "katip":            ["KATİP","KATIP","OY TOPLAMA MEMURU","OY TOPLAYICI"],
            "divan_baskani":    ["DİVAN BAŞKANI","DIVAN BAŞKANI","DIVAN BASKANI"],
        }

    if ROLE_WORDS is None:
        ROLE_WORDS = sorted({w for lst in ROLE_ALIASES.values() for w in lst}, key=len, reverse=True)

    # normalize edilmiş (aksansız) arama için pattern oluştur
    def make_role_regex(words: List[str]) -> re.Pattern:
        # boşlukları \s+ ile esnek yakala, aksansız eşle
        pats = []
        for w in words:
            w0 = canon_text(w)
            w0 = re.sub(r"\s+", r"\\s+", w0)  # space tolerant
            pats.append(w0)
        return re.compile(r"\b(" + "|".join(pats) + r")\b", re.U)

    ROLE_PAT = make_role_regex(ROLE_WORDS)

    # span -> kutu x pikseli haritalama (metin indexi -> piksel)
    def char_to_x(idx: float, x:int, x2:int, L:int) -> int:
        if L <= 0 or x2 <= x: return x
        r = max(0.0, min(1.0, idx / L))
        return int(round(x + r * (x2 - x)))

    def extract_role_spans(text: str):
        t = canon_text(text)
        return [ {"text": m.group(0), "span": m.span()} for m in ROLE_PAT.finditer(t) ]

    def compute_split_boundaries(b, spans):
        if len(spans) < 2: return []
        x, y, x2, y2 = xyxy(b)
        t = canon_text(getf(b,"txt") or "")
        L = len(t)
        centers = []
        for s in spans:
            a, b_ = s["span"]
            c = 0.5*(a+b_)
            centers.append(char_to_x(c, x, x2, L))
        centers.sort()
        splits = []
        for i in range(len(centers)-1):
            sx = (centers[i] + centers[i+1]) // 2
            if x < sx < x2:
                splits.append(sx)
        return sorted(set(splits))

    # ipucu tabanlı güvenli yedek: iki farklı aile adı geçti mi?
    ROLE_FAMILIES = {
        "BASKAN": ["BAŞKAN","BASKAN"],
        "MEMUR":  ["MEMURU","MEMUR","TOPLAYICI"],
        "UYE":    ["ÜYESİ","UYESI","ÜYELERİ","UYELERI","ÜYE","UYE"],
        "YAZMAN": ["YAZMAN","TUTANAK"],
    }
    FAMILY_PAT = re.compile("|".join([canon_text(w) for vals in ROLE_FAMILIES.values() for w in vals]), re.U)

    def has_two_families(text: str) -> bool:
        t = canon_text(text)
        hits = set()
        for fam, vals in ROLE_FAMILIES.items():
            for v in vals:
                if canon_text(v) in t:
                    hits.add(fam); break
        return len(hits) >= 2

    # ---------- ana akış ----------
    out: List[Any] = []
    for b in role_blocks:
        txt_raw = getf(b,"txt") or ""
        spans = extract_role_spans(txt_raw)

        # yalnız tek rol -> normalize edip bırak
        if len(spans) <= 1:
            nb = new_like(b)
            if spans:
                setf(nb, "role", spans[0]["text"])
            out.append(nb)
            continue

        # 2+ rol: doğru yerden böl
        x, y, x2, y2 = xyxy(b)
        t_norm = canon_text(txt_raw)
        L = len(t_norm)

        split_xs = compute_split_boundaries(b, spans)
        # emniyet: regex merkezleri çok yakınsa / boşsa, kutu ortadan böl
        if not split_xs or any(j-i < 8 for i,j in zip(split_xs[:-1], split_xs[1:])):
            # alternatif: iki farklı aile ipucu varsa da ortadan böl
            if has_two_families(txt_raw):
                split_xs = [(x + x2)//2]

        cuts_px = [x] + split_xs + [x2]

        def x_to_char(px:int) -> int:
            if x2 <= x: return 0
            r = (px - x) / (x2 - x)
            return max(0, min(L, int(round(r * L))))
        cuts_ch = [0] + [x_to_char(px) for px in split_xs] + [L]

        for i in range(len(cuts_px)-1):
            px1, px2 = cuts_px[i], cuts_px[i+1]
            cx1, cx2 = cuts_ch[i], cuts_ch[i+1]
            piece_txt = (getf(b,"txt") or "")[cx1:cx2].strip()

            p_spans = extract_role_spans(piece_txt)
            piece_role = p_spans[0]["text"] if p_spans else None

            nb = new_like(b)
            setf(nb, "x", px1); setf(nb, "y", y)
            setf(nb, "w", max(1, px2 - px1)); setf(nb, "h", y2 - y)
            setf(nb, "txt", piece_txt); setf(nb, "role", piece_role)
            out.append(nb)

    return out