from typing import List, Tuple, Optional

BoxXYWH = Tuple[int,int,int,int]
BoxLTRB = Tuple[int,int,int,int]

def build_final_boxes_all(
    role_blocks: List[BoxXYWH],
    sig_boxes: List[BoxXYWH],
    sermaye_boxes: Optional[List[BoxXYWH]] = None,
    *,
    near_px: int = 3,               # temas/≤near_px yakın say
    band_pad_scale: float = 0.35,   # rol yüksekliğinin oranı kadar dikey bant
    band_center_scale: float = 1.0, # bandın yatay toleransı
    corridor_pad_px: int = 8,       # koridor yan payı
    forbid_crossing: bool = True,   # koridor çarpışırsa eşleşmeyi iptal et
    include_unpaired_roles: bool = True,
    include_unpaired_sigs: bool = True,
    dedup_iou: float = 0.90,        # final setinde neredeyse aynı kutuları tekilleştir
    dbg: bool = False
):
    """
    role_blocks, sig_boxes, sermaye_boxes -> (x,y,w,h) kutular.
    Döner: dict {"final","pairs","roles","sigs","sermaye"}

    'final' = birleştirilmiş EŞLEŞMELER  + sermaye  + (opsiyonel) eşleşmeyen rol/sig.
    """
    # ------------- helpers -------------
    def to_ltrb(b: BoxXYWH) -> BoxLTRB:
        x,y,w,h = b
        return (int(x), int(y), int(x+w), int(y+h))

    def to_xywh(bb: BoxLTRB) -> BoxXYWH:
        l,t,r,b = bb
        return (int(l), int(t), int(max(0, r-l)), int(max(0, b-t)))

    def union(a: BoxLTRB, b: BoxLTRB) -> BoxLTRB:
        return (min(a[0],b[0]), min(a[1],b[1]), max(a[2],b[2]), max(a[3],b[3]))

    def expand(bb: BoxLTRB, pad: int) -> BoxLTRB:
        l,t,r,b = bb
        return (l-pad, t-pad, r+pad, b+pad)

    def intersects(a: BoxLTRB, b: BoxLTRB) -> bool:
        return not (a[2] < b[0] or b[2] < a[0] or a[3] < b[1] or b[3] < a[1])

    def center(bb: BoxLTRB) -> Tuple[float,float]:
        l,t,r,b = bb
        return ((l+r)/2.0, (t+b)/2.0)

    def area(bb: BoxLTRB) -> int:
        l,t,r,b = bb
        return max(0, r-l) * max(0, b-t)

    def iou(a: BoxLTRB, b: BoxLTRB) -> float:
        if not intersects(a,b):
            return 0.0
        l = max(a[0], b[0]); t = max(a[1], b[1])
        r = min(a[2], b[2]); btm = min(a[3], b[3])
        inter = max(0, r-l) * max(0, btm-t)
        if inter <= 0:
            return 0.0
        return inter / float(area(a) + area(b) - inter + 1e-6)

    def dedup_merge_close(boxes_xywh: List[BoxXYWH]) -> List[BoxXYWH]:
        """Yakın (≤near_px) ya da IoU≥dedup_iou olanları tekilleştir."""
        rects = [to_ltrb(b) for b in boxes_xywh]
        changed = True
        while changed:
            changed = False
            rects.sort(key=lambda r: (r[0], r[1], r[2]-r[0], r[3]-r[1]))
            used = [False]*len(rects)
            merged: List[BoxLTRB] = []
            for i in range(len(rects)):
                if used[i]: 
                    continue
                cur = rects[i]
                used[i] = True
                j = 0
                while j < len(rects):
                    if not used[j]:
                        a = expand(cur, near_px)
                        b = expand(rects[j], near_px)
                        if intersects(a,b) or iou(cur, rects[j]) >= dedup_iou:
                            cur = union(cur, rects[j])
                            used[j] = True
                            changed = True
                            j = 0
                            continue
                    j += 1
                merged.append(cur)
            rects = merged
        return [to_xywh(r) for r in rects]

    # ------------- normalize inputs -------------
    roles_ltrb   = [to_ltrb(b) for b in role_blocks]
    sigs_ltrb    = [to_ltrb(b) for b in sig_boxes]
    sermaye_ltrb = [to_ltrb(b) for b in (sermaye_boxes or [])]

    # ------------- pairing (role ↔ sig) -------------
    if near_px > 0:
        sigs_grown = [expand(s, near_px) for s in sigs_ltrb]
    else:
        sigs_grown = list(sigs_ltrb)

    used_roles, used_sigs = set(), set()
    pairs: List[Tuple[int,int]] = []

    for ri, rb in enumerate(roles_ltrb):
        if ri in used_roles:
            continue
        rl,rt,rr,rbottom = rb
        rh = rbottom - rt
        rcx, rcy = center(rb)

        # dikey bant
        band_top = int(rcy - rh * band_pad_scale)
        band_bot = int(rcy + rh * band_pad_scale)
        band_l   = int(rl - (rr-rl) * band_center_scale)
        band_r   = int(rr + (rr-rl) * band_center_scale)
        band = (band_l, band_top, band_r, band_bot)

        best = None  # (score, si)
        for si, sb in enumerate(sigs_grown):
            if si in used_sigs:
                continue
            if not intersects(band, sb):
                continue

            # koridor kontrolü (rol.bottom ↔ sig.top)
            blocked = False
            if forbid_crossing:
                sl,st,sr,sbtt = sigs_ltrb[si]
                cl = min(rl, sl) - corridor_pad_px
                cr = max(rr, sr) + corridor_pad_px
                ct = min(rbottom, st)
                cb = max(rbottom, st)
                corridor = (cl, ct, cr, cb)
                # diğer roller
                for rj, ob in enumerate(roles_ltrb):
                    if rj == ri: 
                        continue
                    if intersects(corridor, ob):
                        blocked = True
                        break
                # diğer imzalar
                if not blocked:
                    for sj, ob in enumerate(sigs_ltrb):
                        if sj == si: 
                            continue
                        if intersects(corridor, ob):
                            blocked = True
                            break
            if blocked:
                if dbg: 
                    print(f"[SKIP] ri={ri} si={si} -> corridor blocked")
                continue

            # skor: dikey merkez mesafesi (küçük daha iyi)
            _, scy = center(sigs_ltrb[si])
            gap = abs(scy - rcy) + 1e-6
            score = 1.0 / gap
            if (best is None) or (score > best[0]):
                best = (score, si)

        if best is not None:
            si = best[1]
            pairs.append((ri, si))
            used_roles.add(ri)
            used_sigs.add(si)

    # ------------- compose final set -------------
    final_ltrb: List[BoxLTRB] = []

    # 1) eşleşen rol∪imza
    for ri, si in pairs:
        final_ltrb.append(union(roles_ltrb[ri], sigs_ltrb[si]))

    # 2) sermaye kutularını doğrudan ekle
    final_ltrb.extend(sermaye_ltrb)

    # 3) isteğe bağlı: eşleşmemiş rol/sig kutuları
    if include_unpaired_roles:
        for ri, rb in enumerate(roles_ltrb):
            if ri not in used_roles:
                final_ltrb.append(rb)
    if include_unpaired_sigs:
        for si, sb in enumerate(sigs_ltrb):
            if si not in used_sigs:
                final_ltrb.append(sb)

    # 4) dedup / yakın olanları birleştir
    final_xywh = dedup_merge_close([to_xywh(bb) for bb in final_ltrb])

    return {
        "final": final_xywh,                         # hepsi bir arada
        "pairs": pairs,
        "roles": [to_xywh(b) for b in roles_ltrb],
        "sigs":  [to_xywh(b) for b in sigs_ltrb],
        "sermaye": [to_xywh(b) for b in sermaye_ltrb],
    }