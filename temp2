from difflib import SequenceMatcher
from typing import List, Dict, Any, Tuple
import numpy as np


def mark_signatures_on_imza_column(
    table_dfs: List["pd.DataFrame"],
    page_cells_all: List[List[Dict[str, Any]]],
    sig_boxes: List[Dict[str, Any]],
    signature_header_target: str = "IMZA",   # veya "İMZA"
    sig_cover_threshold: float = 0.25,       # imzanın en az %25’i hücre içinde olsun
    iou_threshold: float = 0.01,             # çok düşük yedek eşik
    fuzzy_min_score: float = 0.7,
):
    """
    table_dfs      : list[pd.DataFrame] -> her sayfanın tablo DataFrame'i
    page_cells_all : list[list[dict]]   -> her sayfa için hücreler (row, col, x, y, w, h)
    sig_boxes      : YOLO imza çıkışları (predict_on_memory_images çıktısı: all_boxes)
    """

    # 1) YOLO çıktısını normalize et: her imza için (page, x_min, y_min, x_max, y_max)
    norm_sigs: List[Dict[str, Any]] = []

    for sb in sig_boxes:
        img_idx = sb.get("image_index", 0)
        boxes = sb.get("boxes", [])

        for b in boxes:
            # b: {"xyxy":[x1,y1,x2,y2], "conf":..., "class_id":...} vb.
            xyxy = (
                b.get("xyxy")
                or b.get("bbox")
                or b.get("xxyy")
                or b
            )
            if xyxy is None or len(xyxy) != 4:
                continue

            x1, y1, x2, y2 = map(float, xyxy)

            norm_sigs.append(
                {
                    "image_index": int(img_idx),
                    "x_min": x1,
                    "y_min": y1,
                    "x_max": x2,
                    "y_max": y2,
                }
            )

    # 2) Overlap ölçüleri: IoU + imzanın / hücrenin kapsanma oranları
    def overlap_measures(cell: Dict[str, Any], sig: Dict[str, Any]) -> Tuple[float, float, float]:
        """
        return (iou, frac_sig, frac_cell)
            iou      : klasik IoU
            frac_sig : imza alanının yüzde kaçı hücre içinde (intersection / area_sig)
            frac_cell: hücre alanının yüzde kaçı overlap (intersection / area_cell)
        """
        xA = max(float(cell["x"]), sig["x_min"])
        yA = max(float(cell["y"]), sig["y_min"])
        xB = min(float(cell["x"]) + float(cell["w"]), sig["x_max"])
        yB = min(float(cell["y"]) + float(cell["h"]), sig["y_max"])

        inter_w = max(0.0, xB - xA)
        inter_h = max(0.0, yB - yA)
        inter_area = inter_w * inter_h

        if inter_area <= 0:
            return 0.0, 0.0, 0.0

        area_cell = float(cell["w"]) * float(cell["h"])
        area_sig = (sig["x_max"] - sig["x_min"]) * (sig["y_max"] - sig["y_min"])
        union_area = area_cell + area_sig - inter_area

        iou = inter_area / union_area if union_area > 0 else 0.0
        frac_sig = inter_area / area_sig if area_sig > 0 else 0.0
        frac_cell = inter_area / area_cell if area_cell > 0 else 0.0

        return iou, frac_sig, frac_cell

    # 3) Kolon adını fuzzy ile bul
    def fuzzy_best_col(columns, target: str):
        best_col = None
        best_score = 0.0
        t = target.upper()

        for col in columns:
            s = SequenceMatcher(None, str(col).upper(), t).ratio()
            if s > best_score:
                best_score = s
                best_col = col
        return best_col, best_score

    # 4) Her sayfa için imza kolonunu 0/1 olarak doldur
    result_dfs: List["pd.DataFrame"] = []

    for page_index, df in enumerate(table_dfs):
        if df is None or df.empty:
            result_dfs.append(df)
            continue

        # "page_index" hariç kolonlar
        data_cols = [c for c in df.columns if c != "page_index"]

        sig_col_name, score = fuzzy_best_col(data_cols, signature_header_target)

        # imza başlığı yoksa dokunma
        if sig_col_name is None or score < fuzzy_min_score:
            result_dfs.append(df)
            continue

        sig_col_pos = data_cols.index(sig_col_name)

        # İMZA kolonunu 0 ile başlat
        df[sig_col_name] = 0

        # Sayfanın hücreleri ve imzaları
        cells = page_cells_all[page_index]
        page_sigs = [s for s in norm_sigs if s["image_index"] == page_index]

        if not cells or not page_sigs:
            result_dfs.append(df)
            continue

        # Sadece imza kolonundaki hücreler
        imza_cells = [c for c in cells if c["col"] == sig_col_pos]
        if not imza_cells:
            result_dfs.append(df)
            continue

        # Her imza için EN İYİ hücreyi ata
        for sig in page_sigs:
            sx_center = 0.5 * (sig["x_min"] + sig["x_max"])
            sy_center = 0.5 * (sig["y_min"] + sig["y_max"])

            best_cell = None
            best_score = -1.0
            best_measures = (0.0, 0.0, 0.0)

            for cell in imza_cells:
                iou, frac_sig, frac_cell = overlap_measures(cell, sig)

                # imzanın orta noktası bu hücrenin içinde mi?
                cx_min = float(cell["x"])
                cy_min = float(cell["y"])
                cx_max = cx_min + float(cell["w"])
                cy_max = cy_min + float(cell["h"])

                center_inside = (
                    (sx_center >= cx_min)
                    and (sx_center <= cx_max)
                    and (sy_center >= cy_min)
                    and (sy_center <= cy_max)
                )

                # skor: merkez içindeyse +1; değilse sadece frac_sig
                score_cell = frac_sig
                if center_inside:
                    score_cell += 1.0

                if score_cell > best_score:
                    best_score = score_cell
                    best_cell = cell
                    best_measures = (iou, frac_sig, frac_cell)

            if best_cell is None:
                continue

            iou, frac_sig, frac_cell = best_measures
            # Kabul koşulu:
            #  - merkez hücre içindeyse (score >= 1.0), veya
            #  - imzanın en az sig_cover_threshold kadarı hücre içinde, veya
            #  - IoU yeterli
            if (best_score >= 1.0) or (frac_sig >= sig_cover_threshold) or (iou >= iou_threshold):
                row_idx = best_cell["row"]
                if row_idx in df.index:
                    df.at[row_idx, sig_col_name] = 1

        result_dfs.append(df)

    return result_dfs

table_dfs_marked = mark_signatures_on_imza_column(
    table_dfs=table_df,
    page_cells_all=page_cells_all,
    sig_boxes=sig_boxes,
    signature_header_target="İMZA",
    sig_cover_threshold=0.25,  # gerekirse 0.2’ye düşürebilirsin
    iou_threshold=0.01,
    fuzzy_min_score=0.7,
)


from difflib import SequenceMatcher
from typing import List, Dict, Any, Tuple
import numpy as np


def mark_signatures_on_imza_column(
    table_dfs: List["pd.DataFrame"],
    page_cells_all: List[List[Dict[str, Any]]],
    sig_boxes: List[Dict[str, Any]],
    signature_header_target: str = "IMZA",   # veya "İMZA"
    sig_cover_threshold: float = 0.4,        # imzanın en az %40'ı hücre içinde olsun
    iou_threshold: float = 0.01,             # çok düşük bırakıyorum, yedek koşul
    fuzzy_min_score: float = 0.7,
):
    """
    table_dfs      : list[pd.DataFrame] -> her sayfanın tablo DataFrame'i
    page_cells_all : list[list[dict]]   -> her sayfa için hücreler (row, col, x, y, w, h)
    sig_boxes      : YOLO imza çıkışları listesi (all_boxes)
    """

    # 1) YOLO çıktısını normalize et: her imza için (page, x_min, y_min, x_max, y_max)
    norm_sigs: List[Dict[str, Any]] = []

    for sb in sig_boxes:
        img_idx = sb.get("image_index", 0)
        boxes = sb.get("boxes", [])

        for b in boxes:
            # b yapısı: {"xyxy":[x1,y1,x2,y2], "conf":..., "class_id":...}
            xyxy = (
                b.get("xyxy")
                or b.get("bbox")
                or b.get("xxyy")
                or b
            )
            if xyxy is None or len(xyxy) != 4:
                continue

            x1, y1, x2, y2 = map(float, xyxy)

            norm_sigs.append(
                {
                    "image_index": int(img_idx),
                    "x_min": x1,
                    "y_min": y1,
                    "x_max": x2,
                    "y_max": y2,
                }
            )

    # 2) Overlap ölçüleri: IoU + imzanın hücre içinde kalan oranı
    def overlap_measures(cell: Dict[str, Any], sig: Dict[str, Any]) -> Tuple[float, float, float]:
        """
        return: (iou, frac_sig, frac_cell)
            iou      : klasik IoU
            frac_sig : imza alanının yüzde kaçı hücre içinde (intersection / area_sig)
            frac_cell: hücre alanının yüzde kaçı overlap (intersection / area_cell)
        """
        xA = max(float(cell["x"]), sig["x_min"])
        yA = max(float(cell["y"]), sig["y_min"])
        xB = min(float(cell["x"]) + float(cell["w"]), sig["x_max"])
        yB = min(float(cell["y"]) + float(cell["h"]), sig["y_max"])

        inter_w = max(0.0, xB - xA)
        inter_h = max(0.0, yB - yA)
        inter_area = inter_w * inter_h

        if inter_area <= 0:
            return 0.0, 0.0, 0.0

        area_cell = float(cell["w"]) * float(cell["h"])
        area_sig = (sig["x_max"] - sig["x_min"]) * (sig["y_max"] - sig["y_min"])
        union_area = area_cell + area_sig - inter_area

        iou = inter_area / union_area if union_area > 0 else 0.0
        frac_sig = inter_area / area_sig if area_sig > 0 else 0.0
        frac_cell = inter_area / area_cell if area_cell > 0 else 0.0

        return iou, frac_sig, frac_cell

    # 3) Kolon adını fuzzy ile bul
    def fuzzy_best_col(columns, target: str):
        best_col = None
        best_score = 0.0
        t = target.upper()

        for col in columns:
            s = SequenceMatcher(None, str(col).upper(), t).ratio()
            if s > best_score:
                best_score = s
                best_col = col
        return best_col, best_score

    # 4) Her sayfa için imza kolonunu 0/1 olarak doldur
    result_dfs: List["pd.DataFrame"] = []

    for page_index, df in enumerate(table_dfs):
        if df is None or df.empty:
            result_dfs.append(df)
            continue

        # "page_index" hariç kolonlar
        data_cols = [c for c in df.columns if c != "page_index"]

        sig_col_name, score = fuzzy_best_col(data_cols, signature_header_target)

        # imza başlığı bulunamadı -> dokunma
        if sig_col_name is None or score < fuzzy_min_score:
            result_dfs.append(df)
            continue

        sig_col_pos = data_cols.index(sig_col_name)

        # İMZA kolonunu 0'la başlat
        df[sig_col_name] = 0

        # İlgili sayfanın hücreleri ve imzaları
        cells = page_cells_all[page_index]
        page_sigs = [s for s in norm_sigs if s["image_index"] == page_index]

        if not cells or not page_sigs:
            result_dfs.append(df)
            continue

        # Sadece imza kolonundaki hücrelere bak
        for cell in cells:
            if cell["col"] != sig_col_pos:
                continue

            # Bu hücre için herhangi bir imza yeterince içeride mi?
            for sig in page_sigs:
                iou, frac_sig, frac_cell = overlap_measures(cell, sig)

                # imzanın belli oranı hücre içinde ise veya IoU yeterliyse işaretle
                if (frac_sig >= sig_cover_threshold) or (iou >= iou_threshold):
                    row_idx = cell["row"]
                    if row_idx in df.index:
                        df.at[row_idx, sig_col_name] = 1
                    break  # aynı hücre için başka imzaya bakmaya gerek yok

        result_dfs.append(df)

    return result_dfs

table_dfs_marked = mark_signatures_on_imza_column(
    table_dfs=table_df,
    page_cells_all=page_cells_all,
    sig_boxes=sig_boxes,
    signature_header_target="İMZA",
    sig_cover_threshold=0.4,   # istersen 0.3–0.5 arasında oynayabilirsin
    iou_threshold=0.01,
    fuzzy_min_score=0.7,
)

for df in table_dfs_marked:
    display(df)


from typing import List, Tuple, Optional
import numpy as np
import cv2


def crop_all_tables_from_doc_images(
    doc_images: List[np.ndarray],
    margin: int = 5,
    strict: bool = False,
    debug: bool = False,
) -> List[np.ndarray]:
    """
    Her sayfa için tablo bbox'ını tespit edip sadece tabloyu crop eder.
    ÇIKTI: [array([[...]], dtype=uint8), ...] şeklinde bir liste.

    Parameters
    ----------
    doc_images : List[np.ndarray]
        Sayfa görüntüleri listesi (BGR, GRAY veya BGRA olabilir).
    margin : int, optional
        Tablo etrafına eklenecek boşluk (px), by default 5.
    strict : bool, optional
        True ise herhangi bir hata durumunda exception fırlatır, by default False.
    debug : bool, optional
        Ara adımları ve uyarıları yazdırmak için, by default False.

    Returns
    -------
    List[np.ndarray]
        Tablonun crop edilmiş görüntüleri listesi.
    """

    # ------------------------------------------------------------------
    # 1) Yardımcı: tablo benzeri en büyük dikdörtgen alanı bul (bbox)
    # ------------------------------------------------------------------
    def detect_table_bbox_from_mask(
        img: np.ndarray, debug: bool = False
    ) -> Optional[Tuple[int, int, int, int]]:
        # Griye çevir
        if img.ndim == 3:
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        else:
            gray = img.copy()

        # Hafif blur
        blur = cv2.GaussianBlur(gray, (3, 3), 0)

        # Binary + invert
        _, bin_img = cv2.threshold(
            blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU
        )
        bin_inv = cv2.bitwise_not(bin_img)

        h, w = bin_inv.shape

        # Yatay + dikey çizgi tespiti
        hx, hy = max(1, w // 100), max(1, h // 100)

        horiz_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (hx, 1))
        vert_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, hy))

        horiz = cv2.morphologyEx(
            bin_inv, cv2.MORPH_OPEN, horiz_kernel, iterations=2
        )
        vert = cv2.morphologyEx(
            bin_inv, cv2.MORPH_OPEN, vert_kernel, iterations=2
        )

        table_mask = cv2.addWeighted(horiz, 0.5, vert, 0.5, 0.0)

        # Kontur bul
        cnts, _ = cv2.findContours(
            table_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
        )
        if not cnts:
            if debug:
                print("[WARN] no_table_found")
            return None

        # En büyük alanlı konturu al
        cnt = max(cnts, key=cv2.contourArea)
        x, y, w, h = cv2.boundingRect(cnt)

        if debug:
            vis = img.copy()
            cv2.rectangle(vis, (x, y), (x + w, y + h), (0, 255, 0), 2)
            cv2.imshow("table_bbox", vis)
            cv2.waitKey(0)
            cv2.destroyAllWindows()

        return x, y, w, h

    # ------------------------------------------------------------------
    # 2) Yardımcı: her görüntüyü BGR formatına çevir
    # ------------------------------------------------------------------
    def _to_bgr(img: np.ndarray) -> np.ndarray:
        if img.ndim == 2:
            return cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
        if img.ndim == 3 and img.shape[2] == 3:
            return img.copy()
        if img.ndim == 3 and img.shape[2] == 4:
            return cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
        raise ValueError(f"Unsupported image shape: {img.shape}")

    # ------------------------------------------------------------------
    # 3) Ana döngü: tüm sayfalarda tabloyu crop et
    # ------------------------------------------------------------------
    table_imgs: List[np.ndarray] = []

    for i, page in enumerate(doc_images):
        try:
            bgr = _to_bgr(page)

            bbox = detect_table_bbox_from_mask(bgr, debug=debug)
            if bbox is None:
                raise RuntimeError(f"No table detected on page {i}")

            x, y, w, h = bbox

            x1 = max(0, x - margin)
            y1 = max(0, y - margin)
            x2 = min(bgr.shape[1], x + w + margin)
            y2 = min(bgr.shape[0], y + h + margin)

            table_img = bgr[y1:y2, x1:x2]

            table_imgs.append(table_img)

            if debug:
                print(f"[page {i}] table crop shape: {table_img.shape}")

        except Exception as e:
            if debug:
                print(f"[page {i}] failed: {e}")
            if strict:
                raise
            table_imgs.append(None)

    return table_imgs

table_imgs = crop_all_tables_from_doc_images(doc_images)

for i in table_imgs:
    print(i)
    plt.figure(figsize=(10, 4))
    plt.imshow(cv2.cvtColor(i, cv2.COLOR_BGR2RGB))
    plt.axis('off')
    plt.show()

from typing import List, Tuple, Optional, Union
import numpy as np
import cv2


def crop_all_tables_from_doc_images(
    doc_images: List[np.ndarray],
    margin: int = 5,
    strict: bool = False,
    debug: bool = False,
    include_bboxes: bool = True,
) -> Union[
    List[np.ndarray],
    Tuple[List[np.ndarray], List[Optional[Tuple[int, int, int, int]]]],
]:
    """
    Her sayfa için tablo bbox'ını tespit edip sadece tabloyu crop eder.

    Parameters
    ----------
    doc_images : List[np.ndarray]
        Sayfa görüntüleri listesi (BGR, GRAY veya BGRA olabilir).
    margin : int, optional
        Tablo etrafına eklenecek boşluk (px), by default 5.
    strict : bool, optional
        True ise herhangi bir hata durumunda exception fırlatır, by default False.
    debug : bool, optional
        Ara adımları ve uyarıları yazdırmak için, by default False.
    include_bboxes : bool, optional
        True ise (table_imgs, bboxes) döner, aksi halde sadece table_imgs.

    Returns
    -------
    List[np.ndarray] veya (List[np.ndarray], List[Optional[Tuple[int,int,int,int]]])
        Tablonun crop edilmiş görüntüleri ve isteğe bağlı bbox listesi.
    """

    # ----------------------------------------------------------------------
    # 1) Yardımcı: tablo benzeri en büyük dikdörtgen alanı bul (bbox)
    # ----------------------------------------------------------------------
    def detect_table_bbox_from_mask(
        img: np.ndarray, debug: bool = False
    ) -> Optional[Tuple[int, int, int, int]]:
        # Griye çevir
        if img.ndim == 3:
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        else:
            gray = img.copy()

        # Hafif blur
        blur = cv2.GaussianBlur(gray, (3, 3), 0)

        # Binary + invert (çizgileri beyaz yapmak için)
        _, bin_img = cv2.threshold(
            blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU
        )
        bin_inv = cv2.bitwise_not(bin_img)

        h, w = bin_inv.shape

        # Yatay + dikey çizgi tespiti
        hx, hy = max(1, w // 100), max(1, h // 100)

        horiz_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (hx, 1))
        vert_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, hy))

        horiz = cv2.morphologyEx(
            bin_inv, cv2.MORPH_OPEN, horiz_kernel, iterations=2
        )
        vert = cv2.morphologyEx(
            bin_inv, cv2.MORPH_OPEN, vert_kernel, iterations=2
        )

        table_mask = cv2.addWeighted(horiz, 0.5, vert, 0.5, 0.0)

        # Kontur bul
        cnts, _ = cv2.findContours(
            table_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
        )
        if not cnts:
            if debug:
                print("[WARN] no_table_found")
            return None

        # En büyük alanlı konturu al
        cnt = max(cnts, key=cv2.contourArea)
        x, y, w, h = cv2.boundingRect(cnt)

        if debug:
            vis = img.copy()
            cv2.rectangle(vis, (x, y), (x + w, y + h), (0, 255, 0), 2)
            cv2.imshow("table_bbox", vis)
            cv2.waitKey(0)
            cv2.destroyAllWindows()

        return x, y, w, h

    # ----------------------------------------------------------------------
    # 2) Yardımcı: her görüntüyü BGR formatına çevir
    # ----------------------------------------------------------------------
    def _to_bgr(img: np.ndarray) -> np.ndarray:
        if img.ndim == 2:
            return cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
        if img.ndim == 3 and img.shape[2] == 3:
            return img.copy()
        if img.ndim == 3 and img.shape[2] == 4:
            return cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
        raise ValueError(f"Unsupported image shape: {img.shape}")

    # ----------------------------------------------------------------------
    # 3) Ana döngü: tüm sayfalarda tabloyu crop et
    # ----------------------------------------------------------------------
    table_imgs: List[np.ndarray] = []
    bboxes: List[Optional[Tuple[int, int, int, int]]] = []

    for i, page in enumerate(doc_images):
        try:
            bgr = _to_bgr(page)

            bbox = detect_table_bbox_from_mask(bgr, debug=debug)
            if bbox is None:
                raise RuntimeError(f"No table detected on page {i}")

            x, y, w, h = bbox

            x1 = max(0, x - margin)
            y1 = max(0, y - margin)
            x2 = min(bgr.shape[1], x + w + margin)
            y2 = min(bgr.shape[0], y + h + margin)

            table_img = bgr[y1:y2, x1:x2]

            table_imgs.append(table_img)
            bboxes.append(bbox)

            if debug:
                print(f"[page {i}] table crop shape: {table_img.shape}")

        except Exception as e:
            if debug:
                print(f"[page {i}] failed: {e}")
            if strict:
                raise
            table_imgs.append(None)
            bboxes.append(None)

    if include_bboxes:
        return table_imgs, bboxes
    return table_imgs

table_imgs = crop_all_tables_from_doc_images(doc_images)