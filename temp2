import re, copy
from typing import List, Any, Tuple, Optional

def separate_multi_role_blocks(
    role_blocks: List[Any],
    *,
    role_words: Optional[List[str]] = None,
    role_aliases: Optional[dict] = None
) -> List[Any]:
    """
    Input : role_blocks -> (x,y,w,h,txt[,role]) alanlarına sahip kutular listesi (dict veya obj)
    Output: role_blocks -> Çoklu rol içeren kutular parçalanmış halde (aynı tipte) döner.

    Kural:
      - Kutu metninde 2+ ROL başlığı yakalanırsa, yakalanan rol başlıklarının
        metin (string) içi pozisyonlarının yatay merkezleri alınır; ardışık merkezlerin
        tam ortaları kesim sınırı olur. Kutu bu sınırlar ile N parçaya bölünür.
      - 'role' alanı her parça için o parçadaki İLK rol başlığıyla set edilir.
      - Tek rol varsa kutu aynen (role alanı normalize edilerek) bırakılır.
    """

    # --- Türkçe büyük harf / normalizasyon yardımcıları (gerekirse sade)
    def tr_upper(s: str) -> str:
        return (s or "").replace("i","İ").replace("ı","I").upper()

    # --- Kullanıcı sözlükleri (varsa) yoksa makul varsayılanlar
    if role_aliases is None:
        role_aliases = {
            "toplanti_baskani": ["TOPLANTI BAŞKANI","TOPLANTI BASKANI","TOPLANTI BAŞI"],
            "tutanak_yazmani":  ["TUTANAK YAZMANI","YAZMAN"],
            "bakanlik_temsilcisi":["BAKANLIK TEMSİLCİSİ","TİCARET BAKANLIĞI TEMSİLCİSİ","TİCARET BAKANLIĞI TEMSİLCİSİ"],
            "yk_baskani":       ["YÖNETİM KURULU BAŞKANI","YÖNETİM KURULU BASKANI","YK BAŞKANI","YK BASKANI"],
            "yk_uyesi":         ["YÖNETİM KURULU ÜYESİ","YONETIM KURULU UYESI","YK ÜYESİ","YK UYESI","YÖNETİM KURULU ÜYELERİ"],
            "katip":            ["KATİP","KATIP","OY TOPLAMA MEMURU","OY TOPLAYICI"],
            "divan_baskani":    ["DİVAN BAŞKANI","DIVAN BAŞKANI","DIVAN BASKANI"],
        }

    if role_words is None:
        # alias’ları düz listeye aç
        role_words = sorted({w for lst in role_aliases.values() for w in lst}, key=len, reverse=True)

    # --- Rol regex’i (tüm varyasyonları yakalar)
    role_pat = re.compile(r"\b(" + "|".join([re.escape(tr_upper(w)) for w in role_words]) + r")\b", re.U)

    # --- Obj/dict alan erişimi
    def getf(b, k, default=None):
        if isinstance(b, dict): return b.get(k, default)
        return getattr(b, k, default)

    def setf(b, k, v):
        if isinstance(b, dict): b[k] = v
        else: setattr(b, k, v)

    def new_like(b):
        return dict(b) if isinstance(b, dict) else copy.deepcopy(b)

    def xyxy(b) -> Tuple[int,int,int,int]:
        x, y, w, h = int(getf(b,"x")), int(getf(b,"y")), int(getf(b,"w")), int(getf(b,"h"))
        return x, y, x+w, y+h

    # --- Metinden rol span’larını çıkar (BÜYÜK harfe çevirerek)
    def extract_role_spans(text: str):
        t = tr_upper(text or "")
        return [ {"text": m.group(0), "span": m.span()} for m in role_pat.finditer(t) ]

    # --- Metin indexini piksel x’e kaba eşle (kutu genişliğine orantı)
    def char_to_x(idx: float, x:int, x2:int, L:int) -> int:
        if L <= 0 or x2 <= x: return x
        r = max(0.0, min(1.0, idx / L))
        return int(round(x + r * (x2 - x)))

    # --- Parçalama sınırlarını üret (merkezlerin ortası)
    def compute_split_boundaries(b, spans):
        if len(spans) < 2: return []
        x, y, x2, y2 = xyxy(b)
        t = tr_upper(getf(b,"txt") or "")
        L = len(t)
        centers = []
        for s in spans:
            a, b_ = s["span"]
            c = 0.5*(a+b_)
            centers.append(char_to_x(c, x, x2, L))
        centers.sort()
        # ardışık merkezlerin ortaları sınırdır
        splits = []
        for i in range(len(centers)-1):
            sx = (centers[i] + centers[i+1]) // 2
            if x < sx < x2:
                splits.append(sx)
        # uniq + sıralı
        return sorted(set(splits))

    # --- Ana akış
    out: List[Any] = []
    for b in role_blocks:
        txt = getf(b,"txt") or ""
        spans = extract_role_spans(txt)

        # Tek ya da hiç rol: dokunma; varsa role alanını normalize et
        if len(spans) <= 1:
            nb = new_like(b)
            if spans:
                setf(nb, "role", spans[0]["text"])
            out.append(nb)
            continue

        # Çoklu rol: N parçaya böl
        x, y, x2, y2 = xyxy(b)
        t_up = tr_upper(txt)
        L = len(t_up)

        split_xs = compute_split_boundaries(b, spans)
        cuts_px = [x] + split_xs + [x2]

        # metni aynı oranda bölmek için px->char index dönüşümü
        def x_to_char(px:int) -> int:
            if x2 <= x: return 0
            r = (px - x) / (x2 - x)
            return max(0, min(L, int(round(r * L))))

        cuts_ch = [0] + [x_to_char(px) for px in split_xs] + [L]

        for i in range(len(cuts_px)-1):
            px1, px2 = cuts_px[i], cuts_px[i+1]
            cx1, cx2 = cuts_ch[i], cuts_ch[i+1]
            piece_txt = (getf(b,"txt") or "")[cx1:cx2].strip()

            # parça içindeki ilk rolü role alanına ata
            p_spans = extract_role_spans(piece_txt)
            piece_role = p_spans[0]["text"] if p_spans else None

            nb = new_like(b)
            setf(nb, "x", px1)
            setf(nb, "y", y)
            setf(nb, "w", max(1, px2 - px1))
            setf(nb, "h", y2 - y)
            setf(nb, "txt", piece_txt)
            setf(nb, "role", piece_role)
            out.append(nb)

    return out