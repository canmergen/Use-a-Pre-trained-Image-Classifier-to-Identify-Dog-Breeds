# pip install rapidfuzz
import copy, unicodedata, re
from typing import Any, List, Tuple, Dict, Optional
from rapidfuzz import fuzz

def split_equal_when_multi_role_fuzzy_strict(
    role_blocks: List[Any],
    *,
    ROLE_ALIASES: Optional[Dict[str, List[str]]] = None,
    gap_px: int = 6,
    min_piece_w: int = 12,
    fuzzy_enable: bool = True,
    fuzzy_score_thr: int = 85,
    small_space_policy: str = "drop",  # "drop" | "shrink_gap" | "keep_unsplit"
    debug: bool = False
) -> List[Any]:
    """
    Aynı kutuda 2+ rol varsa kutuyu N eşit parçaya böler.
    Parçalar arası boşluk `gap_px` kadar bırakılır.
    Yer yetmezse davranış `small_space_policy` ile belirlenir.
    Tek rol varsa bölmez.
    """

    # ---- dict/obj yardımcıları ----
    def getf(b, k, d=None): return b.get(k, d) if isinstance(b, dict) else getattr(b, k, d)
    def setf(b, k, v): b.__setitem__(k, v) if isinstance(b, dict) else setattr(b, k, v)
    def new_like(b): return dict(b) if isinstance(b, dict) else copy.deepcopy(b)
    def xyxy(b):
        x,y,w,h = int(getf(b,"x")), int(getf(b,"y")), int(getf(b,"w")), int(getf(b,"h"))
        return x, y, x+w, y+h

    # ---- kanonikleştirme ----
    def tr_upper(s:str)->str: return (s or "").replace("i","İ").replace("ı","I").upper()
    def strip_diac(s:str)->str: return "".join(c for c in unicodedata.normalize("NFKD", s) if not unicodedata.combining(c))
    def canon(s:str)->str: return re.sub(r"\s+"," ", tr_upper(strip_diac(s))).strip()

    # ---- alias sözlüğü ----
    if ROLE_ALIASES is None:
        ROLE_ALIASES = {
            "divan_baskani":    ["DİVAN BAŞKANI","DIVAN BASKANI"],
            "oy_toplama_memuru":["OY TOPLAMA MEMURU","OY TOPLAYICI","TOPLAYICI"],
            "toplanti_baskani": ["TOPLANTI BAŞKANI","TOPLANTI BASKANI","TOPLANTI BAŞI"],
            "tutanak_yazmani":  ["TUTANAK YAZMANI","YAZMAN"],
            "yk_baskani":       ["YÖNETİM KURULU BAŞKANI","YONETIM KURULU BASKANI","YK BAŞKANI","YK BASKANI"],
            "yk_uyesi":         ["YÖNETİM KURULU ÜYESİ","YONETIM KURULU UYESI","YK ÜYESİ","YK UYESI","YÖNETİM KURULU ÜYELERİ"],
            "mudur":            ["MÜDÜR","MUDUR","GENEL MÜDÜR","GENEL MUDUR"],
            "baskan":           ["BAŞKAN","BASKAN"],
        }

    ALIASES = [(fam, canon(v)) for fam, vals in ROLE_ALIASES.items() for v in vals]
    ALIASES.sort(key=lambda t: len(t[1]), reverse=True)  # uzun alias önce

    # ---- rol tespiti (exact + fuzzy; non-overlap) ----
    def detect_roles(text: str) -> List[str]:
        t = canon(text)
        taken = [False]*len(t)
        fams: List[str] = []

        # exact
        for fam, cv in ALIASES:
            start = 0
            while True:
                idx = t.find(cv, start)
                if idx == -1: break
                rng = range(idx, idx+len(cv))
                if any(taken[i] for i in rng):
                    start = idx + 1; continue
                for i in rng: taken[i] = True
                fams.append(fam)
                start = idx + len(cv)

        # fuzzy fallback (yalnızca hiç/tek kaldıysa)
        if fuzzy_enable and len(fams) <= 1:
            cands = []
            for fam, cv in ALIASES:
                s1 = fuzz.partial_ratio(t, cv)
                s2 = fuzz.token_set_ratio(t, cv)
                sc = max(s1, s2)
                if sc >= fuzzy_score_thr:
                    key = cv.split()[0]
                    pos = t.find(key)
                    if pos == -1: pos = len(t) + 10
                    cands.append((fam, pos, sc))
            cands.sort(key=lambda x: (-x[2], x[1]))
            for fam, _, _ in cands:
                if fam not in fams:
                    fams.append(fam)

        # daha spesifik aile varsa genel "baskan"ı çıkar
        if any(f in fams for f in ("divan_baskani","toplanti_baskani","yk_baskani")):
            fams = [f for f in fams if f != "baskan"]

        # soldan sağa sıralı benzersiz liste
        seen=set(); ordered=[]
        for f in fams:
            if f not in seen:
                ordered.append(f); seen.add(f)
        return ordered

    # ---- ana akış ----
    out: List[Any] = []
    for b in role_blocks:
        txt = getf(b, "txt") or ""
        fams = detect_roles(txt)
        if debug: print(f"[roles] {fams} | txt[:80]={str(txt)[:80]!r}")

        if len(fams) <= 1:
            nb = new_like(b)
            if fams: setf(nb, "role", fams[0])
            out.append(nb)
            continue

        # N parçaya eşit böl + gap
        N = len(fams)
        x,y,x2,y2 = xyxy(b)
        W = x2 - x

        needed = N*min_piece_w + (N-1)*gap_px
        if needed > W:
            if small_space_policy == "drop":
                if debug: print(f"[drop] W={W} < needed={needed} (N={N}, gap={gap_px}, minw={min_piece_w})")
                # Tamamen dropla: hiçbir parça ekleme
                continue
            elif small_space_policy == "keep_unsplit":
                nb = new_like(b)
                setf(nb, "role", fams[0])  # birincil rolü yaz
                out.append(nb)
                continue
            else:  # "shrink_gap"
                # boşluğu küçült, yine de parçala
                possible_gap = max(0, (W - N*min_piece_w)) // max(1, (N-1))
                gap = possible_gap
        else:
            gap = gap_px

        usable = W - gap*(N-1)
        base = usable // N
        rem  = usable % N

        cur_x = x
        for i in range(N):
            w_piece = max(min_piece_w, base + (1 if i < rem else 0))
            nb = new_like(b)
            setf(nb, "x", cur_x); setf(nb, "y", y)
            setf(nb, "w", w_piece); setf(nb, "h", y2 - y)
            setf(nb, "role", fams[i])
            out.append(nb)
            if i < N-1:
                cur_x += w_piece + gap

    return out