from dataclasses import dataclass
from typing import List, Optional
import numpy as np

@dataclass(frozen=True)
class TextBox:
    x:int; y:int; w:int; h:int

# ---- yardımcılar ----
def union(a: TextBox, b: TextBox) -> TextBox:
    x1 = min(a.x, b.x)
    y1 = min(a.y, b.y)
    x2 = max(a.x + a.w, b.x + b.w)
    y2 = max(a.y + a.h, b.y + b.h)
    return TextBox(x1, y1, x2-x1, y2-y1)

def area(b: TextBox) -> int:
    return max(0, b.w) * max(0, b.h)

def inter(a: TextBox, b: TextBox) -> int:
    x1 = max(a.x, b.x)
    y1 = max(a.y, b.y)
    x2 = min(a.x + a.w, b.x + b.w)
    y2 = min(a.y + a.h, b.y + b.h)
    return max(0, x2-x1) * max(0, y2-y1)

def iou(a: TextBox, b: TextBox) -> float:
    i = inter(a,b)
    if i == 0: return 0.0
    return i / float(area(a) + area(b) - i)

def contains_ratio(outer: TextBox, inner: TextBox) -> float:
    """inner alanının ne kadarı outer içinde?"""
    x1 = max(outer.x, inner.x)
    y1 = max(outer.y, inner.y)
    x2 = min(outer.x + outer.w, inner.x + inner.w)
    y2 = min(outer.y + outer.h, inner.y + inner.h)
    inside = max(0, x2-x1) * max(0, y2-y1)
    a = area(inner)
    return 0.0 if a == 0 else inside / float(a)

def x_overlap_ratio(a: TextBox, b: TextBox) -> float:
    ax1, ax2 = a.x, a.x + a.w
    bx1, bx2 = b.x, b.x + b.w
    inter_w = max(0, min(ax2, bx2) - max(ax1, bx1))
    return 0.0 if min(a.w, b.w) <= 0 else inter_w / float(min(a.w, b.w))

# ---- imza sezgisi (yalnız/çizgi kutusu) ----
def is_signature_box(box: TextBox, text: str, h_char_txt: float) -> bool:
    # yazı çok az olsun
    letters_digits = sum(c.isalnum() for c in (text or ""))
    low_text = letters_digits <= 8

    # imzalar geniş-yatay olur; boy/en küçük; yükseklik karaktere göre sınırlı
    asp = box.w / max(1.0, box.h)      # genişlik / yükseklik
    ok_asp = 1.8 <= asp <= 13.0

    # karakter yüksekliğinin ~0.6–8 katı arası (DPI dalgalanmasına tolerans)
    ok_rel_h = (0.6*h_char_txt <= box.h <= 8.0*h_char_txt)
    ok_abs_h = (12 <= box.h <= 220)    # genel güvenli aralık

    # metin fazlaysa geometri çok ikna edici değilse imza sayma
    return (low_text and (ok_rel_h or ok_abs_h) and ok_asp)

def estimate_h_char_text(boxes: List[TextBox], texts: List[str], default: float = 20.0) -> float:
    # metin-benzeri kutulardan medyan karakter yüksekliği tahmini
    cands = []
    for b, t in zip(boxes, texts):
        a = sum(c.isalnum() for c in (t or ""))
        if a < 8: 
            continue
        asp = b.w / max(1.0, b.h)
        if asp < 0.6 or asp > 6.0: 
            continue
        if not (8 <= b.h <= 200): 
            continue
        cands.append(b.h)
    return float(np.median(cands)) if cands else default

# ---- SADECE imzayı üste bağla (zincirleme yok, tek eş, imza içerideyse dokunma) ----
def attach_signatures_upward_once(
    boxes: List[TextBox],
    texts: List[str],
    dbg: bool = False,
    x_ov_thr: float = 0.30,          # x-örtüşme eşiği (normal bağlama)
    band_pad_frac: float = 0.40,     # fallback x-band yarı genişliği = frac * imza.w
    max_center_frac: float = 0.50,   # fallback'te merkez farkı toleransı (frac * imza.w)
    contain_thr: float = 0.85        # imza zaten bir kutunun %85+ içinde ise "dokunma"
) -> List[TextBox]:
    """
    - İmzaları tespit eder.
    - Eğer imza, bir metin kutusunun içinde yer alıyorsa -> atla.
    - Aksi halde önce normal x-örtüşme ile en iyi ÜST kutuya bağlar (tek eş).
    - Bulamazsa, imzanın hemen üstündeki en yakın kutuyu 'dar x-bandı' içinde arar.
    - Birleştirince imza kutusunu listeden çıkarır; zincirleme birleşme yapmaz.
    """
    if not boxes:
        return boxes

    h_char_txt = estimate_h_char_text(boxes, texts, default=20.0)

    # üstten alta doğru sırala
    order = list(range(len(boxes)))
    order.sort(key=lambda i: boxes[i].y)

    used = [False] * len(boxes)
    out: List[TextBox] = []

    # hızlı kapsama kontrolü için
    def is_inside_any_text(i_sig: int) -> bool:
        b = boxes[i_sig]
        for j in range(len(boxes)):
            if j == i_sig: 
                continue
            if contains_ratio(boxes[j], b) >= contain_thr:
                # imza zaten bir kutunun içinde (muhtemelen o grubun parçası)
                return True
        return False

    # normal + fallback bağlama
    for i in order:
        if used[i]:
            continue

        b = boxes[i]
        t = texts[i] if i < len(texts) else ""

        # imza değilse olduğu gibi bırak
        if not is_signature_box(b, t, h_char_txt):
            out.append(b)
            used[i] = True
            continue

        # imza zaten bir metin kutusunun içinde mi? -> hiç dokunma
        if is_inside_any_text(i):
            if dbg: print(f"[SIG] inside-skip: i={i}")
            out.append(b)
            used[i] = True
            continue

        # 1) normal bağlama: x-örtüşmeli en iyi üst kutu
        best_j = None
        best_ov = 0.0
        for j in range(len(boxes)):
            if j == i or used[j]:
                continue
            top = boxes[j]
            if top.y + top.h > b.y:   # sadece üstteki kutular
                continue
            ov = x_overlap_ratio(top, b)
            if ov >= x_ov_thr and ov > best_ov:
                best_ov = ov
                best_j = j

        if best_j is not None:
            merged = union(boxes[best_j], b)
            if dbg: print(f"[DBG] normal bağlandı: i={i} -> j={best_j}, x-ovl={best_ov:.2f}")
            out.append(merged)
            used[i] = True
            used[best_j] = True
            continue

        # 2) fallback: dar x-bandında, merkeze göre en yakın ÜST kutu
        band_pad = int(round(band_pad_frac * b.w))
        left = b.x - band_pad
        right = b.x + b.w + band_pad
        cx = b.x + b.w // 2
        max_center_dx = max_center_frac * b.w

        candidates = []
        for j in range(len(boxes)):
            if j == i or used[j]:
                continue
            top = boxes[j]
            if top.y + top.h > b.y:
                continue
            # x-band filtresi
            in_band = not (top.x + top.w < left or top.x > right)
            if not in_band:
                continue
            # merkez yakınlığı
            cxt = top.x + top.w // 2
            if abs(cxt - cx) > max_center_dx:
                continue
            # geniş kapsama engeli: koca alanları es geç (çok büyük kutuya yapışıp her şeyi almamak için)
            if top.w > 1.6 * b.w and top.h > 3.0 * b.h:
                # yine de tamamen farklı gövde olabilir — aday listesinden çıkar
                pass
            dist = b.y - (top.y + top.h)
            candidates.append((dist, j))

        if candidates:
            candidates.sort()  # en küçük düşey boşluk
            j = candidates[0][1]
            merged = union(boxes[j], b)
            if dbg:
                print(f"[DBG] FALLBACK bağlandı: i={i} -> j={j}, "
                      f"band=({left},{right}), cxΔ={abs((boxes[j].x+boxes[j].w//2)-cx)}")
            out.append(merged)
            used[i] = True
            used[j] = True
        else:
            # bağlanacak üst kutu yok -> tek başına bırak (kurala göre istersen bırakmayabilirsin)
            if dbg: print(f"[DBG] üstte kutu yok, imza tek bırakıldı: i={i}")
            out.append(b)
            used[i] = True

    # kullanılmamış (ne imza ne birleştirilen) kutuları ekle
    for i in range(len(boxes)):
        if not used[i]:
            out.append(boxes[i])

    # sabit görüntü için sol-sağ, yukarı-aşağı sırala
    out.sort(key=lambda b: (b.y, b.x))
    return out