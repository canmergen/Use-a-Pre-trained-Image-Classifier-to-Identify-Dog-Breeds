# ==== 1) İmza sezgisi: daha toleranslı ====
def is_signature_box(box: TextBox, text: str, h_char_txt: float) -> bool:
    # metin az olmalı (OCR hataları vs. için toleranslı)
    letters_digits = sum(c.isalnum() for c in (text or ""))
    low_text = letters_digits <= 20

    # imzalar genelde yatay-uzun
    asp = box.w / max(1.0, box.h)            # en-boy oranı
    ok_asp = 1.3 <= asp <= 10.0

    # karakter yüksekliğine göre göreli yükseklik + mutlak güvenli aralık
    ok_rel_h = (0.5*h_char_txt <= box.h <= 10.0*h_char_txt)
    ok_abs_h = (10 <= box.h <= 260)

    # çok yüksek en-boy + çok az metin + makul yükseklik -> imza
    return (low_text and (ok_rel_h or ok_abs_h) and ok_asp)


# ==== 2) Sadece imzayı bir üst kutuya bağla (zincirleme yok) + detaylı DEBUG ====
def attach_signatures_upward_once(
    boxes: List[TextBox],
    texts: List[str],
    dbg: bool = False,
    x_ov_thr: float = 0.30,          # normal bağlama için x-örtüşme eşiği
    band_pad_frac: float = 0.40,     # fallback x-band yarı genişliği = frac * imza.w
    max_center_frac: float = 0.60,   # fallback merkez farkı toleransı = frac * imza.w
    contain_thr: float = 0.85        # imza zaten bir kutunun %85+ içinde ise dokunma
) -> List[TextBox]:

    if not boxes:
        return boxes

    # karakter yüksekliği tahmini (sadece metin-benzeri kutulardan)
    def estimate_h_char_text(boxes, texts, default=20.0):
        cands=[]
        for b,t in zip(boxes,texts):
            a=sum(c.isalnum() for c in (t or ""))
            if a<8: continue
            asp=b.w/max(1.0,b.h)
            if asp<0.6 or asp>6.0: continue
            if not (8<=b.h<=220): continue
            cands.append(b.h)
        import numpy as np
        return float(np.median(cands)) if cands else default

    def x_overlap_ratio(a: TextBox, b: TextBox) -> float:
        ax1,ax2=a.x,a.x+a.w; bx1,bx2=b.x,b.x+b.w
        inter_w=max(0, min(ax2,bx2)-max(ax1,bx1))
        return 0.0 if min(a.w,b.w)<=0 else inter_w/float(min(a.w,b.w))

    def contains_ratio(outer: TextBox, inner: TextBox) -> float:
        x1=max(outer.x, inner.x); y1=max(outer.y, inner.y)
        x2=min(outer.x+outer.w, inner.x+inner.w)
        y2=min(outer.y+outer.h, inner.y+inner.h)
        inside=max(0, x2-x1)*max(0, y2-y1)
        a=max(0, inner.w)*max(0, inner.h)
        return 0.0 if a==0 else inside/float(a)

    def union(a: TextBox, b: TextBox) -> TextBox:
        x1=min(a.x,b.x); y1=min(a.y,b.y)
        x2=max(a.x+a.w, b.x+b.w); y2=max(a.y+a.h, b.y+b.h)
        return TextBox(x1,y1,x2-x1,y2-y1)

    h_char_txt = estimate_h_char_text(boxes, texts, default=20.0)

    order = list(range(len(boxes)))
    order.sort(key=lambda i: boxes[i].y)     # yukarıdan aşağı

    used = [False]*len(boxes)
    out: List[TextBox] = []

    # debug başlık
    if dbg:
        print(f"[DBG] h_char_txt ~= {h_char_txt:.1f}px")

    # imza kutusu zaten başka bir kutunun içinde mi?
    def is_inside_any(i_sig: int) -> bool:
        b = boxes[i_sig]
        for j in range(len(boxes)):
            if j==i_sig: continue
            if contains_ratio(boxes[j], b) >= contain_thr:
                return True
        return False

    for i in order:
        if used[i]: 
            continue

        b = boxes[i]
        t = texts[i] if i < len(texts) else ""

        # her kutu için decision log yaz
        if dbg:
            alnum = sum(c.isalnum() for c in (t or ""))
            asp = b.w/max(1.0,b.h)
            ok_rel = (0.5*h_char_txt <= b.h <= 10.0*h_char_txt)
            ok_abs = (10 <= b.h <= 260)
            ok_asp = (1.3 <= asp <= 10.0)
            is_sig = is_signature_box(b, t, h_char_txt)
            print(f"[DBG] i={i} box=({b.x},{b.y},{b.w},{b.h}) "
                  f"alnum={alnum} h_char={h_char_txt:.1f} ok_rel={ok_rel} "
                  f"ok_abs={ok_abs} asp={asp:.2f} ok_asp={ok_asp} -> is_sig={is_sig}")

        # imza değilse aynen ekle
        if not is_signature_box(b, t, h_char_txt):
            out.append(b); used[i]=True
            continue

        # imza zaten bir kutunun içinde -> dokunma
        if is_inside_any(i):
            if dbg: print(f"[SIG] inside-skip: i={i}")
            out.append(b); used[i]=True
            continue

        # 1) normal bağlama: x-örtüşmeli en iyi üst kutu
        best_j=None; best_ov=0.0
        for j in range(len(boxes)):
            if j==i or used[j]: continue
            top=boxes[j]
            if top.y+top.h > b.y:   # sadece üsttekiler
                continue
            ov = x_overlap_ratio(top, b)
            if ov >= x_ov_thr and ov > best_ov:
                best_ov=ov; best_j=j

        if best_j is not None:
            out.append( union(boxes[best_j], b) )
            used[i]=True; used[best_j]=True
            if dbg: print(f"[DBG] normal bağlandı: i={i} -> j={best_j}, x-ovl={best_ov:.2f}")
            continue

        # 2) fallback: dar x-band + merkez yakınlığı ile en yakın üst kutu
        band_pad = int(round(band_pad_frac * b.w))
        left  = b.x - band_pad
        right = b.x + b.w + band_pad
        cx = b.x + b.w//2
        max_dx = max_center_frac * b.w

        candidates=[]
        for j in range(len(boxes)):
            if j==i or used[j]: continue
            top=boxes[j]
            if top.y+top.h > b.y: continue
            in_band = not (top.x + top.w < left or top.x > right)
            if not in_band: continue
            cxt = top.x + top.w//2
            if abs(cxt - cx) > max_dx: continue
            candidates.append( (b.y - (top.y+top.h), j) )  # dikey mesafe

        if candidates:
            candidates.sort()
            j = candidates[0][1]
            out.append( union(boxes[j], b) )
            used[i]=True; used[j]=True
            if dbg: 
                print(f"[DBG] FALLBACK bağlandı: i={i} -> j={j} "
                      f"(band=({left},{right}), |cxΔ|<={max_dx:.1f})")
        else:
            # üstte hiç kutu yoksa tek bırak
            if dbg: print(f"[DBG] üstte kutu yok, imza tek bırakıldı: i={i}")
            out.append(b); used[i]=True

    # kalanları ekle
    for i in range(len(boxes)):
        if not used[i]:
            out.append(boxes[i])

    out.sort(key=lambda b: (b.y, b.x))
    return out