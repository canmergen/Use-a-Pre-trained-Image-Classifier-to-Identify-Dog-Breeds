# --- yardımcı: satır kırığı ile ayrılan '... GIDA s\nAN., VE TİC ...' örneklerini birleştir ---
def _merge_split_san(name: str) -> str:
    # 's AN.' / 's AN,' / 's AN' varyasyonları
    name = re.sub(r"\bs\s+an(\.|,)", r"SAN\1", name, flags=re.IGNORECASE)
    name = re.sub(r"\bs\s+an\b", "SAN", name, flags=re.IGNORECASE)
    return name


def _find_company(
    lines: List[str],
    *,
    fuzzy_type_thresh: float = 0.82,
    fuzzy_join_lines: bool = True,
) -> Tuple[Optional[str], Optional[str]]:
    """
    Üst bölüm OCR satırlarından şirket adını ve türünü yakala.
    Dönüş: (cname_raw, ctype)
    """

    # ---- kalite metriği (kısa/rakam ağırlıklı adayları ele) ----
    def _quality_score(name: str) -> float:
        if not name: return 0.0
        s = unicodedata.normalize("NFKC", name)
        letters = sum(ch.isalpha() for ch in s)
        digits  = sum(ch.isdigit() for ch in s)
        if letters < 3 or letters <= digits:  # aşırı zayıf
            return 0.0
        toks = [t for t in re.split(r"\s+", s.strip()) if t]
        return 0.6*min(len(s)/80.0, 1.0) + 0.3*min(len(toks)/8.0, 1.0) + 0.1*(letters/(letters+digits+1e-6))

    # ---- boşluk/dağınık harfe toleranslı tip kalıpları ----
    def _spaced(word: str) -> str:
        m = (word.replace("İ","I").replace("ı","i")
                 .replace("Ş","S").replace("ş","s")
                 .replace("Ğ","G").replace("ğ","g")
                 .replace("Ü","U").replace("ü","u")
                 .replace("Ö","O").replace("ö","o")
                 .replace("Ç","C").replace("ç","c"))
        letters = [re.escape(ch) for ch in m if ch.strip()]
        return r"\s*".join(letters)

    spaced_anchors = [
        _spaced("ANONIM")+r"\s+"+_spaced("SIRKET")+r"[Iİ]?",
        _spaced("LIMITED")+r"\s+"+_spaced("SIRKET")+r"[Iİ]?",
        r"L\s*TD\.?\s*"+_spaced("STI"),
        _spaced("A")+r"\.?\s*"+_spaced("S")+r"\.?",  # A.Ş.
        _spaced("AS"),
        _spaced("HOLDING"),
        _spaced("KOOPERATIF"),
        _spaced("KOLEKTIF")+r"\s+"+_spaced("SIRKET")+r"[Iİ]?",
        _spaced("KOMANDIT")+r"\s+"+_spaced("SIRKET")+r"[Iİ]?",
        _spaced("VAKIF"),
        _spaced("DERNEK"),
    ]
    SPACED_TYPE = r"(?:\b" + r"\b|\b".join(spaced_anchors) + r"\b)"

    # Greedy (non-greedy değil): tipten önceki tüm sol bağlamı al
    RE_COMP_BEFORE = re.compile(
        rf"(?P<name>[A-ZÇĞİÖŞÜ0-9][A-ZÇĞİÖŞÜ0-9\s&\.\-']{{6,}})\s+(?P<type>{SPACED_TYPE})",
        re.IGNORECASE
    )
    RE_COMP_AFTER = re.compile(
        rf"(?P<type>{SPACED_TYPE})\s*[:,-]?\s*(?P<name>[A-ZÇĞİÖŞÜ0-9][A-ZÇĞİÖŞÜ0-9\s&\.\-']{{6,}})",
        re.IGNORECASE
    )

    HEADER_WORDS = {
        "GENEL","KURUL","KURULDA","HAZIR","BULUNANLAR","LİSTESİ","LISTESI","TOPLANTI",
        "TUTANAĞI","TUTANAGI","PAY","SAHİBİNİN","SAHIBININ","TC","TCKN","VKN","VKNO",
        "AD","SOYAD","ADRES","ÜNVAN","UNVAN","KATILIM","TEMSİLCİ","IMZA","İMZA",
        "TOPLAM","İTİBARİ","ITIBARI","GÜNDEM"
    }

    def _map_type_to_label(type_span: str) -> Optional[str]:
        up = _normalize_line(type_span)
        for creg, label in TYPE_REGEX:
            if creg.search(up):
                return label
        return None

    # ---- 0) satırları hazırla ----
    src = [ln for ln in (lines or []) if isinstance(ln, str)]
    if not src:
        return None, None

    # Gürültü/tek karakter/başlık kelimeleri ayıkla; ilk 12 satır makul
    filt = []
    for ln in src[:12]:
        s = (ln or "").strip()
        if not s:
            continue
        # tek işaret / tek harf satırı
        if re.fullmatch(r"[^\wçğıöşüÇĞİÖŞÜ]+|[A-Za-zÇĞİÖŞÜçğıöşü]", s):
            continue
        up = unicodedata.normalize("NFKC", s).upper()
        if any(w in up for w in HEADER_WORDS):
            continue
        filt.append(s)

    # ---- 1) FLAT: satırları birleştir ve ara (satır kırıkları çözülür) ----
    flat = re.sub(r"\s+", " ", " ".join(filt if filt else src[:12])).strip()
    for pat in (RE_COMP_BEFORE, RE_COMP_AFTER):
        m = pat.search(flat)
        if m:
            cname_raw = _merge_split_san(m.group("name").strip())
            ctype = _map_type_to_label(m.group("type"))
            return cname_raw, ctype

    # ---- 2) PAIR JOIN: ardışık satır çiftlerini birleştirip ara ----
    best = None  # (score, cname_raw, ctype)
    for i in range(len(src)-1):
        pair = re.sub(r"\s+", " ", (src[i] + " " + src[i+1])).strip()
        for pat in (RE_COMP_BEFORE, RE_COMP_AFTER):
            m = pat.search(pair)
            if not m:
                continue
            cname_raw = _merge_split_san(m.group("name").strip())
            q = _quality_score(cname_raw)
            if q <= 0:
                continue
            ctype = _map_type_to_label(m.group("type"))
            if (best is None) or (q > best[0]):
                best = (q, cname_raw, ctype)
    if best:
        return best[1], best[2]

    # ---- 3) Geriye uyumluluk: eski REGEX/FUZZY mantığı ----
    best_regex = None  # (score, line_idx, cname_raw, ctype)
    for i, raw in enumerate(src):
        norm = _normalize_line(raw)
        for creg, label in TYPE_REGEX:
            mm = creg.search(norm)
            if not mm:
                continue
            cand = raw.strip() if mm.start() == 0 else raw[:mm.start()].strip()
            q = _quality_score(cand)
            if q > 0 and ((best_regex is None) or (q > best_regex[0]) or (q == best_regex[0] and i < best_regex[1])):
                best_regex = (q, i, str(cand), label)
    if best_regex:
        return best_regex[2], best_regex[3]

    best_fuzzy = None  # (rank, line_idx, cname_raw, ctype)
    for i, raw in enumerate(src):
        norm = _normalize_line(raw)
        best_label, best_score = None, 0.0
        for canonical, variants in CANON_TYPES.items():
            sc = max(_fuzzy_ratio(v, norm) for v in variants)
            if sc > best_score:
                best_score, best_label = sc, canonical
        if best_label and best_score >= fuzzy_type_thresh:
            cand = raw.strip()
            q = _quality_score(cand)
            if q > 0:
                rank = 0.7*best_score + 0.3*min(q, 1.0)
                if (best_fuzzy is None) or (rank > best_fuzzy[0]) or (rank == best_fuzzy[0] and i < best_fuzzy[1]):
                    best_fuzzy = (rank, i, str(cand), best_label)
    if best_fuzzy:
        return best_fuzzy[2], best_fuzzy[3]

    if fuzzy_join_lines and src:
        joined_raw = " ".join(src).strip()
        joined_norm = _normalize_line(joined_raw)
        best_label, best_score = None, 0.0
        for canonical, variants in CANON_TYPES.items():
            sc = max(_fuzzy_ratio(v, joined_norm) for v in variants)
            if sc > best_score:
                best_score, best_label = sc, canonical
        if best_label and best_score >= fuzzy_type_thresh:
            head = " ".join([ln.strip() for ln in src[:3]]).strip()
            cand = head if _quality_score(head) >= _quality_score(joined_raw) else joined_raw
            if _quality_score(cand) > 0:
                return str(cand), best_label

    return None, None