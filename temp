import re, unicodedata

def fallback_company_from_text(
    text: str,
    *,
    left_window: int = 160,     # tipe kadar en fazla kaç karakteri "ad" kabul edelim
    min_name_len: int = 6,      # temizlik sonrası minimum ad uzunluğu
) -> tuple[str|None, str|None, dict]:
    """
    Üst-bant OCR metninden (tek string) şirket adını ve türünü bulur.
    Harf arası boşluklara, ekli biçimlere (ŞİRKETİNİN), noktalama/bozulmalara toleranslıdır.
    Dönüş: (company_name | None, canonical_type | None, debug_info)
    """

    if not text or not isinstance(text, str):
        return None, None, {"reason": "empty_text"}

    dbg = {}

    # --- Normalizasyon (ama Türkçe büyük harfleri koruyarak) ------------------
    T = unicodedata.normalize("NFKC", text)
    # satırları birleştir, çoklu boşluğu tek boşluk yap
    T = re.sub(r"[ \t\f]+", " ", T.replace("\r", " ").replace("\n", " ").strip())

    # Harf arası boşluk toleransı için yardımcı
    def spaced_token(tok: str) -> str:
        # "ŞİRKET" -> "Ş\s*İ\s*R\s*K\s*E\s*T"
        parts = [re.escape(ch) for ch in tok if not ch.isspace()]
        return r"\s*".join(parts)

    # --- Tip desenleri (geniş) ------------------------------------------------
    TYPE_ANCHORS = [
        r"A\.?\s*Ş\.?", r"A\.?\s*S\.?", r"\bAŞ\b", r"\bAS\b",
        r"ANON[İI]M\s+" + spaced_token("ŞİRKET"),
        r"LTD\.?\s*ŞT[İI]", r"LTD\.?\s*ST[İI]",
        r"L[İI]M[İI]TED\s+" + spaced_token("ŞİRKET"),
        spaced_token("ŞİRKET"),
        r"HOLD[İI]NG", r"KOOPERAT[İI]F",
        r"KOLEKT[İI]F\s+" + spaced_token("ŞİRKET"),
        r"AD[İI]\s+KOMAND[İI]T\s+" + spaced_token("ŞİRKET"),
        r"SERMAYES[İI]\s+PAYLARA\s+BÖLÜNMÜŞ\s+KOMAND[İI]T\s+" + spaced_token("ŞİRKET"),
        r"KOMAND[İI]T\s+" + spaced_token("ŞİRKET"),
        r"VAKF[ıiIİ]|VAKIF", r"DERNEK",
    ]
    GEN_SUFFIX = r"(?:\s*[’'\"“”]?\s*(?:NIN|NİN|NUN|NÜN|IN|İN|UN|ÜN))?"  # ŞİRKETİNİN vb.
    TYPE_CORE = r"(?P<type>(" + "|".join(TYPE_ANCHORS) + r"))" + GEN_SUFFIX
    # “solundaki her şey adı” mantığı
    PAT = re.compile(rf"(?P<left>.{{0,{left_window}}}?){TYPE_CORE}", re.IGNORECASE)

    m = PAT.search(T)
    if not m:
        dbg["reason"] = "type_not_found"
        return None, None, dbg

    left = (m.group("left") or "").strip(" :;,-—–\u200b")
    type_raw = m.group("type")

    # --- Kanonik tipe mapleme -------------------------------------------------
    def map_type(raw: str) -> str|None:
        U = unicodedata.normalize("NFKC", raw).upper()
        if re.search(r"\bA\.?\s*Ş\.?|\bAŞ\b|\bA\.?\s*S\.?\b", U): return "ANONİM ŞİRKETİ"
        if re.search(r"\bLTD\s*.?\s*ŞT[İI]\b|\bLTD\s*.?\s*ST[İI]\b|\bL[İI]M[İI]TED\s+Ş[İI]RKET[İI]?\b", U): return "LİMİTED ŞİRKETİ"
        if re.search(r"ANON[İI]M\s+Ş[İI]RKET[İI]?", U): return "ANONİM ŞİRKETİ"
        if re.search(r"HOLD[İI]NG", U): return "HOLDİNG"
        if re.search(r"KOOPERAT[İI]F", U): return "KOOPERATİF"
        if re.search(r"KOLEKT[İI]F\s+Ş[İI]RKET[İI]?", U): return "KOLEKTİF ŞİRKET"
        if re.search(r"AD[İI]\s+KOMAND[İI]T\s+Ş[İI]RKET[İI]?", U): return "ADİ KOMANDİT ŞİRKET"
        if re.search(r"SERMAYES[İI]\s+PAYLARA\s+BÖLÜNMÜŞ\s+KOMAND[İI]T\s+Ş[İI]RKET[İI]?", U): return "SERMAYESİ PAYLARA BÖLÜNMÜŞ KOMANDİT ŞİRKET"
        if re.search(r"KOMAND[İI]T\s+Ş[İI]RKET[İI]?", U): return "KOMANDİT ŞİRKET"
        if re.search(r"\bVAKF[ıiIİ]\b|\bVAKIF\b", U): return "VAKIF"
        if re.search(r"\bDERNEK\b", U): return "DERNEK"
        # yalın “ŞİRKET” yakalanmışsa ad üstünden tahmin yapmak mantıksız; None bırak
        return None

    ctype = map_type(type_raw)

    # --- Ad temizliği (tip kelimesi ve eklerini kes) --------------------------
    # Şirket, LTD., A.Ş. vb. çıksın; şirket kelimesinden sonrası atılsın
    TYPE_CORE_LITE = re.compile(
        r"(?:A\.?\s*Ş\.?|A\.?\s*S\.?|AŞ|AS|ANON[İI]M\s+Ş[İI]RKET[İI]?|"
        r"LTD\s*.?\s*ŞT[İI]|LTD\s*.?\s*ST[İI]|L[İI]M[İI]TED\s+Ş[İI]RKET[İI]?|"
        r"Ş[İI]RKET[İI]?|HOLD[İI]NG|KOOPERAT[İI]F|KOLEKT[İI]F\s+Ş[İI]RKET[İI]?|"
        r"AD[İI]\s+KOMAND[İI]T\s+Ş[İI]RKET[İI]?|KOMAND[İI]T\s+Ş[İI]RKET[İI]?|VAKF[ıiIİ]|VAKIF|DERNEK)"
        r"(?:\s*[’'\"“”]?\s*(?:NIN|NİN|NUN|NÜN|IN|İN|UN|ÜN))?$",
        re.IGNORECASE
    )
    # soldaki son “tip” demirini bulup onun SOLUNU ad olarak bırak
    cut = TYPE_CORE_LITE.search(left)
    if cut:
        name = left[:cut.start()].rstrip(" ,.-:;’'\"“”").strip()
    else:
        name = left.strip()

    # Aşırı temizleme yapmayın: ticari karakterleri tutalım
    name = re.sub(r"[^\w\s\.-/&ÇĞİÖŞÜçğıöşü]", " ", name)
    name = re.sub(r"\s+", " ", name).strip()

    # çok kısa ise None
    if len(name) < min_name_len:
        dbg.update({"reason": "name_too_short", "name": name, "type": ctype, "matched_left": left})
        return None, ctype, dbg

    # Türkçe büyük harflerle üst alma
    def upper_tr(s: str) -> str:
        mp = {"i":"İ","ı":"I","ş":"Ş","ğ":"Ğ","ü":"Ü","ö":"Ö","ç":"Ç"}
        return "".join(mp.get(ch, ch.upper()) for ch in s)

    name_up = upper_tr(name)

    dbg.update({
        "match_span": (m.start(), m.end()),
        "matched_type_raw": type_raw,
        "matched_left": left,
        "final_name": name_up,
        "final_type": ctype
    })
    return name_up, ctype, dbg