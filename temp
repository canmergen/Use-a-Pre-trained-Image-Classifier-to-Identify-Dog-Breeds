def _find_company(lines):
    """
    OCR satırlarından şirket adını ve türünü çıkarır.
    - A.Ş’NİN / LTD. ŞTİ.’NİN / Ş İ R K E T vb. toleranslı
    - Son görülen tipe göre SOL kesim
    - Kısa/yarım adlarda önceki satırı ekler
    Dönüş: (company_name | None, canonical_type | None)
    """
    import re, unicodedata

    def upper_tr(s: str) -> str:
        mp = {"i":"İ","ı":"I","ş":"Ş","ğ":"Ğ","ü":"Ü","ö":"Ö","ç":"Ç"}
        return "".join(mp.get(ch, ch.upper()) for ch in s or "")

    def norm(s: str) -> str:
        s = unicodedata.normalize("NFKC", s or "")
        s = s.replace("\u200b"," ").replace("\xa0"," ")
        return re.sub(r"\s+", " ", s).strip()

    def spaced(tok: str) -> str:
        return r"\s*".join(re.escape(ch) for ch in tok if not ch.isspace())

    # --- Tip (kısaltma + ek) desenleri ---
    GEN = r"(?:\s*[’'`´\"“”]?\s*(?:NIN|NİN|NUN|NÜN|IN|İN|UN|ÜN))?"
    AS   = r"(?:A\.?\s*Ş|A\.?\s*S|AŞ|AS)"+GEN
    ANON = r"ANON[İI]M\s+"+spaced("ŞİRKET")+GEN
    LTD  = r"(?:LTD\s*\.?\s*ŞT[İI]|LTD\s*\.?\s*ST[İI]|L[İI]M[İI]TED\s+"+spaced("ŞİRKET")+r")"+GEN
    SIRK = spaced("ŞİRKET")+GEN
    HOLD = r"HOLD[İI]NG"; KOOP=r"KOOPERAT[İI]F"
    KOL  = r"KOLEKT[İI]F\s+"+SIRK; ADKOM=r"AD[İI]\s+KOMAND[İI]T\s+"+SIRK
    SPBK = r"SERMAYES[İI]\s+PAYLARA\s+BÖLÜNMÜŞ\s+KOMAND[İI]T\s+"+SIRK
    KOM  = r"KOMAND[İI]T\s+"+SIRK; VAK=r"VAKF[Iİ]|VAKIF"; DER=r"DERNEK"

    TYPE_CORE = rf"(?:{AS}|{ANON}|{LTD}|{KOL}|{ADKOM}|{SPBK}|{KOM}|{HOLD}|{KOOP}|{VAK}|{DER})"
    TYPE_RE = re.compile(TYPE_CORE, re.IGNORECASE)

    def canon_type(raw: str | None) -> str | None:
        if not raw: return None
        U = norm(raw).upper()
        U2 = re.sub(r"[\s\.\-_/’'`´]+", "", U.replace("İ","I").replace("Ş","S").replace("Ğ","G").replace("Ü","U").replace("Ö","O").replace("Ç","C"))
        if re.search(r"(AS|AŞ|ANONIMSIRKET)", U2): return "ANONİM ŞİRKETİ"
        if re.search(r"(LTDSTI|LIMITEDSIRKET)", U2): return "LİMİTED ŞİRKETİ"
        if "HOLDING" in U2: return "HOLDİNG"
        if "KOOPERATIF" in U2: return "KOOPERATİF"
        if re.search(r"KOLEKTIF.*SIRKET", U2): return "KOLEKTİF ŞİRKET"
        if re.search(r"ADIKOMANDIT.*SIRKET", U2): return "ADİ KOMANDİT ŞİRKET"
        if re.search(r"SERMAYESIPAYLARABOLUNMUSKOMANDIT.*SIRKET", U2): return "SERMAYESİ PAYLARA BÖLÜNMÜŞ KOMANDİT ŞİRKET"
        if re.search(r"KOMANDIT.*SIRKET", U2): return "KOMANDİT ŞİRKET"
        if "VAKIF" in U2: return "VAKIF"
        if "DERNEK" in U2: return "DERNEK"
        return None

    BAD_ENDS = {"AN","VE","TIC","TİC","SAN","VE.","TIC.","TİC.","SAN."}

    def clean_name(left: str, ctype: str | None) -> str:
        # soldaki metni ad yap; tip kelimeleri, ekleri ve son noktalama temizle
        s = norm(left)
        # çok agresif olmayın: . - / & ' karakterlerini tut
        s = re.sub(r"[^\w\s\.\-\/&’'ÇĞİÖŞÜçğıöşü]", " ", s)
        s = re.sub(r"\s+", " ", s).strip(" ,.-:;’'")
        # kötü bitişler için önceki kelimeyi de bırak
        tail = re.sub(r".*\s", "", s).upper()
        if tail in BAD_ENDS:
            s = re.sub(r"\s+\S+$", "", s).strip(" ,.-:;’'")
        return s

    src = [norm(x) for x in (lines or []) if isinstance(x, str) and x.strip()]
    if not src: return None, None

    best = None  # (score, name, type)

    for i, ln in enumerate(src):
        # SATIRDAKİ SON TİP EŞLEŞMESİNİ BUL
        matches = list(TYPE_RE.finditer(ln))
        if not matches: continue
        m = matches[-1]
        name_left = ln[:m.start()]
        # kısa/yarım ise bir önceki satırı ekle
        if (len(name_left) < 8 or re.sub(r".*\s","",name_left).upper() in BAD_ENDS) and i>0:
            name_left = (src[i-1] + " " + name_left).strip()
        ctype = canon_type(m.group(0))
        name = clean_name(name_left, ctype)
        # makul skor: uzunluk + kelime sayısı
        letters = sum(ch.isalpha() for ch in name)
        toks = len([t for t in name.split() if t])
        score = 0.6*min(len(name)/80,1)+0.3*min(toks/8,1)+0.1*(letters/(letters+1e-6))
        if letters>=3 and (best is None or score>best[0]):
            best = (score, name, ctype)

    if best:
        return upper_tr(best[1]), best[2]

    # Fallback: tüm metni birleştirip aynı işlemi yap
    joined = " ".join(src)
    matches = list(TYPE_RE.finditer(joined))
    if not matches: 
        return None, None
    m = matches[-1]
    name = clean_name(joined[:m.start()], None)
    return (upper_tr(name) if name else None), canon_type(m.group(0))