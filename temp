def extract_and_merge_sermaye(
    pages_scaled,
    bottom_df=None,
    fuzzy_threshold: int = 80,
    line_tol: float = 0.8,
    max_dx: int = 1600
):
    """
    End-to-end 'sermaye' extractor with robust number parsing.
    Inputs
    ------
    pages_scaled : List[List[Dict]]   # OCR regions per page, each region has {"text": str, "bbox": {x_min,y_min,x_max,y_max,...}}
    bottom_df    : Optional[pd.DataFrame]  # if given, merged output is returned
    fuzzy_threshold : int             # RapidFuzz partial-ratio threshold
    line_tol     : float              # same-line tolerance as a multiple of label height
    max_dx       : int                # max horizontal distance (pixels) to search on the right

    Returns
    -------
    sermaye_df if bottom_df is None; otherwise merged_df
    """
    import re
    import pandas as pd
    from rapidfuzz import fuzz

    # --------------------- helpers (scoped; not polluting global space) ---------------------
    REQ_KEYS = ("x_min", "y_min", "x_max", "y_max")

    # generous digit capture (allows thousands & decimals with mixed separators and spaces)
    DIGIT_RX = re.compile(r"\d[\d\s\.,]*")

    # strict detectors to avoid mis-parsing:
    _RX_COMMA_DEC  = re.compile(r"^\s*\d{1,3}(?:\.\d{3})*,\d{1,2}\s*$")   # 1.234,56
    _RX_DOT_DEC    = re.compile(r"^\s*\d{1,3}(?:,\d{3})*\.\d{1,2}\s*$")   # 1,234.56
    _RX_DOTS_THOUS = re.compile(r"^\s*\d{1,3}(?:\.\d{3})+\s*$")           # 12.050.000
    _RX_COMM_THOUS = re.compile(r"^\s*\d{1,3}(?:,\d{3})+\s*$")            # 12,050,000
    _RX_INTEGER    = re.compile(r"^\s*\d+\s*$")                           # 12050000

    def _norm(s: str) -> str:
        return (s or "").casefold()

    def _has_digits(s: str) -> bool:
        return bool(DIGIT_RX.search(s or ""))

    def _extract_number_str(s: str):
        if not s:
            return None
        # take the *longest* digit-like span; OCR sometimes emits noise fragments
        cands = [m.group(0).strip() for m in DIGIT_RX.finditer(s)]
        if not cands:
            return None
        return max(cands, key=len)

    def _parse_tr_number(num_str: str):
        """
        Robust parsing for:
          '12.050.000' -> 12050000
          '12,050,000' -> 12050000
          '12.050,00'  -> 12050.00
          '12,050.00'  -> 12050.00
          '12050000'   -> 12050000
        Also tolerates trailing currency text (TL, ₺, TRY).
        """
        if not num_str:
            return None
        s = num_str.strip()
        # strip currency/labels (OCR variants included)
        for tok in ["TL", "tl", "Tl", "tL", "₺", "TRY", "try", "Try"]:
            s = s.replace(tok, "")
        s = s.strip()

        # normalize internal spaces around separators
        s = re.sub(r"\s+", "", s)

        # explicit patterns (highest confidence first)
        if _RX_COMMA_DEC.match(s):
            s_norm = s.replace(".", "").replace(",", ".")
            try: return float(s_norm)
            except ValueError: return None

        if _RX_DOT_DEC.match(s):
            s_norm = s.replace(",", "")
            try: return float(s_norm)
            except ValueError: return None

        if _RX_DOTS_THOUS.match(s):
            s_norm = s.replace(".", "")
            try: return float(s_norm)
            except ValueError: return None

        if _RX_COMM_THOUS.match(s):
            s_norm = s.replace(",", "")
            try: return float(s_norm)
            except ValueError: return None

        if _RX_INTEGER.match(s):
            try: return float(s)
            except ValueError: return None

        # fallback heuristic by last separator role
        last_dot   = s.rfind(".")
        last_comma = s.rfind(",")
        if last_comma > last_dot >= 0:
            s_norm = s.replace(".", "").replace(",", ".")   # comma-decimal
        elif last_dot > last_comma >= 0:
            s_norm = s.replace(",", "")                     # dot-decimal
        else:
            s_norm = s.replace(".", "").replace(",", "")    # ambiguous ⇒ integer

        try:
            return float(s_norm)
        except ValueError:
            return None

    def _height(b):
        return b.get("height", b["y_max"] - b["y_min"])

    def _reading_order(items):
        return sorted(range(len(items)), key=lambda i: (items[i]["bbox"]["y_min"], items[i]["bbox"]["x_min"]))

    def _same_line(bA, bB, tol):
        ya = (bA["y_min"] + bA["y_max"]) / 2.0
        yb = (bB["y_min"] + bB["y_max"]) / 2.0
        h  = max(_height(bA), 1)
        return abs(ya - yb) <= tol * h

    def _nearest_value_on_right(items, idx_label, max_dx, line_tol):
        A = items[idx_label]["bbox"]
        cxA = (A["x_min"] + A["x_max"]) / 2.0
        best_i, best_dx = None, None
        for i, it in enumerate(items):
            if i == idx_label:
                continue
            B = it["bbox"]
            if B["x_min"] <= cxA:
                continue
            if not _same_line(A, B, line_tol):
                continue
            if not _has_digits(it.get("text", "")):
                continue
            dx = B["x_min"] - cxA
            if 0 <= dx <= max_dx and (best_dx is None or dx < best_dx):
                best_i, best_dx = i, dx
        return best_i

    # --------------------- extraction ---------------------
    rows = []
    for pidx, items in enumerate(pages_scaled or []):
        if not items:
            continue

        order = _reading_order(items)
        pos = {i: k for k, i in enumerate(order)}

        for i, itm in enumerate(items):
            txt = _norm(itm.get("text", ""))

            # fuzzy match any sermaye variant
            score = max(
                fuzz.partial_ratio(txt, "sermaye"),
                fuzz.partial_ratio(txt, "sermayesi"),
                fuzz.partial_ratio(txt, "ödenmiş sermaye"),
                fuzz.partial_ratio(txt, "çıkarılmış sermaye"),
                fuzz.partial_ratio(txt, "sermayenin"),
            )
            if score < fuzzy_threshold:
                continue

            label_bbox = itm["bbox"]
            value_txt = None
            value_bbox = None
            value_str = None
            value_num = None

            # 1) same box
            value_str = _extract_number_str(itm.get("text", ""))
            value_num = _parse_tr_number(value_str) if value_str else None
            if value_num is None:
                # 2) right neighbor on same line
                cand = _nearest_value_on_right(items, i, max_dx=max_dx, line_tol=line_tol)
                if cand is not None:
                    value_txt = items[cand].get("text", "")
                    value_bbox = items[cand]["bbox"]
                    value_str  = _extract_number_str(value_txt)
                    value_num  = _parse_tr_number(value_str) if value_str else None

                # 3) fallback to next/prev in reading order
                if value_num is None:
                    k = pos[i]
                    neigh = []
                    if k + 1 < len(order): neigh.append(order[k + 1])
                    if k - 1 >= 0:         neigh.append(order[k - 1])
                    for j in neigh:
                        if _has_digits(items[j].get("text", "")):
                            value_txt = items[j].get("text", "")
                            value_bbox = items[j]["bbox"]
                            value_str  = _extract_number_str(value_txt)
                            value_num  = _parse_tr_number(value_str) if value_str else None
                            if value_num is not None:
                                break

            # default texts if we only had the label itself
            if value_txt is None and value_str is not None:
                value_txt = itm.get("text", "")
                value_bbox = label_bbox

            rows.append({
                "page_idx":   pidx,
                "label_text": itm.get("text", ""),
                "label_bbox": label_bbox,
                "value_text": value_txt,
                "value_bbox": value_bbox,
                "value_str":  value_str,
                "value_num":  value_num,
            })

    sermaye_df = pd.DataFrame(rows)

    # If caller doesn't provide bottom_df, just return extracted table.
    if bottom_df is None:
        return sermaye_df

    # Merge policy: keep the highest value per page (typical for capital amounts)
    if sermaye_df.empty or sermaye_df["value_num"].dropna().empty:
        return bottom_df

    best = (sermaye_df.dropna(subset=["value_num"])
                      .sort_values(["page_idx", "value_num"], ascending=[True, False])
                      .groupby("page_idx", as_index=False)
                      .first()[["page_idx", "value_num", "value_bbox"]]
                      .rename(columns={"value_num": "sermaye_value", "value_bbox": "sermaye_bbox"}))

    # align/merge by page_idx
    if "page_idx" not in bottom_df.columns:
        # make a minimal index if needed
        bottom_df = bottom_df.copy()
        bottom_df["page_idx"] = 0

    merged = bottom_df.merge(best, on="page_idx", how="left")
    return merged

# If you want the extracted table only:
sermaye_df = extract_and_merge_sermaye(pages_scaled)

# If you want it merged into your existing bottom_df:
bottom_df = extract_and_merge_sermaye(pages_scaled, bottom_df=bottom_df)