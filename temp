import cv2
import numpy as np

def close_table_line_gaps(
    table_bin: np.ndarray,
    horiz_frac: float = 0.20,
    vert_frac: float = 0.20,
    close_iters: int = 2,
    dilate_iters: int = 1,
) -> np.ndarray:
    """
    Tablo gridindeki yatay/dikey çizgi kopukluklarını kapatır ve çizgileri kalınlaştırır.
    Çıktı: 0/255 tek kanallı grid maskesi (yazılar mümkün olduğunca atılır).

    Parametreler:
        table_bin  : Binarize tablo görüntüsü (H×W, 0/255 veya 3 kanallı).
        horiz_frac : Genişliğin hangi oranı yatay kernel uzunluğu olsun (0.1–0.3 arası tipik).
        vert_frac  : Yüksekliğin hangi oranı dikey kernel uzunluğu olsun.
        close_iters: Closing (erode+ dilate) tekrar sayısı – kopukluk kapatma agresifliği.
        dilate_iters: Son kalınlaştırma adımında kullanılacak dilate iterasyonu.
    """

    # 1) Gri + tek kanal
    if len(table_bin.shape) == 3:
        gray = cv2.cvtColor(table_bin, cv2.COLOR_BGR2GRAY)
    else:
        gray = table_bin.copy()

    # 2) Kesin binarizasyon (0-255)
    #   Tablo zaten binarize ise fazla etkilemez ama garanti olur.
    _, bw = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # 3) Çizgileri beyaz (255), arka planı siyah (0) yap (morfoloji için daha rahat)
    #   Eğer zaten bu formattaysa invert fazla etkilemez.
    white_ratio = (bw == 255).mean()
    if white_ratio < 0.5:
        # Çoğunluk siyah ise muhtemelen çizgiler + yazılar siyah, invert et.
        imv = 255 - bw
    else:
        imv = bw.copy()

    h, w = imv.shape

    # 4) Kernel uzunluklarını görüntü boyutuna göre dinamik ayarla
    #    Çok küçük olmaması için min 15 piksel koyuyoruz.
    horiz_kernel_len = max(int(w * horiz_frac), 15)
    vert_kernel_len  = max(int(h * vert_frac), 15)

    horiz_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (horiz_kernel_len, 1))
    vert_kernel  = cv2.getStructuringElement(cv2.MORPH_RECT, (1, vert_kernel_len))

    # 5) Yatay çizgi maskesi: erode -> dilate (closing benzeri)
    horiz_lines = cv2.erode(imv, horiz_kernel, iterations=1)
    horiz_lines = cv2.dilate(horiz_lines, horiz_kernel, iterations=close_iters)

    # 6) Dikey çizgi maskesi
    vert_lines = cv2.erode(imv, vert_kernel, iterations=1)
    vert_lines = cv2.dilate(vert_lines, vert_kernel, iterations=close_iters)

    # 7) Yatay + dikey birleştir, tekrar closing ile kopuklukları iyice kapat
    grid = cv2.bitwise_or(horiz_lines, vert_lines)

    # Hafif closing (küçük boşlukları kapatmak için)
    grid = cv2.morphologyEx(
        grid,
        cv2.MORPH_CLOSE,
        cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3)),
        iterations=1,
    )

    # 8) Çizgileri biraz kalınlaştır (ince çizgiler de kalınlaşsın)
    if dilate_iters > 0:
        thicken_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
        grid = cv2.dilate(grid, thicken_kernel, iterations=dilate_iters)

    # 9) Maskeyi 0/255 aralığında döndür
    grid = np.clip(grid, 0, 255).astype(np.uint8)

    return grid

closed_line_masks = [
    close_table_line_gaps(
        img,
        horiz_frac=0.18,   # çok kopukluk varsa 0.25–0.30'a çıkar
        vert_frac=0.18,
        close_iters=2,     # kopukluk kapanmıyorsa 3–4 deneyebilirsin
        dilate_iters=1     # çizgiler hâlâ inceyse 2 yap
    )
    for img in binarized_tables
]

# Kontrol için plot
for i, img in enumerate(closed_line_masks):
    plt.figure(figsize=(6, 8))
    plt.title(f"Table {i} (closed grid)")
    plt.imshow(img, cmap="gray")
    plt.axis("off")
    plt.show()