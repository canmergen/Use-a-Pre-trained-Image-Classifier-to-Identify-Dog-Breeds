import cv2
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, Optional

def return_binary_mask(
    table: np.ndarray,
    ver_kernels: Optional[Tuple[int, int]] = None,
    hor_kernels: Optional[Tuple[int, int]] = None,
    hor_erode_iter: int = 2,
    ver_erode_iter: int = 1,
    handle_inv: bool = True,
    min_cov_h: float = 0.4,
    min_cov_v: float = 0.4,
    min_gap_frac: float = 0.015,
    compact_ratio: float = 0.5,
    v_proj_top_frac: float = 0.7,   # dikey projeksiyon için üst band
    debug: bool = False,
):
    """
    Çıktı:
      binary_lines      : yatay+dikey çizgi maskesi
      binary_horizontal : yatay çizgi maskesi
      binary_vertical   : dikey çizgi maskesi
      rows_y            : grid yatay eksenleri (üst+ara+alt)
      cols_x            : grid dikey eksenleri (sol+ara+sağ)
    """

    # ----------------- yardımcılar -----------------

    def add_borders(img: np.ndarray, border: int = 2) -> np.ndarray:
        img[:border, :] = 255
        img[-border:, :] = 255
        img[:, :border] = 255
        img[:, -border:] = 255
        return img

    def extract_axes_from_mask(mask: np.ndarray,
                               axis: str,
                               min_coverage: float,
                               min_gap_px: int,
                               title: str = "",
                               dbg: bool = False) -> np.ndarray:
        """
        1D projeksiyon ile eksen merkezlerini bulur.
        axis = 'h' -> satır eksenleri (y)
        axis = 'v' -> sütun eksenleri (x)
        """
        H, W = mask.shape

        if axis == "h":
            proj = mask.sum(axis=1) / (255.0 * max(1, W))
            length = H
        else:
            proj = mask.sum(axis=0) / (255.0 * max(1, H))
            length = W

        is_line = proj > min_coverage

        centers = []
        i = 0
        while i < length:
            if not is_line[i]:
                i += 1
                continue
            j = i + 1
            while j < length and is_line[j]:
                j += 1
            c = (i + j - 1) // 2
            centers.append(c)
            i = j

        merged = []
        for c in centers:
            if not merged or c - merged[-1] >= min_gap_px:
                merged.append(c)
            else:
                merged[-1] = int((merged[-1] + c) / 2)

        merged = np.array(merged, dtype=int)

        if dbg:
            xs = np.arange(length)
            plt.figure(figsize=(10, 3))
            plt.plot(xs, proj, label="projection")
            if len(merged) > 0:
                plt.scatter(merged, proj[merged], c="red", s=30, label="axes")
            plt.title(title)
            plt.legend()
            plt.tight_layout()
            plt.show()

        return merged

    def merge_dense_axes(axes: np.ndarray,
                         ratio: float,
                         full_length: int) -> np.ndarray:
        """
        Çok yakın eksenleri gap dağılımına + mutlak eşiğe göre birleştirir.
        Ayrıca sağ taraftaki imza bölgesinde en fazla 2 eksen bırakır.
        """
        if axes is None or len(axes) <= 2:
            return axes

        gaps = np.diff(axes).astype(float)
        valid = gaps[gaps > 0]
        if len(valid) == 0:
            return axes

        q1 = np.percentile(valid, 25)
        median = np.median(valid)

        # sayfa genişliğinin %2'si: sadece çok dar aralıklara izin
        abs_thresh = 0.02 * full_length
        thresh = min(q1, median * ratio, abs_thresh)

        merged = [axes[0]]
        for dx, x in zip(gaps, axes[1:]):
            if dx < thresh:
                merged[-1] = int((merged[-1] + x) / 2)
            else:
                merged.append(x)
        merged = np.array(merged, dtype=int)

        # --- sağ uç için ek kontrol (imza sütunu alanı) ---
        # sağ bölge: genişliğin son %18'i
        right_start = int(0.82 * full_length)
        right_idx = np.where(merged >= right_start)[0]
        if len(right_idx) > 2:
            left_sig = merged[right_idx[0]]
            right_sig = merged[right_idx[-1]]
            keep_mask = merged < right_start
            merged = np.concatenate([merged[keep_mask],
                                     np.array([left_sig, right_sig])])
            merged = np.sort(merged)

        return np.array(merged, dtype=int)

    # ----------------- 1) gri + threshold -----------------

    if table.ndim == 3:
        gray = cv2.cvtColor(table, cv2.COLOR_BGR2GRAY)
    else:
        gray = table.copy()

    _, binary = cv2.threshold(gray, 240, 255, cv2.THRESH_BINARY_INV)
    binary = add_borders(binary)

    H, W = binary.shape[:2]

    # ----------------- 2) kernel boyutları -----------------

    if hor_kernels is None:
        kw = max(25, W // 20)
        hor_kernels = (kw, 1)

    if ver_kernels is None:
        kh = max(25, H // 20)
        ver_kernels = (1, kh)

    kernel_hor = cv2.getStructuringElement(cv2.MORPH_RECT, hor_kernels)
    kernel_ver = cv2.getStructuringElement(cv2.MORPH_RECT, ver_kernels)

    # ----------------- 3) yatay / dikey çizgiler -----------------

    binary_horizontal = cv2.erode(binary, kernel_hor, iterations=hor_erode_iter)
    binary_horizontal = cv2.dilate(binary_horizontal, kernel_hor, iterations=20)

    binary_vertical = cv2.erode(binary, kernel_ver, iterations=ver_erode_iter)
    binary_vertical = cv2.dilate(binary_vertical, kernel_ver, iterations=20)

    # ----------------- 4) sağ taraftaki anomalik kolon kırpma -----------------

    if handle_inv:
        inv_x_range = 0
        for x in range(W):
            if np.mean(binary_vertical[:, x]) == 0:
                inv_x_range = x
                break

        if inv_x_range >= W * 0.15:
            binary_vertical[:, :max(0, 2 * inv_x_range - 2)] = 0

    # ----------------- 5) birleşik maske -----------------

    binary_lines = cv2.addWeighted(binary_vertical, 0.5,
                                   binary_horizontal, 0.5, 0.0)

    # ----------------- 6) grid eksenleri -----------------

    min_gap_h = max(3, int(H * min_gap_frac))
    min_gap_v = max(3, int(W * min_gap_frac))

    rows_y = extract_axes_from_mask(
        binary_horizontal,
        axis="h",
        min_coverage=min_cov_h,
        min_gap_px=min_gap_h,
        title="Row projection",
        dbg=debug,
    )

    # Dikey projeksiyon için üst bandı kullan (imzayı baskılamak için)
    top_h = int(H * v_proj_top_frac)
    vert_for_proj = binary_vertical[:top_h, :]

    cols_x_raw = extract_axes_from_mask(
        vert_for_proj,
        axis="v",
        min_coverage=min_cov_v,
        min_gap_px=min_gap_v,
        title="Column projection (raw, top band)",
        dbg=debug,
    )

    cols_x = merge_dense_axes(cols_x_raw, ratio=compact_ratio, full_length=W)

    # ----------------- 7) DEBUG görselleştirme -----------------

    if debug:
        print(f"rows_y (len={len(rows_y)}): {rows_y}")
        print(f"cols_x_raw (len={len(cols_x_raw)}): {cols_x_raw}")
        print(f"cols_x_merged (len={len(cols_x)}): {cols_x}")

        # arka planı silik yapmak için griyi biraz aç
        bg = cv2.normalize(gray, None, 200, 255, cv2.NORM_MINMAX)
        vis = cv2.cvtColor(bg, cv2.COLOR_GRAY2BGR)

        # satırlar: yeşil, kalın
        for y in rows_y:
            cv2.line(vis, (0, y), (W - 1, y), (0, 255, 0), 4)

        # sütunlar: kırmızı, kalın
        for x in cols_x:
            cv2.line(vis, (x, 0), (x, H - 1), (255, 0, 0), 4)

        plt.figure(figsize=(8, 8))
        plt.title("Detected grid axes (over original)")
        plt.imshow(vis[:, :, ::-1])
        plt.axis('off')
        plt.tight_layout()
        plt.show()

    return binary_lines, binary_horizontal, binary_vertical, rows_y, cols_x

bin_lines, hmask, vmask, rows_y, cols_x = return_binary_mask(
    binarized_tables[i],
    debug=True
)
n_rows = len(rows_y) - 1
n_cols = len(cols_x) - 1
print(f"Page {i}: rows={n_rows}, cols={n_cols}")


for page_idx, table in enumerate(binarized_tables):
		all_bin_lines = []
		all_hmask    = []
		all_vmask    = []
		all_rows_y   = []   # her sayfa için horizontal line Y koordinatları
		all_cols_x   = []   # her sayfa için vertical line X koordinatları
		grid_info    = []   # özet bilgi (opsiyonel)
    bin_lines, hmask, vmask, rows_y, cols_x = return_binary_mask(
        table,
        debug=False,      # istersen burada kapat
        more_debug=False
    )

    n_rows = len(rows_y) - 1
    n_cols = len(cols_x) - 1
    print(f"Page {page_idx}: rows={n_rows}, cols={n_cols}")

    # maskeleri ve eksenleri sakla
    all_bin_lines.append(bin_lines)
    all_hmask.append(hmask)
    all_vmask.append(vmask)
    all_rows_y.append(rows_y)
    all_cols_x.append(cols_x)

    # özet struct (ileride işine yarar)
    grid_info.append({
        "page_index": page_idx,
        "rows_y": rows_y,
        "cols_x": cols_x,
        "n_rows": n_rows,
        "n_cols": n_cols,
    })
