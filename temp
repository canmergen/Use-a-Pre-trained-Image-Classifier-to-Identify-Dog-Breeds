import re, cv2, json, base64, unicodedata
import numpy as np
import pandas as pd
from typing import Any, List, Tuple, Dict, Optional
from rapidfuzz import fuzz, process

def build_per_box_df_v2(
    lower_img: np.ndarray,
    final_boxes: List[Any],
    *,
    sig_boxes: List[Any],
    role_blocks: List[Any],
    sermaye_boxes: List[Any],
    known_names: Optional[List[str]],
    ocr_url: str,
    lang: str = "tur+eng",
    role_threshold: float = 0.80,
    name_sim_threshold: float = 0.82,
) -> pd.DataFrame:
    """
    Final kutulardan per_box_df üretir (dinamik PSM/OEM, rol kelimelerini isimden temizleme,
    imza dahil olma kontrolü, isim çıkarımı için fallback OCR, TCKN yakalama).

    Çıktı kolonları:
      i, bbox, loc, sig, role_best, role_score, name_in_box, text_preview
    """

    # ---------------- utils: geometry ----------------
    def _to_xywh(b: Any) -> Optional[Tuple[int,int,int,int]]:
        if isinstance(b, (tuple, list, np.ndarray)) and len(b)==4:
            x,y,w,h = [int(round(float(v))) for v in b]; return (x,y,w,h)
        if isinstance(b, dict):
            if all(k in b for k in ("x","y","w","h")):
                return int(b["x"]), int(b["y"]), int(b["w"]), int(b["h"])
            if all(k in b for k in ("x0","y0","x1","y1")):
                return int(b["x0"]), int(b["y0"]), int(b["x1"]-b["x0"]), int(b["y1"]-b["y0"])
            if all(k in b for k in ("left","top","right","bottom")):
                return int(b["left"]), int(b["top"]), int(b["right"]-b["left"]), int(b["bottom"]-b["top"])
        return None

    def _to_xyxy(b: Any) -> Tuple[int,int,int,int]:
        x,y,w,h = _to_xywh(b)
        return (x, y, x+w, y+h)

    def _iou(a, b) -> float:
        ax1,ay1,ax2,ay2 = a; bx1,by1,bx2,by2 = b
        ix1,iy1 = max(ax1,bx1), max(ay1,by1)
        ix2,iy2 = min(ax2,bx2), min(ay2,by2)
        iw, ih = max(0, ix2-ix1), max(0, iy2-iy1)
        inter = iw * ih
        if inter == 0: return 0.0
        aarea = (ax2-ax1)*(ay2-ay1); barea = (bx2-bx1)*(by2-by1)
        return inter / (aarea + barea - inter + 1e-9)

    def _contains(outer, inner, pad=2) -> bool:
        ox1,oy1,ox2,oy2 = outer
        ix1,iy1,ix2,iy2 = inner
        return (ix1 >= ox1-pad) and (iy1 >= oy1-pad) and (ix2 <= ox2+pad) and (iy2 <= oy2+pad)

    def _any_overlap(a: Tuple[int,int,int,int], group: List[Tuple[int,int,int,int]]) -> bool:
        for g in group:
            if _iou(a, g) > 0 or _contains(a, g) or _contains(g, a):
                return True
        return False

    # ---------------- utils: text / roles / names ----------------
    def _strip_diac(s: str) -> str:
        return "".join(c for c in unicodedata.normalize("NFKD", s) if not unicodedata.combining(c))

    def _U(s: str) -> str:
        s = (s or "").upper()
        return re.sub(r"\s+"," ",_strip_diac(s)).strip()

    ROLE_ALIASES: Dict[str, List[str]] = {
        "toplanti_baskani":    ["TOPLANTI BAŞKANI","TOPLANTI BASKANI"],
        "yk_baskani":          ["YÖNETİM KURULU BAŞKANI","YONETIM KURULU BASKANI","YK BAŞKANI","YK BASKANI"],
        "yk_uyesi":            ["YÖNETİM KURULU ÜYESİ","YONETIM KURULU UYESI","YK ÜYESİ","YK UYESI","YÖNETİM KURULU ÜYELERİ"],
        "bakanlik_temsilcisi": ["BAKANLIK TEMSİLCİSİ","TİCARET BAKANLIĞI TEMSİLCİSİ","TICARET BAKANLIGI TEMSILCISI"],
        "katip":               ["KÂTİP","KATİP","OY TOPLAMA MEMURU","OY TOPLAYICI"],
        "divan_baskani":       ["DİVAN BAŞKANI","DIVAN BASKANI"],
        "tutanak_yazmani":     ["TUTANAK YAZMANI","YAZMAN"],
    }
    ROLE_PRIORITY = ["toplanti_baskani","yk_baskani","yk_uyesi","bakanlik_temsilcisi","katip","divan_baskani","tutanak_yazmani"]

    # rol kelimeleri: isim temizlemede kullanılacak
    ROLE_TOKENS = set(sum([a.split() for v in ROLE_ALIASES.values() for a in v], [])) | {
        "YÖNETİM","KURULU","ÜYE","ÜYESİ","ÜYELERİ","BAŞKAN","BAŞKANI","KATİP","KÂTİP",
        "DİVAN","OY","TOPLAMA","MEMURU","TEMSİLCİSİ","BAKANLIK","YAZMAN","İMZA","IMZA","KAŞE","MÜHÜR","STAMP"
    }

    def best_role_for_text(text: str) -> Tuple[Optional[str], float]:
        tU = _U(text)
        def _alias_score(ali: str) -> float:
            return fuzz.token_set_ratio(tU, _U(ali)) / 100.0
        best_role, best_score = None, 0.0
        for rk, aliases in ROLE_ALIASES.items():
            sc = max(_alias_score(a) for a in aliases)
            if (sc > best_score) or (abs(sc-best_score) < 1e-6 and (best_role is None or ROLE_PRIORITY.index(rk) < ROLE_PRIORITY.index(best_role))):
                best_role, best_score = rk, sc
        return best_role, best_score

    def remove_role_words(text: str) -> str:
        # rol/ünvan kelimelerini düşür
        toks = re.findall(r"[A-Za-zÇĞİÖŞÜçğıöşü’']+", text)
        toks_clean = [t for t in toks if _U(t) not in ROLE_TOKENS]
        return " ".join(toks_clean)

    def raw_name_candidates(text: str) -> List[str]:
        # segmentlere ayır ve 3-gram / 2-gram üret
        t = text.replace("\n"," ")
        segs = [p.strip() for p in re.split(r"\s*(?:[,;/]| ve )\s*", t, flags=re.IGNORECASE) if p.strip()]
        cands: List[str] = []
        for seg in segs:
            toks = re.findall(r"[A-Za-zÇĞİÖŞÜçğıöşü’']+", seg)
            if not toks: continue
            n = len(toks)
            for L in (3,2):
                for i in range(max(0, n-L+1)):
                    cands.append(" ".join(toks[i:i+L]))
            if n == 1:
                cands.append(toks[0])
        # tekilleştir
        return list(dict.fromkeys(cands))

    def map_to_known(name: str, pool: List[str]) -> Optional[str]:
        if not pool: return None
        best = process.extractOne(name, pool, scorer=fuzz.token_set_ratio)
        if best and best[1] >= name_sim_threshold*100:
            return best[0]
        # tek ad benzersizse tam ada yükselt
        toks = name.split()
        if len(toks) == 1:
            first = _U(toks[0])
            by_first: Dict[str, List[str]] = {}
            for kn in pool:
                ts = kn.split()
                if ts: by_first.setdefault(_U(ts[0]), []).append(kn)
            vals = by_first.get(first, [])
            if len(vals) == 1:
                return vals[0]
        return None

    def pick_name_from_text(text: str, known_pool: List[str]) -> Optional[str]:
        text_wo_role = remove_role_words(text)
        cands = raw_name_candidates(text_wo_role)
        chosen: List[str] = []
        seen = set()
        for c in cands:
            mapped = map_to_known(c, known_pool)
            name = mapped or c
            if name not in seen:
                seen.add(name)
                chosen.append(name)
        return "; ".join(chosen) if chosen else None

    def find_tckn(text: str) -> Optional[str]:
        # 10 veya 11 haneli ardışık rakam; başında/sonunda harf yok
        m = re.findall(r"(?<!\d)(\d{10,11})(?!\d)", text.replace(" ", ""))
        if not m: return None
        # benzersiz sırayı koru
        return "; ".join(list(dict.fromkeys(m)))

    # ---------------- utils: OCR ----------------
    def _ocr_crop(img_bgr: np.ndarray, xywh: Tuple[int,int,int,int], psm: int, oem: int) -> str:
        x,y,w,h = xywh
        crop = img_bgr[max(0,y):y+h, max(0,x):x+w]
        if crop.size == 0: return ""
        ok, buf = cv2.imencode(".png", crop)
        if not ok: return ""
        payload = {
            "image_b64": base64.b64encode(buf.tobytes()).decode("ascii"),
            "lang": lang,
            "psm": int(psm),
            "oem": int(oem),
        }
        try:
            import requests
            r = requests.post(ocr_url, data=json.dumps(payload), headers={"Content-Type":"application/json"}, timeout=30)
            r.raise_for_status()
            js = r.json()
            return (js.get("text") or "").strip()
        except Exception:
            return ""

    # dinamik PSM/OEM seçici
    def decide_psm_oem(loc: str) -> Tuple[int,int]:
        if loc == "sermaye":
            return 1, 1       # blok/paragrafik metinler için burada iyi çalışıyor
        if loc == "roles":
            return 11, 1      # sparse text: rol başlık/isim satırı karışık olabilir
        return 11, 1          # default

    # ---------------- prepare boxes ----------------
    final_xywh = [b for b in (_to_xywh(b) for b in final_boxes) if b is not None and b[2]>0 and b[3]>0]
    final_xyxy = [_to_xyxy(b) for b in final_xywh]
    sig_xyxy   = [_to_xyxy(b) for b in (sig_boxes or [])]
    role_xyxy  = [_to_xyxy(b) for b in (role_blocks or [])]
    serm_xyxy  = [_to_xyxy(b) for b in (sermaye_boxes or [])]
    known_pool = list(dict.fromkeys([(known_names or [])]))

    # ---------------- main loop ----------------
    rows = []
    for i, (b_wh, b_xyxy) in enumerate(zip(final_xywh, final_xyxy)):
        # loc tespiti
        loc = "roles" if _any_overlap(b_xyxy, role_xyxy) else ("sermaye" if _any_overlap(b_xyxy, serm_xyxy) else "other")

        # imza: sig_box az da olsa dahil mi?
        sig = any(_contains(b_xyxy, s, pad=2) or _iou(b_xyxy, s) >= 0.02 for s in sig_xyxy)

        # ilk OCR (loc'a göre)
        psm0, oem0 = decide_psm_oem(loc)
        text0 = _ocr_crop(lower_img, b_wh, psm=psm0, oem=oem0)
        text_preview = re.sub(r"\s+"," ",text0)[:200]

        # rol skoru/ata
        role_key, role_score = best_role_for_text(text0)
        role_best = role_key if (role_score >= role_threshold or loc=="roles") else None

        # isim çıkarımı – 1. deneme
        name1 = pick_name_from_text(text0, known_names or [])

        # TCKN var mı?
        tckn0 = find_tckn(text0)

        # isim yoksa veya çok zayıfsa fallback OCR (psm=1,oem=1) ile tekrar dene
        need_fallback = (not name1) or (name1 and known_names and max((fuzz.token_set_ratio(name1, k) for k in known_names), default=0) < name_sim_threshold*100)
        if need_fallback:
            text1 = _ocr_crop(lower_img, b_wh, psm=1, oem=1)
            if text1 and (len(text1) > len(text0) or not name1):
                # daha iyi olabilir → role yeniden değerlendir, isim yeniden çıkar
                role_key2, role_score2 = best_role_for_text(text1)
                if role_score2 > role_score:
                    role_key, role_score = role_key2, role_score2
                    role_best = role_key if (role_score >= role_threshold or loc=="roles") else role_best
                name2 = pick_name_from_text(text1, known_names or [])
                if name2: name1 = name2
                tckn1 = find_tckn(text1)
                if tckn1: tckn0 = tckn0 + ("; "+tckn1 if tckn0 else tckn1)
                # preview olarak daha okunaklı olanı kullan
                if len(text1) > len(text0):
                    text_preview = re.sub(r"\s+"," ",text1)[:200]

        # name_in_box'e TCKN ekle
        if tckn0:
            name_in_box = (name1 + " | " + tckn0) if name1 else tckn0
        else:
            name_in_box = name1

        rows.append({
            "i": i,
            "bbox": b_wh,
            "loc": loc,
            "sig": bool(sig),
            "role_best": role_best,
            "role_score": float(role_score),
            "name_in_box": name_in_box,
            "text_preview": text_preview
        })

    per_box_df = pd.DataFrame(rows, columns=["i","bbox","loc","sig","role_best","role_score","name_in_box","text_preview"])
    return per_box_df