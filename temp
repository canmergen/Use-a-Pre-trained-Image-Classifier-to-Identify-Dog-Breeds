from typing import List, Tuple, Optional, Dict, Set

def build_final_boxes_onceall(
    role_boxes: List[Tuple[int,int,int,int]],          # [(x,y,w,h)]
    sig_boxes:  List[Tuple[int,int,int,int]],          # [(x,y,w,h)]
    sermaye_boxes: Optional[List[Tuple[int,int,int,int]]] = None,
    *,
    require_x_overlap: float = 0.20,       # rol–imza min X-örtüşme (min(width) bazında)
    stop_x_overlap: float = 0.12,          # koridorda başka rol tespiti için min X-örtüşme
    max_vertical_gap: Optional[int] = 120, # None: sınırsız
    dedup_near_px: int = 2                 # kategori-içi tekilleştirme toleransı
) -> Dict[str, List[Tuple[int,int,int,int]]]:

    # ---------- helpers ----------
    Box = Tuple[int,int,int,int]
    LTRB = Tuple[int,int,int,int]

    def to_ltrb(b: Box) -> LTRB:
        x,y,w,h = b; return (int(x), int(y), int(x+w), int(y+h))

    def to_xywh(b: LTRB) -> Box:
        l,t,r,bm = b; return (int(l), int(t), int(r-l), int(bm-t))

    def w(b: LTRB) -> int: return max(0, b[2]-b[0])
    def h(b: LTRB) -> int: return max(0, b[3]-b[1])

    def union(a: LTRB, b: LTRB) -> LTRB:
        return (min(a[0],b[0]), min(a[1],b[1]), max(a[2],b[2]), max(a[3],b[3]))

    def inter(a: LTRB, b: LTRB) -> Optional[LTRB]:
        l, t = max(a[0], b[0]), max(a[1], b[1])
        r, bm = min(a[2], b[2]), min(a[3], b[3])
        return (l,t,r,bm) if (r>l and bm>t) else None

    def intersects(a: LTRB, b: LTRB) -> bool:
        return not (a[2] <= b[0] or b[2] <= a[0] or a[3] <= b[1] or b[3] <= a[1])

    def inter_w(a: LTRB, b: LTRB) -> int:
        return max(0, min(a[2],b[2]) - max(a[0],b[0]))

    def x_overlap_ratio(a: LTRB, b: LTRB) -> float:
        iw = inter_w(a,b)
        if iw <= 0: return 0.0
        return iw / float(max(1, min(w(a), w(b))))

    def corridor(role: LTRB, sig: LTRB) -> Optional[LTRB]:
        # role.bottom → sig.top aralığı ve ortak X bandı
        if sig[1] < role[3]: return None
        l, r = max(role[0], sig[0]), min(role[2], sig[2])
        if r <= l: return None
        return (l, role[3], r, sig[1])

    def corridor_blocked(corr: LTRB, other_role: LTRB, th: float) -> bool:
        # Koridor Y bandı ile rol Y bandı kesişiyor ve X-örtüşme yeterli mi?
        y_hit = not (other_role[3] <= corr[1] or other_role[1] >= corr[3])
        if not y_hit: return False
        xo = x_overlap_ratio((corr[0],0,corr[2],1), (other_role[0],0,other_role[2],1))
        return xo >= th

    def contains(big: LTRB, small: LTRB) -> bool:
        return (big[0] <= small[0] and big[1] <= small[1] and
                big[2] >= small[2] and big[3] >= small[3])

    def dedup_in_category(boxes: List[LTRB], tol: int = 2) -> List[LTRB]:
        if not boxes: return []
        boxes = boxes[:]
        changed = True
        while changed:
            changed = False
            out: List[LTRB] = []
            used = [False]*len(boxes)
            for i in range(len(boxes)):
                if used[i]: continue
                a = boxes[i]
                for j in range(i+1, len(boxes)):
                    if used[j]: continue
                    b = boxes[j]
                    touch = not (a[2] < b[0]-tol or b[2] < a[0]-tol or
                                 a[3] < b[1]-tol or b[3] < a[1]-tol)
                    if touch:
                        a = union(a,b)
                        used[j] = True
                        changed = True
                out.append(a); used[i] = True
            boxes = out
        return boxes

    # ---------- normalize ----------
    roles: List[LTRB] = [to_ltrb(b) for b in (role_boxes or [])]
    sigs:  List[LTRB] = [to_ltrb(b) for b in (sig_boxes  or [])]
    serm:  List[LTRB] = [to_ltrb(b) for b in (sermaye_boxes or [])]

    # (ÖN FİLTRE) Zaten rol/sermaye kutularının İÇİNDE kalan imzaları aday listesinden çıkar
    if roles or serm:
        containers0 = roles + serm
        sigs = [s for s in sigs if not any(contains(k, s) for k in containers0)]

    used_roles: Set[int] = set()
    used_sigs:  Set[int] = set()
    pairs: List[Tuple[int,int]] = []

    unions: List[LTRB] = []      # rol∪imza
    roles_left: List[LTRB] = []  # union’a girmeyen roller
    sigs_left:  List[LTRB] = []  # union’a girmeyen imzalar (kural gereği sonradan drop)

    # ---------- rol→imza eşleştirme (koridor engelli) ----------
    for ri, rb in enumerate(roles):
        best = None  # (score, si, union_ltrb)
        for si, sb in enumerate(sigs):
            if si in used_sigs: 
                continue
            if sb[1] < rb[3]:
                continue
            if max_vertical_gap is not None and (sb[1] - rb[3]) > max_vertical_gap:
                continue
            if x_overlap_ratio(rb, sb) < require_x_overlap:
                continue

            cor = corridor(rb, sb)
            if cor is None:
                continue

            # koridorda başka rol var mı? → blokla
            if any(corridor_blocked(cor, other, stop_x_overlap) 
                   for rj, other in enumerate(roles) if rj != ri):
                continue

            u = union(rb, sb)
            score = (x_overlap_ratio(rb, sb), -(sb[1]-rb[3]), -h(sb))
            if (best is None) or (score > best[0]):
                best = (score, si, u)

        if best:
            _, si, u = best
            unions.append(u); used_roles.add(ri); used_sigs.add(si)
            pairs.append((ri, si))

    # ---------- kalanlar ----------
    for ri, rb in enumerate(roles):
        if ri not in used_roles:
            roles_left.append(rb)
    for si, sb in enumerate(sigs):
        if si not in used_sigs:
            sigs_left.append(sb)

    # ---------- kategori-içi tekilleştirme ----------
    unions     = dedup_in_category(unions,     dedup_near_px)
    roles_left = dedup_in_category(roles_left, dedup_near_px)
    serm       = dedup_in_category(serm,       dedup_near_px)

    # ---------- contain-or-drop: leftover imzalar ----------
    # Kural: imza tek başınaysa drop; başka kutu içindeyse de drop (büyük kutu kalır).
    # Bu nedenle sigs_left listeyi tamamen boşaltıyoruz.
    sigs_left = []

    # ---------- final ----------
    final_l = unions + roles_left + serm
    return {
        "final":   [to_xywh(b) for b in final_l],
        "pairs":   pairs,
        "roles":   [to_xywh(b) for b in roles_left],
        "sigs":    [],  # kural gereği leftover imzalar droplandı
        "sermaye": [to_xywh(b) for b in serm],
    }