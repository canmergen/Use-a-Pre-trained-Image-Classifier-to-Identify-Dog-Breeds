def process_all_tables(
    res,
    auto_percentile: int = 90,
    use_tight_crop: bool = True,
    min_area_ratio: float = 0.25,
    extra_margin_px: int = 4,
    ver_kernel_ratio: float = 0.35,
    hor_kernel_ratio: float = 0.15,
    ver_erode_iter: int = 2,
    ver_dilate_iter: int = 20,
    hor_erode_iter: int = 1,
    hor_dilate_iter: int = 20,
    thin_dilate_size: int = 3,
    thin_dilate_iter: int = 3,
):
    """
    res: 
        - [{ 'table_bw': img, ... }, ...]  veya 
        - [img1, img2, ...]  (np.ndarray listesi)

    Çıktı:
        - binarized_tables: [np.ndarray, ...] -> arka plan beyaz, çizgiler kalın siyah
    """
    import cv2
    import numpy as np

    # ----------------------- #
    #  STRICT BINARIZATION
    # ----------------------- #
    def _binarize_strict_white(img: np.ndarray, auto_percentile: int = 90) -> np.ndarray:
        if img.ndim == 3:
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        else:
            gray = img.copy()

        gmin, gmax = float(gray.min()), float(gray.max())
        if gmax - gmin < 1e-6:
            return np.full_like(gray, 255, dtype=np.uint8)

        # Normalize dinamik aralık
        gray = np.clip((gray - gmin) * (255.0 / (gmax - gmin)), 0, 255).astype(np.uint8)

        p1 = np.percentile(gray, 1)
        p2 = np.percentile(gray, auto_percentile)
        if p2 - p1 < 1:
            p2 = p1 + 1

        gray = np.clip((gray - p1) * (255.0 / (p2 - p1)), 0, 255).astype(np.uint8)

        blur = cv2.GaussianBlur(gray, (3, 3), 0)
        _, bin_img = cv2.threshold(
            blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU
        )
        return bin_img

    # ----------------------- #
    #  SIKI TABLO KIRPMA
    # ----------------------- #
    def _tight_table_crop(
        rectified_bgr: np.ndarray,
        min_area_ratio: float = 0.25,
        extra_margin_px: int = 4,
    ):
        H, W = rectified_bgr.shape[:2]

        if rectified_bgr.ndim == 3:
            gray = cv2.cvtColor(rectified_bgr, cv2.COLOR_BGR2GRAY)
        else:
            gray = rectified_bgr.copy()

        # Zemin normalize + median + otsu (ızgarayı belirginleştir)
        gray = cv2.normalize(gray, None, 0, 255, cv2.NORM_MINMAX)
        gray = cv2.medianBlur(gray, 3)
        _, bin_inv = cv2.threshold(
            gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU
        )

        # Grid için dikey/yatay maskeler
        ky = max(25, H // 30)
        kx = max(25, W // 25)
        vmask = cv2.morphologyEx(
            bin_inv,
            cv2.MORPH_OPEN,
            cv2.getStructuringElement(cv2.MORPH_RECT, (1, ky)),
            iterations=1,
        )
        hmask = cv2.morphologyEx(
            bin_inv,
            cv2.MORPH_OPEN,
            cv2.getStructuringElement(cv2.MORPH_RECT, (kx, 1)),
            iterations=1,
        )
        grid = cv2.bitwise_or(vmask, hmask)
        grid = cv2.morphologyEx(
            grid,
            cv2.MORPH_CLOSE,
            cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5)),
            iterations=2,
        )

        cnts, _ = cv2.findContours(grid, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if not cnts:
            return rectified_bgr, (0, 0, W, H)

        c = max(cnts, key=cv2.contourArea)
        if cv2.contourArea(c) < (min_area_ratio * W * H):
            return rectified_bgr, (0, 0, W, H)

        x, y, w, h = cv2.boundingRect(c)

        x0 = max(0, x - extra_margin_px)
        y0 = max(0, y - extra_margin_px)
        x1 = min(W, x + w + extra_margin_px)
        y1 = min(H, y + h + extra_margin_px)

        cropped = rectified_bgr[y0:y1, x0:x1].copy()
        return cropped, (x0, y0, x1, y1)

    # ----------------------- #
    #  UZUN ÇİZGİ MASKESİ
    # ----------------------- #
    def _long_line_mask(bin_img: np.ndarray) -> np.ndarray:
        # bin_img: arka plan beyaz (255), metin+çizgi siyah (0)
        inv = cv2.bitwise_not(bin_img)  # 255 = foreground (metin+çizgi)

        h, w = inv.shape
        ver_len = max(20, int(h * ver_kernel_ratio))
        hor_len = max(20, int(w * hor_kernel_ratio))

        kernel_ver = cv2.getStructuringElement(cv2.MORPH_RECT, (1, ver_len))
        kernel_hor = cv2.getStructuringElement(cv2.MORPH_RECT, (hor_len, 1))

        # Dikey
        v = cv2.erode(inv, kernel_ver, iterations=ver_erode_iter)
        v = cv2.dilate(v, kernel_ver, iterations=ver_dilate_iter)

        # Yatay
        hmask = cv2.erode(inv, kernel_hor, iterations=hor_erode_iter)
        hmask = cv2.dilate(hmask, kernel_hor, iterations=hor_dilate_iter)

        merged = cv2.addWeighted(v, 0.5, hmask, 0.5, 0)

        # Uzun çizgiler için maske: 0 = çizgi, 255 = zemin
        long_mask = cv2.bitwise_not(merged)
        return long_mask

    # ----------------------- #
    #  KISA / İNCE ÇİZGİ MASKESİ
    # ----------------------- #
    def _thin_line_mask(
        bin_img: np.ndarray, size: int = 3, iterations: int = 3
    ) -> np.ndarray:
        # ximgproc varsa thinning kullan, yoksa fallback
        try:
            thin = cv2.ximgproc.thinning(bin_img)
        except Exception:
            thin = cv2.erode(bin_img, np.ones((3, 3), np.uint8), iterations=2)

        k = cv2.getStructuringElement(cv2.MORPH_RECT, (size, size))
        thick = cv2.dilate(thin, k, iterations=iterations)

        short_mask = cv2.bitwise_not(thick)  # 0 = çizgi, 255 = zemin
        return short_mask

    # ----------------------- #
    #  ANA DÖNGÜ
    # ----------------------- #
    binarized_tables = []

    # res dict list mi, direkt img list mi?
    if isinstance(res, (list, tuple)):
        iterable = res
    else:
        iterable = [res]

    for r in iterable:
        if isinstance(r, dict):
            table = (
                r.get("table_bw")
                or r.get("table")
                or r.get("image")
                or r.get("img")
            )
        else:
            table = r

        if table is None:
            continue

        # 1) İsteğe bağlı sıkı kırpma
        if use_tight_crop:
            table, _ = _tight_table_crop(
                table,
                min_area_ratio=min_area_ratio,
                extra_margin_px=extra_margin_px,
            )

        # 2) Sert binarizasyon (arka plan beyaz, içerik siyah)
        bin_img = _binarize_strict_white(table, auto_percentile=auto_percentile)

        # 3) Uzun çizgi maskesi
        long_mask = _long_line_mask(bin_img)

        # 4) Kısa / ince çizgi maskesi
        short_mask = _thin_line_mask(
            bin_img, size=thin_dilate_size, iterations=thin_dilate_iter
        )

        # 5) Maskeleri birleştir (çizgi = 0, zemin = 255)
        combined_mask = cv2.bitwise_and(long_mask, short_mask)

        # 6) Maske sadece çizgilere dokunsun, metne dokunma:
        final = bin_img.copy()
        # Çizgi olması gereken yerde siyah zorla
        final[combined_mask == 0] = 0

        binarized_tables.append(final)

    return binarized_tables


binarized_tables = process_all_tables(
    res,
    ver_kernel_ratio=0.4,
    hor_kernel_ratio=0.2,
    ver_dilate_iter=25,
    hor_dilate_iter=25,
    thin_dilate_size=3,
    thin_dilate_iter=4,
)

for i, img in enumerate(binarized_tables):
    plt.figure(figsize=(10, 4))
    plt.title(f"Table {i}")
    plt.imshow(img, cmap="gray")
    plt.axis("off")
    plt.show()

