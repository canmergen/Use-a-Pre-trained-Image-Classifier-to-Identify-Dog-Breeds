import cv2
import numpy as np
from typing import List, Dict, Any, Optional

# ---------------------------------------------------------------------
# 1) İnce çizgileri koruyan lokal binarizasyon (K=2 K-means)
# ---------------------------------------------------------------------
def binarize_preserve_lines(gray: np.ndarray) -> np.ndarray:
    """
    Tablo bölgesini, global threshold yerine K-means (K=2) ile
    binarize eder. Koyu cluster mürekkep (0), açık cluster arka plan (255).

    Girdi:
        gray : (H, W) uint8
    Çıktı:
        bw   : (H, W) uint8, 0=ink, 255=background
    """
    if gray.ndim == 3:
        gray = cv2.cvtColor(gray, cv2.COLOR_BGR2GRAY)

    # K-means öncesi normalize
    norm = cv2.normalize(gray, None, 0, 255, cv2.NORM_MINMAX)
    Z = norm.reshape(-1, 1).astype(np.float32)

    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER,
                10, 1.0)
    K = 2
    try:
        _, labels, centers = cv2.kmeans(
            Z, K, None, criteria, 5, cv2.KMEANS_PP_CENTERS
        )
        labels = labels.reshape(norm.shape)
        centers = centers.reshape(-1)       # [c0, c1]
        ink_cluster = int(np.argmin(centers))
        bw = np.where(labels == ink_cluster, 0, 255).astype(np.uint8)
    except Exception:
        # Güvenli fallback
        _, bw = cv2.threshold(
            gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU
        )

    return bw


# ---------------------------------------------------------------------
# 2) Sayfalardan tablo tespiti + binarizasyon (kopukluk yok)
# ---------------------------------------------------------------------
def extract_tables_bw(
    pages: List[np.ndarray],
    min_area_ratio: float = 0.005,   # tablo en az %0.5 alan kaplasın
    margin_px: int = 6,              # bbox'a küçük pay
    debug: bool = False
) -> List[Dict[str, Any]]:
    """
    Her sayfada tabloyu bulur, gri tabloyu kırpar ve çizgileri
    bozmadan ikili (0/255) tablo görüntüsü döndürür.

    Dönen her eleman:
        {
            "image_index": int,
            "status": "ok" | "fallback" | "error",
            "bbox": (x0, y0, x1, y1) | None,
            "table_bw": np.ndarray(H,W) | None,
            "debug": {...} | None
        }
    """
    results: List[Dict[str, Any]] = []

    for idx, img in enumerate(pages):
        try:
            # --- 1) Griye çevir ---
            if img.ndim == 2:
                gray = img.copy()
            elif img.ndim == 3 and img.shape[2] == 3:
                try:
                    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
                except Exception:
                    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
            else:
                raise ValueError(f"Unsupported image shape: {img.shape}")

            H, W = gray.shape[:2]

            # ---------------------------------------------------------
            # 2) TABLO MASKESİ (bw_mask) – ADAPTİF, PERCENTILE TABANLI
            #    Amaç: tablo alanını bulmak, çizgi kopukluğu değil.
            # ---------------------------------------------------------

            # a) Arka planı normalize et (koyu gri sayfaları aç)
            #    Büyük median blur ile yavaş değişen arka planı tahmin et
            k_bg = max(31, (min(H, W) // 20) | 1)  # tek sayı olsun
            bg = cv2.medianBlur(gray, k_bg)

            # Gölge / ton farklarını azalt: gray / bg
            norm_mask = cv2.divide(gray, bg, scale=255)
            norm_mask = cv2.normalize(
                norm_mask, None, 0, 255, cv2.NORM_MINMAX
            ).astype(np.uint8)

            # b) Otomatik yüksek eşik: percentile tabanlı
            #    90. percentile genelde arka plan parlaklığına denk geliyor.
            p90 = np.percentile(norm_mask, 90)
            # Eşiği biraz aşağı çek (arka planın da üstünde kalsın)
            thr = np.clip(p90 - 5, 150, 245).astype(np.uint8)

            # Arka plan > thr; mürekkep <= thr olacak şekilde invert threshold
            # Sonuç: bw_mask: 255 = ink bölgesi, 0 = arka plan
            _, bw_mask = cv2.threshold(
                norm_mask, int(thr), 255, cv2.THRESH_BINARY_INV
            )

            # c) Küçük delikleri kapat, tabloyu tek parça yap
            ink = bw_mask  # zaten ink=255, background=0
            ink = cv2.medianBlur(ink, 3)

            kx = max(15, W // 60)
            ky = max(15, H // 60)
            ker = cv2.getStructuringElement(cv2.MORPH_RECT, (kx, ky))
            mask = cv2.morphologyEx(ink, cv2.MORPH_CLOSE, ker, iterations=1)

            ker2 = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
            mask = cv2.dilate(mask, ker2, iterations=1)

            # --- 3) En büyük dış konturu bul (tablo alanı) ---
            cnts, _ = cv2.findContours(
                mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
            )

            table_bbox: Optional[tuple[int, int, int, int]] = None
            status = "fallback"

            if cnts:
                area_img = H * W
                cand = []
                for c in cnts:
                    a = cv2.contourArea(c)
                    if a >= min_area_ratio * area_img:
                        cand.append((a, c))

                if cand:
                    cand.sort(key=lambda x: x[0], reverse=True)
                    _, best = cand[0]
                    x, y, w, h = cv2.boundingRect(best)

                    x0 = max(0, x - margin_px)
                    y0 = max(0, y - margin_px)
                    x1 = min(W, x + w + margin_px)
                    y1 = min(H, y + h + margin_px)

                    table_bbox = (x0, y0, x1, y1)
                    status = "ok"

            # --- 4) Tablo bölgesini gri olarak kırp ---
            if table_bbox is None:
                x0, y0, x1, y1 = 0, 0, W, H
                table_bbox = (x0, y0, x1, y1)
                status = "fallback"
            else:
                x0, y0, x1, y1 = table_bbox

            table_gray = gray[y0:y1, x0:x1].copy()

            # ---------------------------------------------------------
            # 5) ÇİZGİLERİ BOZMADAN BİNARİZE (K-means)
            # ---------------------------------------------------------
            table_bw = binarize_preserve_lines(table_gray)

            # --- 6) Çıkış ---
            out: Dict[str, Any] = {
                "image_index": idx,
                "status": status,
                "bbox": table_bbox,
                "table_bw": table_bw,
                "debug": None,
            }

            if debug:
                dbg = {
                    "gray": gray,
                    "bg": bg,
                    "norm_mask": norm_mask,
                    "bw_mask": bw_mask,
                    "ink": ink,
                    "mask": mask,
                    "kernel": (kx, ky),
                    "thr": float(thr),
                    "p90": float(p90),
                }
                out["debug"] = dbg

            results.append(out)

        except Exception as e:
            results.append(
                {
                    "image_index": idx,
                    "status": "error",
                    "error": str(e),
                    "bbox": None,
                    "table_bw": None,
                    "debug": None,
                }
            )

    return results

res = extract_tables_bw(table_imgs, min_area_ratio=0.005, margin_px=6, debug=False)

from matplotlib import pyplot as plt

for r in res:
    if r["status"] in ("ok", "fallback") and r["table_bw"] is not None:
        plt.figure(figsize=(6, 8))
        plt.title(f"page={r['image_index']} ({r['status']})")
        plt.imshow(r["table_bw"], cmap="gray", vmin=0, vmax=255)
        plt.axis("off")
        plt.show()