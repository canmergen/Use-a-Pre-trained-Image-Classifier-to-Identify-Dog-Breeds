import cv2
import numpy as np

# ----------------------
# Yardımcılar
# ----------------------
def _order_quad(pts: np.ndarray) -> np.ndarray:
    # 4x2 -> saat yönünde: tl, tr, br, bl
    pts = pts.astype(np.float32)
    s = pts.sum(axis=1); d = np.diff(pts, axis=1).ravel()
    tl = pts[np.argmin(s)]
    br = pts[np.argmax(s)]
    tr = pts[np.argmin(d)]
    bl = pts[np.argmax(d)]
    return np.array([tl, tr, br, bl], dtype=np.float32)

def _find_table_quad(binv: np.ndarray) -> tuple:
    """
    Çizgi maskesinden en büyük konturu bul, 4'gene yaklaştır.
    Döndür: (quad[4,2] veya None, bbox_rect)  -> bbox_rect: (x,y,w,h)
    """
    cnts = cv2.findContours(binv, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[0]
    if not cnts:
        return None, None
    cnt = max(cnts, key=cv2.contourArea)
    x,y,w,h = cv2.boundingRect(cnt)
    peri = cv2.arcLength(cnt, True)
    approx = cv2.approxPolyDP(cnt, 0.02*peri, True)
    if len(approx) == 4:
        quad = _order_quad(approx.reshape(-1,2))
        return quad, (x,y,w,h)
    return None, (x,y,w,h)

def _binarize_inv(img: np.ndarray) -> np.ndarray:
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if img.ndim == 3 else img
    # İnce yazıları korumak için adaptif eşik (INVerse)
    return cv2.adaptiveThreshold(gray, 255,
                                 cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV,
                                 15, 10)

# ----------------------
# 1) İlk kaba crop (senin mevcut fonksiyonun)
# ----------------------
def extract_full_table_region(image, debug=False, save_path=None):
    gray  = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) if len(image.shape) == 3 else image
    binary = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                                   cv2.THRESH_BINARY_INV, 15, 10)

    # Yatay ve dikey çizgileri güçlendir
    H, W = binary.shape[:2]
    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (max(40, W//40), 1))
    vertical_kernel   = cv2.getStructuringElement(cv2.MORPH_RECT, (1, max(40, H//40)))

    det_horizontal = cv2.morphologyEx(binary, cv2.MORPH_OPEN, horizontal_kernel, iterations=1)
    det_vertical   = cv2.morphologyEx(binary, cv2.MORPH_OPEN, vertical_kernel,   iterations=1)
    lines = cv2.bitwise_or(det_horizontal, det_vertical)

    # Projeksiyondan sol-sağ-üst-alt
    proj_h = lines.sum(axis=1); proj_v = lines.sum(axis=0)
    th_h = 0.5 * proj_h.max(); th_v = 0.5 * proj_v.max()

    ys = np.where(proj_h > th_h)[0] if proj_h.max() > 0 else np.array([0, H-1])
    xs = np.where(proj_v > th_v)[0] if proj_v.max() > 0 else np.array([0, W-1])

    top, bottom = int(ys[0]), int(ys[-1])
    left, right = int(xs[0]), int(xs[-1])

    pad = 5
    top    = max(0, top - pad);    bottom = min(H-1, bottom + pad)
    left   = max(0, left - pad);   right  = min(W-1, right + pad)

    cropped = image[top:bottom+1, left:right+1].copy()

    if debug:
        print(f"[INFO] Kesilen tablo: x={left}, y={top}, w={right-left}, h={bottom-top}")
    return cropped

# ----------------------
# 2) Sıkılaştır + Rectify + (gerekirse) Deskew
# ----------------------
def deskew_cropped_table(table_img,
                         min_thr=0.1, max_thr=10.0,
                         debug=False):
    """
    Girdi: extract_full_table_region'den gelen BGR tablo alanı
    Çıkış: BGR, sadece tablo (dış yazılar yok), rectify uygulanmış
    """
    # 2.1 Çizgilerden dış kutuyu netleştir – tablo dışındaki yazıları at
    binv = _binarize_inv(table_img)

    H, W = binv.shape[:2]
    kx = max(30, W // 25)
    ky = max(30, H // 25)
    horiz = cv2.morphologyEx(binv, cv2.MORPH_OPEN,
                             cv2.getStructuringElement(cv2.MORPH_RECT, (kx,1)), iterations=1)
    vert  = cv2.morphologyEx(binv, cv2.MORPH_OPEN,
                             cv2.getStructuringElement(cv2.MORPH_RECT, (1,ky)), iterations=1)
    line_mask = cv2.bitwise_or(horiz, vert)

    quad, bbox = _find_table_quad(line_mask)
    if bbox is not None:
        x,y,w,h = bbox
        # Küçük bir iç pad ile dış yazıları garanti dışına al
        shrink = max(2, min(w,h)//200)
        x = max(0, x+shrink); y = max(0, y+shrink)
        w = max(1, w-2*shrink); h = max(1, h-2*shrink)
        table_img = table_img[y:y+h, x:x+w].copy()
        binv      = binv[y:y+h, x:x+w].copy()
        if debug: print(f"[tight] bbox -> x={x}, y={y}, w={w}, h={h}")

    # 2.2 Perspektif varsa uygula (rectify)
    if quad is not None:
        # quad, eski görüntü koordinatlarındaydı; crop sonrası hizala
        if bbox is not None:
            x,y,_,_ = bbox
            quad = quad - np.array([x, y], dtype=np.float32)

        w = int(max(np.linalg.norm(quad[1]-quad[0]), np.linalg.norm(quad[2]-quad[3])))
        h = int(max(np.linalg.norm(quad[3]-quad[0]), np.linalg.norm(quad[2]-quad[1])))
        w = max(w, 1); h = max(h, 1)
        dst = np.array([[0,0],[w-1,0],[w-1,h-1],[0,h-1]], dtype=np.float32)
        M = cv2.getPerspectiveTransform(quad, dst)
        rectified = cv2.warpPerspective(table_img, M, (w, h),
                                        flags=cv2.INTER_LINEAR,
                                        borderMode=cv2.BORDER_REPLICATE)
        if debug: print("[rectify] perspective warp applied")
        return rectified

    # 2.3 Perspektif bulunamadıysa: hafif açı düzeltme (Hough)
    gray = cv2.cvtColor(table_img, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (3,3), 0)
    _, th = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

    lines = cv2.HoughLinesP(th, 1, np.pi/180,
                            threshold=max(80, (H+W)//80),
                            minLineLength=max(H,W)//3,
                            maxLineGap=10)
    angle = None
    if lines is not None:
        angs = []
        for x1,y1,x2,y2 in lines[:,0]:
            a = np.degrees(np.arctan2(y2-y1, x2-x1))
            a = (a + 180) % 180
            if a > 90: a -= 180
            if abs(a) <= 45: angs.append(a)
        if angs:
            angle = float(np.median(angs))

    if angle is None or abs(angle) < min_thr or abs(angle) > max_thr:
        if debug: print("[deskew] angle unavailable or out-of-range, skip.")
        return table_img

    H2, W2 = table_img.shape[:2]
    M = cv2.getRotationMatrix2D((W2/2, H2/2), angle, 1.0)
    rotated = cv2.warpAffine(table_img, M, (W2, H2),
                             flags=cv2.INTER_LINEAR,
                             borderMode=cv2.BORDER_REPLICATE)
    if debug: print(f"[deskew] Rotated by {angle:.2f}°")
    return rotated