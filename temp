import re
import unicodedata
from difflib import SequenceMatcher
from typing import List, Dict, Iterable
import pandas as pd


def standardize_table_headers_with_fuzzy(
    table_dfs_marked: List[pd.DataFrame],
    min_score: float = 0.55,
    debug: bool = False,
) -> List[pd.DataFrame]:
    """
    OCR'den gelen sayfa bazlı DataFrame listesini standart şemaya map eder.
    - Kolon isimlerini fuzzy + içerik tipine göre eşler.
    - Boş kalan kolonlardan TC / TCKN bilgisi varsa uygun yere taşır.
    - IMZA/INZA kolonundan sadece tablo_imza_var_mi (0/1) üretir.
    - paylarin_toplam_itibari_degeri(tl) kolonunu float'a çevirir (Türk sayı formatı).
    """

    # ------------- helpers ------------- #
    def _normalize_name(s: str) -> str:
        if s is None:
            return ""
        s = str(s).strip().lower()
        tr_map = str.maketrans(
            {"ç": "c", "ğ": "g", "ı": "i", "ö": "o", "ş": "s", "ü": "u"}
        )
        s = s.translate(tr_map)
        s = unicodedata.normalize("NFKD", s)
        s = re.sub(r"[^a-z0-9]+", " ", s)
        s = re.sub(r"\s+", " ", s).strip()
        return s

    def _sim(a: str, b: str) -> float:
        return SequenceMatcher(None, _normalize_name(a), _normalize_name(b)).ratio()

    def _safe_series(obj) -> pd.Series:
        if isinstance(obj, pd.Series):
            return obj
        if isinstance(obj, pd.DataFrame):
            if obj.shape[1] == 0:
                return pd.Series([], dtype=object)
            return obj.iloc[:, 0]
        return pd.Series(obj)

    def _is_empty_series(s: pd.Series) -> bool:
        s = _safe_series(s)
        if s.empty:
            return True
        s_norm = s.astype(str).str.strip().str.lower()
        return s_norm.isin(["", "nan", "none"]).mean() > 0.8

    def _col_profile(s: pd.Series) -> Dict[str, float]:
        s = _safe_series(s)
        if s.empty:
            return dict(
                tcid_ratio=0.0,
                numeric_ratio=0.0,
                short_int_ratio=0.0,
                text_ratio=0.0,
                has_asal_vek=False,
                has_tem_tur=False,
            )

        s_str = s.astype(str).str.strip()
        s_norm = s_str.str.lower()
        digits = s_str.str.replace(r"\D", "", regex=True)

        tcid_mask = digits.str.fullmatch(r"\d{10,11}")
        numeric_mask = s_str.str.fullmatch(r"\d+(\.\d+)?")
        short_int_mask = digits.str.fullmatch(r"\d{1,3}")
        text_mask = s_norm.str.contains(r"[a-zçğıöşü]", regex=True)

        return dict(
            tcid_ratio=float(tcid_mask.mean()),
            numeric_ratio=float(numeric_mask.mean()),
            short_int_ratio=float(short_int_mask.mean()),
            text_ratio=float(text_mask.mean()),
            has_asal_vek=bool(s_norm.str.contains("asaleten|vekaleten").any()),
            has_tem_tur=bool(s_norm.str.contains("temsilci|turu").any()),
        )

    def _parse_turkish_amount(val) -> float | None:
        """
        '20.237.333,33', '20.237.333.33', '1.50', '.33' gibi değerleri float'a çevirir.
        Varsayım:
          - Son '.' veya ',' ondalık ayracı
          - Önceki tüm '.' ',' binlik ayırıcı
        """
        if val is None:
            return None
        s = str(val).strip()
        if s == "":
            return None

        # sadece rakam + ayraçlar hariç her şeyi at
        s = re.sub(r"[^0-9\.,]", "", s)
        if s == "":
            return None

        # '.33' -> '0.33'
        if s.startswith(".") or s.startswith(","):
            s = "0" + s

        last_dot = s.rfind(".")
        last_comma = s.rfind(",")

        # hiç ayrac yoksa direkt parse
        if last_dot == -1 and last_comma == -1:
            try:
                return float(s)
            except ValueError:
                return None

        # son ayracı ondalık kabul et
        if last_comma > last_dot:
            dec_pos = last_comma
            decimal_sep = ","
        else:
            dec_pos = last_dot
            decimal_sep = "."

        int_part = re.sub(r"[^\d]", "", s[:dec_pos])  # tüm ayraçları kaldır
        frac_part = re.sub(r"[^\d]", "", s[dec_pos + 1 :])

        if int_part == "" and frac_part == "":
            return None
        if int_part == "":
            int_part = "0"

        norm = int_part + "." + frac_part if frac_part != "" else int_part
        try:
            return float(norm)
        except ValueError:
            return None

    # ------------- hedef şema ve sinonimler ------------- #
    target_order = [
        "page_index",
        "pay_sahibinin_adi_soyadi_unvani",
        "tckn",
        "uyrugu",
        "adres",
        "paylarin_toplam_itibari_degeri(tl)",
        "paylarin_edilmin_sekli_tarihi",
        "katilim_sekli",
        "temsilci_turu",
        "temsilci_adi_soyadi_unvani",
        "temsilci_tckn",
        "tablo_imza_var_mi",
    ]

    synonyms: Dict[str, Iterable[str]] = {
        "pay_sahibinin_adi_soyadi_unvani": [
            "pay sahibinin adi soyadi unvani",
            "pay sahibinin adi soyadi/unvani",
            "pay sahibinin adi soyadi / unvani",
        ],
        "tckn": [
            "t c v k no",
            "t.c./v.k.no",
            "t c / v k no",
            "t c no",
            "tckn",
            "tc kimlik no",
            "t c kimlik numarasi",
        ],
        "uyrugu": [
            "uyrugu",
            "uyruk",
        ],
        "adres": [
            "adres",
            "ikamet adresi",
        ],
        "paylarin_toplam_itibari_degeri(tl)": [
            "paylarin toplam itibari degeri tl",
            "paylarin toplam itibari degeri",
            "paylarin toplam itibari degeri (tl)",
        ],
        "paylarin_edilmin_sekli_tarihi": [
            "paylarin edinim sekli ve tarihi",
            "paylarin edinim sekli ve tarıhı",
        ],
        "katilim_sekli": [
            "katilim sekli",
            "katilim sekli (asaleten vekaleten)",
            "katilim sekli (asaleten/vekaleten)",
        ],
        "temsilci_turu": [
            "temsilci turu",
            "temsilcinin turu",
            "temsil sekli temsilci toro",
            "temsil sekli temsilci turu",
        ],
        "temsilci_adi_soyadi_unvani": [
            "temsilcinin adi soyadi unvani",
            "temsilcinin adi soyadi/unvani",
            "temsilcinin adi soyadi",
        ],
        "temsilci_tckn": [
            "temsilcinin t c no su",
            "temsilcinin t c kimlik no su",
            "temsilcinin t c kimlik nosu",
        ],
        # IMZA başlığını sadece tablo_imza_var_mi için kullanacağız
    }

    def choose_best_source(col_target: str, source_cols: Iterable[str], used: set) -> (str, float):
        norm_target = _normalize_name(col_target)
        best_col = None
        best_score = 0.0

        syn_list = synonyms.get(col_target, [])
        syn_norm = {_normalize_name(s) for s in syn_list}

        for c in source_cols:
            if c in used:
                continue
            n = _normalize_name(c)
            if n in syn_norm:
                return c, 1.0

        for c in source_cols:
            if c in used:
                continue
            score = _sim(norm_target, c)
            if score > best_score:
                best_score = score
                best_col = c

        if best_col is None or best_score < min_score:
            return None, 0.0
        return best_col, best_score

    # ------------- ana döngü ------------- #
    standardized_pages: List[pd.DataFrame] = []

    for df in table_dfs_marked:
        if df is None or df.empty:
            standardized_pages.append(pd.DataFrame(columns=target_order))
            continue

        src_cols = list(df.columns)

        # page_index kolonunu bul
        page_index_col = None
        for c in src_cols:
            if _normalize_name(c) == "page index":
                page_index_col = c
                break

        profiles = {c: _col_profile(df[c]) for c in src_cols}
        used_cols = set()
        col_map: Dict[str, str] = {}

        # 1) ilk fuzzy mapping (IMZA hariç; sadece tablo_imza_var_mi'de kullanacağız)
        for tgt in target_order:
            if tgt in ("page_index", "tablo_imza_var_mi"):
                continue
            src, score = choose_best_source(tgt, src_cols, used_cols)
            if src is not None:
                col_map[tgt] = src
                used_cols.add(src)
            elif debug:
                print(f"[WARN] '{tgt}' için fuzzy ile uygun kolon bulunamadı (best_score<{min_score})")

        # 2) temsilci_tckn için içerik tabanlı override
        best_tckn_col = None
        best_tcid_ratio = 0.0
        for c in src_cols:
            p = profiles[c]
            if p["tcid_ratio"] > best_tcid_ratio:
                best_tcid_ratio = p["tcid_ratio"]
                best_tckn_col = c

        if best_tckn_col is not None and best_tcid_ratio >= 0.5:
            if "temsilci_tckn" not in col_map or col_map["temsilci_tckn"] != best_tckn_col:
                if debug:
                    print(f"[INFO] temsilci_tckn override -> '{best_tckn_col}' (tcid_ratio={best_tcid_ratio:.2f})")
                col_map["temsilci_tckn"] = best_tckn_col
            used_cols.add(best_tckn_col)

        # 3) temsilci_turu için içerik tabanlı kontrol
        def is_good_turu(cname: str) -> bool:
            p = profiles[cname]
            return (
                p["text_ratio"] > 0.4
                and p["numeric_ratio"] < 0.5
                and (p["has_asal_vek"] or p["has_tem_tur"])
            )

        cur_turu = col_map.get("temsilci_turu")
        if cur_turu is None or not is_good_turu(cur_turu):
            best_turu_col = None
            for c in src_cols:
                if c == page_index_col:
                    continue
                if c == col_map.get("temsilci_tckn"):
                    continue
                if is_good_turu(c):
                    best_turu_col = c
                    break
            if best_turu_col is not None:
                if debug:
                    print(f"[INFO] temsilci_turu override -> '{best_turu_col}'")
                col_map["temsilci_turu"] = best_turu_col
                used_cols.add(best_turu_col)

        if debug:
            print("Column mapping:", col_map)

        # -------- yeni DF -------- #
        new_df = pd.DataFrame(columns=target_order)

        # page_index
        if page_index_col is not None:
            new_df["page_index"] = df[page_index_col].values
        else:
            new_df["page_index"] = df.index.to_series().fillna(0).astype(int).values

        # map edilen kolonlar
        for tgt, src in col_map.items():
            if tgt == "paylarin_toplam_itibari_degeri(tl)":
                s_vals = _safe_series(df[src])
                new_df[tgt] = s_vals.apply(_parse_turkish_amount)
            else:
                new_df[tgt] = _safe_series(df[src]).values

        # -------- leftover kolonlardan TC / TCKN doldurma -------- #
        leftover_cols = [c for c in src_cols if c not in used_cols and c != page_index_col]

        for col in leftover_cols:
            s_raw = _safe_series(df[col])
            if _is_empty_series(s_raw):
                continue

            s = s_raw.astype(str).str.strip()
            upper = s.str.upper()
            digits = s.str.replace(r"\D", "", regex=True)

            prof = profiles[col]

            # Uyruk (T.C.)
            tc_text_mask = (
                upper.str.contains(r"T\.?C", regex=True)
                | upper.eq("TC")
                | upper.eq("T C")
            )
            if "uyrugu" in new_df.columns and tc_text_mask.mean() > 0.5:
                empty_mask = new_df["uyrugu"].astype(str).str.strip().isin(["", "nan", "none"]) | new_df["uyrugu"].isna()
                new_df.loc[empty_mask, "uyrugu"] = upper[empty_mask]
                if debug:
                    print(f"[INFO] '{col}' kolonu uyrugu için kullanıldı (TC).")
                continue

            # Pay sahibi TCKN
            if "tckn" in new_df.columns and prof["tcid_ratio"] > 0.5:
                empty_mask = new_df["tckn"].astype(str).str.strip().isin(["", "nan", "none"]) | new_df["tckn"].isna()
                new_df.loc[empty_mask, "tckn"] = digits[empty_mask]
                if debug:
                    print(f"[INFO] '{col}' kolonu tckn için kullanıldı (10–11 haneli sayı).")
                continue

        # -------- tablo_imza_var_mi -------- #
        # IMZA/INZA başlığını bul ve sadece sayfa bazında flag üret
        imza_source = None
        for c in src_cols:
            n = _normalize_name(c)
            if n in {_normalize_name("imza"), _normalize_name("inza")}:
                imza_source = c
                break

        if imza_source is not None:
            s_imza = _safe_series(df[imza_source])
            try:
                img_flag = int(
                    s_imza.fillna(0)
                    .astype(str)
                    .str.replace(r"[^\d]", "", regex=True)
                    .replace("", "0")
                    .astype(int)
                    .max()
                    > 0
                )
            except Exception:
                img_flag = 1 if s_imza.notna().any() else 0
        else:
            img_flag = 0

        new_df["tablo_imza_var_mi"] = img_flag
        new_df = new_df[target_order]

        standardized_pages.append(new_df)

    return standardized_pages