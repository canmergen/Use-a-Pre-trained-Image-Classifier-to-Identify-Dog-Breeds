import math
from typing import List, Dict, Any, Tuple, Optional
import cv2
import matplotlib.pyplot as plt

def link_merge_visualize(
    final_lower_imgs: List,                 # sayfa bazında numpy img (H,W,3)
    role_boxes: List[Dict[str, Any]],
    name_boxes: List[Dict[str, Any]],
    sig_boxes:  List[Dict[str, Any]],
    name_to_role_thresh_ratio: float = 0.20,
    sig_to_name_thresh_ratio:  float = 0.20,
    show_unmatched: bool = True,
    save_dir: Optional[str] = None,
    show_plots: bool = True
) -> Tuple[Dict[str, Any], List]:
    """
    Tek fonksiyon: normalize -> eşleştir -> merge -> görselleştir
    Girdi şemaları:
      - role/name: {'page_index':int, 'boxes': {'x_min','y_min','width','height'}, ...}
      - sig:      ya yukarıdaki gibi tekil, ya da sayfa kaydı içinde 'boxes' listesi (xyxy)
                  {'page_index':int, 'boxes':[{'x_min','x_max','y_min','y_max',...}, ...]}
    Çıktı:
      (result_dict, canvases_list)
    """

    # ---------- yardımcılar ----------
    def _to_float(v): 
        try: return float(v)
        except: return 0.0

    def _normalize_flat_xywh(items):
        out=[]
        for it in items:
            b = dict(it.get('boxes', {}))
            if 'width' not in b or 'height' not in b:
                x_min = _to_float(b.get('x_min', 0))
                y_min = _to_float(b.get('y_min', 0))
                x_max = _to_float(b.get('x_max', x_min))
                y_max = _to_float(b.get('y_max', y_min))
                b = {'x_min': x_min,'y_min': y_min,'width': max(0.0,x_max-x_min),'height': max(0.0,y_max-y_min)}
            else:
                b = {'x_min': _to_float(b.get('x_min',0)),'y_min': _to_float(b.get('y_min',0)),
                     'width': _to_float(b.get('width',0)),'height': _to_float(b.get('height',0))}
            new_it = dict(it)
            new_it['boxes']=b
            out.append(new_it)
        return out

    def _normalize_sig(items):
        # sig, sayfa içinde list olabilir
        flat=[]
        for it in items:
            if isinstance(it.get('boxes'), list):
                pidx = int(it.get('page_index',0))
                for bx in it['boxes']:
                    x_min = _to_float(bx.get('x_min',0))
                    y_min = _to_float(bx.get('y_min',0))
                    x_max = _to_float(bx.get('x_max',x_min))
                    y_max = _to_float(bx.get('y_max',y_min))
                    flat.append({
                        'page_index': pidx,
                        'boxes': {'x_min': x_min, 'y_min': y_min, 'width': max(0.0,x_max-x_min), 'height': max(0.0,y_max-y_min)},
                        'conf': _to_float(bx.get('conf', None)) if 'conf' in bx else None,
                        'class_id': bx.get('class_id', None)
                    })
            else:
                flat.append(it)
        return _normalize_flat_xywh(flat)

    def _assign_ids(items, prefix):
        out=[]
        for i,it in enumerate(items):
            c=dict(it)
            c['_id']=f"{prefix}_{i}"
            out.append(c)
        return out

    def _xywh(item):
        b=item['boxes']; return float(b['x_min']),float(b['y_min']),float(b['width']),float(b['height'])
    def _xyxy(item):
        x,y,w,h=_xywh(item); return x,y,x+w,y+h
    def _center(item):
        x,y,w,h=_xywh(item); return (x+w/2.0, y+h/2.0)
    def _top_center(item):
        x,y,w,h=_xywh(item); return (x+w/2.0, y)
    def _euclid(p,q): return math.hypot(p[0]-q[0], p[1]-q[1])
    def _union_xyxy(lst):
        if not lst: return None
        xs=[b[0] for b in lst]; ys=[b[1] for b in lst]; xe=[b[2] for b in lst]; ye=[b[3] for b in lst]
        xmin, ymin, xmax, ymax = min(xs), min(ys), max(xe), max(ye)
        return {'x_min': xmin, 'y_min': ymin, 'width': xmax-xmin, 'height': ymax-ymin}

    def _by_page(items):
        d={}
        for it in items: d.setdefault(it['page_index'], []).append(it)
        return d

    def _greedy_match(children, parents, page_h_map, ratio):
        matches={}
        pairs=[]
        for c in children:
            cp=_top_center(c)
            for p in parents:
                if c['page_index']!=p['page_index']: 
                    continue
                pp=_center(p)
                pairs.append(( _euclid(cp,pp), c['_id'], p['_id'], c['page_index']))
        pairs.sort(key=lambda x:x[0])
        taken=set()
        for dist, cid, pid, pidx in pairs:
            if cid in taken: 
                continue
            if dist <= page_h_map.get(pidx,0)*ratio:
                matches[cid]=pid
                taken.add(cid)
        return matches

    def _xywh_to_xyxy(b):
        x,y,w,h= b['x_min'],b['y_min'],b['width'],b['height']
        return int(x),int(y),int(x+w),int(y+h)

    def _draw(img, box, color, label=None, thick=2):
        x1,y1,x2,y2=_xywh_to_xyxy(box)
        cv2.rectangle(img,(x1,y1),(x2,y2),color,thick)
        if label:
            y = max(0, y1-5)
            cv2.putText(img, label, (x1,y), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1, cv2.LINE_AA)

    # ---------- normalize + id ----------
    role_norm = _assign_ids(_normalize_flat_xywh(role_boxes), 'role')
    name_norm = _assign_ids(_normalize_flat_xywh(name_boxes), 'name')
    sig_norm  = _assign_ids(_normalize_sig(sig_boxes),          'sig')

    # ---------- sayfa yükseklikleri ----------
    page_h = {i:int(img.shape[0]) for i,img in enumerate(final_lower_imgs) if img is not None}

    # ---------- eşleştirme ----------
    name_to_role = _greedy_match(name_norm, role_norm, page_h, name_to_role_thresh_ratio)
    sig_to_name  = _greedy_match(sig_norm,  name_norm, page_h, sig_to_name_thresh_ratio)

    # ---------- role merkezli gruplar ----------
    role_idx = {r['_id']: r for r in role_norm}
    name_idx = {n['_id']: n for n in name_norm}
    sig_idx  = {s['_id']: s for s in sig_norm}

    role_children_names={}
    for n in name_norm:
        rid=name_to_role.get(n['_id'])
        if rid: role_children_names.setdefault(rid, []).append(n['_id'])

    name_children_sigs={}
    for s in sig_norm:
        nid=sig_to_name.get(s['_id'])
        if nid: name_children_sigs.setdefault(nid, []).append(s['_id'])

    groups=[]
    for rid, ritem in role_idx.items():
        nids = role_children_names.get(rid, [])
        sids = []
        for nid in nids:
            sids += name_children_sigs.get(nid, [])
        all_xyxy=[_xyxy(ritem)] + [_xyxy(name_idx[n]) for n in nids] + [_xyxy(sig_idx[s]) for s in sids]
        merged=_union_xyxy(all_xyxy)
        groups.append({
            'page_index': ritem['page_index'],
            'role_id': rid,
            'role_box': ritem,
            'name_ids': nids,
            'sig_ids': sids,
            'merged_box': merged
        })

    unmatched = {
        'names': [n['_id'] for n in name_norm if n['_id'] not in name_to_role],
        'sigs' : [s['_id'] for s in sig_norm  if s['_id'] not in sig_to_name]
    }

    result = {'links': {'name_to_role': name_to_role, 'sig_to_name': sig_to_name},
              'groups': groups, 'unmatched': unmatched}

    # ---------- görselleştirme ----------
    canvases = [img.copy() for img in final_lower_imgs]
    C_ROLE, C_NAME, C_SIG, C_MERGED = (255,0,0), (0,200,0), (0,165,255), (0,0,255)

    for g in groups:
        p=g['page_index']; canvas=canvases[p]
        r=g['role_box']; _draw(canvas, r['boxes'], C_ROLE, label=f"ROLE:{r.get('role','')}", thick=2)
        for nid in g['name_ids']:
            n=name_idx[nid]; _draw(canvas, n['boxes'], C_NAME, label="NAME", thick=2)
        for sid in g['sig_ids']:
            s=sig_idx[sid]; _draw(canvas, s['boxes'], C_SIG,  label="SIG",  thick=2)
        if g['merged_box'] is not None:
            _draw(canvas, g['merged_box'], C_MERGED, label="MERGED", thick=3)

    if show_unmatched:
        for nid in unmatched['names']:
            n=name_idx[nid]; _draw(canvases[n['page_index']], n['boxes'], (0,130,0), "NAME_unmatched", 1)
        for sid in unmatched['sigs']:
            s=sig_idx[sid]; _draw(canvases[s['page_index']], s['boxes'], (0,120,180), "SIG_unmatched", 1)

    if save_dir:
        import os
        os.makedirs(save_dir, exist_ok=True)
        for p, canvas in enumerate(canvases):
            cv2.imwrite(f"{save_dir}/annot_page_{p}.png", canvas)

    if show_plots:
        for p, canvas in enumerate(canvases):
            plt.figure(figsize=(10,10))
            plt.imshow(cv2.cvtColor(canvas, cv2.COLOR_BGR2RGB))
            plt.title(f"Page {p} — role/name/sig & merged")
            plt.axis('off')
            plt.show()

    return result, canvases

result, canvases = link_merge_visualize(
    final_lower_imgs,
    role_boxes,      # ham role listesi
    name_boxes,      # ham name listesi
    sig_boxes,       # sayfa-kayıtlı veya tekil olabilir
    name_to_role_thresh_ratio=0.20,
    sig_to_name_thresh_ratio=0.20,
    show_unmatched=True,
    save_dir="annot_out",     # kaydetmek istemezsen None
    show_plots=True
)