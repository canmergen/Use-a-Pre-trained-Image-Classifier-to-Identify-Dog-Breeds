import cv2
import numpy as np
from typing import List, Dict, Any, Optional

# ---------------------------------------------------------------------
# 1) İnce çizgileri koruyan binarizasyon (K=2 K-means)
# ---------------------------------------------------------------------
def binarize_preserve_lines(gray: np.ndarray) -> np.ndarray:
    """
    Global threshold (Otsu) yerine K-means (K=2) kullanarak,
    koyu kümeyi mürekkep (siyah), açık kümeyi arka plan (beyaz) yapar.
    İnce gri çizgilerin beyaza kaybolduğu durumları toparlamak için kullanılır.

    Girdi:
        gray : (H, W) uint8 gri seviye tablo görüntüsü
    Çıktı:
        bw   : (H, W) uint8 ikili görüntü (0=ink, 255=background)
    """
    # Her ihtimale karşı tek kanal
    if gray.ndim == 3:
        gray = cv2.cvtColor(gray, cv2.COLOR_BGR2GRAY)

    # K-means öncesi hafif normalizasyon
    norm = cv2.normalize(gray, None, 0, 255, cv2.NORM_MINMAX)

    Z = norm.reshape(-1, 1).astype(np.float32)

    # K=2 cluster: arka plan / mürekkep
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER,
                10, 1.0)
    K = 2
    try:
        _, labels, centers = cv2.kmeans(
            Z, K, None, criteria, 5, cv2.KMEANS_PP_CENTERS
        )
        labels = labels.reshape(norm.shape)
        centers = centers.reshape(-1)  # [c0, c1]
        ink_cluster = int(np.argmin(centers))          # en koyu merkez
        bw = np.where(labels == ink_cluster, 0, 255).astype(np.uint8)
    except Exception:
        # K-means bir sebeple çökerse, güvenli fallback: Otsu
        _, bw = cv2.threshold(
            gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU
        )

    return bw

# ---------------------------------------------------------------------
# 2) Sayfalardan tablo tespiti + çizgileri bozmadan binarize etme
# ---------------------------------------------------------------------
def extract_tables_bw(
    pages: List[np.ndarray],
    min_area_ratio: float = 0.005,  # tablo en az %0.5 alan kaplasın
    margin_px: int = 6,             # kırpıma küçük pay
    debug: bool = False
) -> List[Dict[str, Any]]:
    """
    Her sayfada (page) tabloyu bulur, bbox içinde gri tabloyu kırpar ve
    çizgi yapısını bozmadan ikili tablo görüntüsü (table_bw) olarak döndürür.

    Girdi:
        pages : list of np.ndarray, her biri (H,W,3) veya (H,W) uint8
    Çıktı (list of dict):
        {
            "image_index": int,
            "status": "ok" | "fallback" | "error",
            "bbox": (x0, y0, x1, y1) veya None,
            "table_bw": np.ndarray (H,W) veya None,
            "debug": {...} veya None
        }
    """
    results: List[Dict[str, Any]] = []

    for idx, img in enumerate(pages):
        try:
            # --- 1) Griye çevir ---
            if img.ndim == 2:
                gray = img.copy()
            elif img.ndim == 3 and img.shape[2] == 3:
                # BGR / RGB farkını tolere et
                try:
                    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
                except Exception:
                    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
            else:
                raise ValueError(f"Unsupported image shape: {img.shape}")

            H, W = gray.shape[:2]

            # ---------------------------------------------------------
            # 2) TABLO MASKESİ (sadece kontur bulmak için) - OTSU KALSIN
            #    Burada çizgi kopukluğu önemli değil; tek amacımız bbox.
            # ---------------------------------------------------------
            _, bw_mask = cv2.threshold(
                gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU
            )

            # Siyah içeriği (yazı+çizgi) beyaza çevir
            ink = cv2.subtract(255, bw_mask)
            ink = cv2.medianBlur(ink, 3)

            # Tablonun tek büyük bileşen olması için geniş kernel
            kx = max(15, W // 60)
            ky = max(15, H // 60)
            ker = cv2.getStructuringElement(cv2.MORPH_RECT, (kx, ky))
            mask = cv2.morphologyEx(ink, cv2.MORPH_CLOSE, ker, iterations=1)

            # Konturu biraz sağlamlaştır
            ker2 = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
            mask = cv2.dilate(mask, ker2, iterations=1)

            # --- 3) En büyük dış konturu bul (tablo) ---
            cnts, _ = cv2.findContours(
                mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
            )

            table_bbox: Optional[tuple[int, int, int, int]] = None
            status = "fallback"

            if cnts:
                area_img = H * W
                cand = []
                for c in cnts:
                    a = cv2.contourArea(c)
                    if a >= min_area_ratio * area_img:
                        cand.append((a, c))

                if cand:
                    cand.sort(key=lambda x: x[0], reverse=True)
                    _, best = cand[0]
                    x, y, w, h = cv2.boundingRect(best)

                    # Küçük güvenlik marjı
                    x0 = max(0, x - margin_px)
                    y0 = max(0, y - margin_px)
                    x1 = min(W, x + w + margin_px)
                    y1 = min(H, y + h + margin_px)

                    table_bbox = (x0, y0, x1, y1)
                    status = "ok"

            # --- 4) Tablo bölgesini gri olarak kırp ---
            if table_bbox is None:
                # Tespit yoksa tüm sayfayı tablo varsay (fallback)
                x0, y0, x1, y1 = 0, 0, W, H
                table_bbox = (x0, y0, x1, y1)
                status = "fallback"

            x0, y0, x1, y1 = table_bbox
            table_gray = gray[y0:y1, x0:x1].copy()

            # ---------------------------------------------------------
            # 5) Çizgileri bozmadan İKİLİ TABLO (K-means)
            # ---------------------------------------------------------
            table_bw = binarize_preserve_lines(table_gray)

            # --- 6) Çıkış sözlüğü ---
            out: Dict[str, Any] = {
                "image_index": idx,
                "status": status,
                "bbox": table_bbox,
                "table_bw": table_bw,
                "debug": None,
            }

            if debug:
                dbg = {
                    "bw_mask": bw_mask,    # tüm sayfa Otsu binarize
                    "ink": ink,            # siyah içerik maskesi
                    "mask": mask,          # closing sonrası tablo maskesi
                    "kernel": (kx, ky),
                    "gray": gray,
                }
                out["debug"] = dbg

            results.append(out)

        except Exception as e:
            results.append(
                {
                    "image_index": idx,
                    "status": "error",
                    "error": str(e),
                    "bbox": None,
                    "table_bw": None,
                    "debug": None,
                }
            )

    return results

res = extract_tables_bw(table_imgs, min_area_ratio=0.005, margin_px=6, debug=False)

for r in res:
    if r["status"] in ("ok", "fallback") and r["table_bw"] is not None:
        table = r["table_bw"]
        # burada show_tables veya kendi plot’un