import cv2, numpy as np
from typing import Dict, Any

# ---------- helpers ----------
def _to_gray(img): 
    return cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if img.ndim == 3 else img

def _order_quad(pts: np.ndarray) -> np.ndarray:
    s = pts.sum(1); d = np.diff(pts, axis=1).ravel()
    tl = pts[np.argmin(s)]; br = pts[np.argmax(s)]
    tr = pts[np.argmin(d)]; bl = pts[np.argmax(d)]
    return np.array([tl,tr,br,bl], np.float32)

def _grid_mask(gray: np.ndarray) -> np.ndarray:
    H, W = gray.shape
    # Yazıyı bastırıp çizgileri öne çıkar
    bin_ = cv2.adaptiveThreshold(gray,255,cv2.ADAPTIVE_THRESH_MEAN_C,
                                 cv2.THRESH_BINARY_INV, 31, 10)
    kx = max(15, W//60); ky = max(15, H//60)
    hor = cv2.morphologyEx(bin_, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_RECT,(kx,1)), 1)
    ver = cv2.morphologyEx(bin_, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_RECT,(1,ky)), 1)
    grid = cv2.bitwise_or(hor, ver)
    # dış çerçeveyi sürekli hale getir
    grid = cv2.morphologyEx(grid, cv2.MORPH_CLOSE,
                            cv2.getStructuringElement(cv2.MORPH_RECT,(max(3,W//400),max(3,H//400))), 2)
    # metin köprülerini zayıflat
    grid = cv2.erode(grid, cv2.getStructuringElement(cv2.MORPH_RECT,(2,2)), 1)
    return grid

def _largest_rect_like(mask: np.ndarray) -> np.ndarray:
    # En büyük bileşen -> hull -> approx 4 nokta; olmazsa minAreaRect
    cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts:
        raise RuntimeError("Tablo çizgileri bulunamadı.")
    # dikdörtgen benzerliğine göre skorlama
    def score(c):
        area = cv2.contourArea(c)
        if area <= 0: return 0
        x,y,w,h = cv2.boundingRect(c)
        fill = area / (w*h + 1e-6)
        return fill * np.sqrt(area)
    cmax = max(cnts, key=score)

    hull = cv2.convexHull(cmax)
    peri = cv2.arcLength(hull, True)
    approx = cv2.approxPolyDP(hull, 0.02*peri, True)

    if len(approx) == 4:
        quad = approx.reshape(-1,2).astype(np.float32)
    else:
        rect = cv2.minAreaRect(hull)
        quad = cv2.boxPoints(rect).astype(np.float32)

    return _order_quad(quad)

def _warp_with_landscape(image: np.ndarray, quad: np.ndarray) -> np.ndarray:
    # hedef boyut: kenarların uzunlukları (ölçek korunur)
    tl,tr,br,bl = quad
    wA = np.linalg.norm(br - bl); wB = np.linalg.norm(tr - tl)
    hA = np.linalg.norm(tr - br); hB = np.linalg.norm(tl - bl)
    Wt = int(round(max(wA, wB))); Ht = int(round(max(hA, hB)))

    # Peyzaj zorlaması: gerektiğinde hedefi çevir
    landscape = Wt >= Ht
    if not landscape:
        Wt, Ht = Ht, Wt  # hedef yönü değişir

    dst = np.array([[0,0],[Wt-1,0],[Wt-1,Ht-1],[0,Ht-1]], np.float32)
    M = cv2.getPerspectiveTransform(quad, dst)
    warped = cv2.warpPerspective(image, M, (Wt, Ht),
                                 flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REPLICATE)

    # Küçük artık eğimi (0.2°–10°) düzelt
    g = _to_gray(warped)
    _, bw = cv2.threshold(g, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)
    ys,xs = np.where(bw==0)
    if len(xs) > 20:
        rect = cv2.minAreaRect(np.column_stack([xs,ys]).astype(np.float32))
        raw = rect[-1]; ang = raw if raw < 45 else raw - 90
        if 0.2 < abs(ang) < 10:
            h,w = g.shape
            R = cv2.getRotationMatrix2D((w/2,h/2), ang, 1.0)
            interp = cv2.INTER_NEAREST if warped.ndim==2 else cv2.INTER_LINEAR
            warped = cv2.warpAffine(warped, R, (w,h), flags=interp, borderMode=cv2.BORDER_REPLICATE)

    return warped

# ---------- main ----------
def extract_and_rectify_table_v3(image: np.ndarray, debug: bool=False) -> Dict[str, Any]:
    gray = _to_gray(image)
    H,W = gray.shape

    grid = _grid_mask(gray)

    # En büyük dikdörtgen benzeri bölge -> köşeler
    quad = _largest_rect_like(grid)

    # Güvenlik: sınır içine kırp
    quad[:,0] = np.clip(quad[:,0], 0, W-1)
    quad[:,1] = np.clip(quad[:,1], 0, H-1)

    # Bbox ile tabloyu kaba cropla (yan yazıları at)
    x0,y0 = np.floor(quad.min(0)).astype(int)
    x1,y1 = np.ceil(quad.max(0)).astype(int)
    pad = max(4, int(0.01*max(W,H)))
    x0,y0 = max(0, x0-pad), max(0, y0-pad)
    x1,y1 = min(W, x1+pad), min(H, y1+pad)
    crop = image[y0:y1, x0:x1].copy()

    # Crop koordinatlarına göre yerel quad
    quad_local = quad - np.array([x0, y0], np.float32)

    rectified = _warp_with_landscape(crop, quad_local)

    out = {"rectified": rectified, "quad_page": quad, "crop": crop, "quad_local": quad_local}
    if debug:
        dbg = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
        for i in range(4):
            p1 = tuple(quad[i].astype(int)); p2 = tuple(quad[(i+1)%4].astype(int))
            cv2.line(dbg, p1, p2, (0,255,0), 3)
        out["debug_grid"] = grid
        out["debug_overlay"] = dbg
    return out