from typing import List, Tuple, Optional, Set, Dict

# Tek fonksiyon — GÜNCEL v2
# “Rol ↓ İmza” merge yalnızca union başka bir ROL kutusuyla EN KÜÇÜK temas dahi yoksa yapılır.
# Ayrıca artık TEKİLLEŞTİRME (dedup) KATEGORİ-BAĞIMSIZ yapılmıyor:
#   - union’lar kendi içinde
#   - kalan role’ler kendi içinde
#   - imzalar kendi içinde
#   - sermaye kutuları kendi içinde
# dedup’ta KATEGORİLER ARASI merge YASAK → rol+imza union’ı yanındaki başka bir rol ile
# sonradan birleşip “büyük bir sağ kutu”ya dönüşemez.

def build_final_boxes_onceall(
    role_blocks: List[Tuple[int,int,int,int]],       # [(x,y,w,h)]
    sig_boxes:   List[Tuple[int,int,int,int]],       # [(x,y,w,h)]
    sermaye_boxes: Optional[List[Tuple[int,int,int,int]]] = None,
    *,
    include_unpaired_roles: bool = True,
    include_unpaired_sigs:  bool = True,
    # eşleştirme parametreleri
    require_x_overlap: float = 0.10,                 # min yatay projeksiyon oranı
    max_vertical_gap: Optional[int] = None,          # None: sınırsız
    # tekilleştirme toleransı (kategori içi)
    dedup_near_px: int = 2
) -> Dict[str, List]:
    """
    Döner:
      {
        "final":   List[(x,y,w,h)],
        "pairs":   List[(role_idx, sig_idx)],
        "roles":   List[(x,y,w,h)],      # union’lar HARİÇ yalnızca kalan role’ler
        "sigs":    List[(x,y,w,h)],      # union’lar HARİÇ yalnızca kalan imzalar
        "sermaye": List[(x,y,w,h)],
      }
    """

    # ---------- helpers ----------
    BoxXYWH = Tuple[int,int,int,int]
    BoxLTRB = Tuple[int,int,int,int]

    def to_ltrb(b: BoxXYWH) -> BoxLTRB:
        x,y,w,h = b; return (int(x), int(y), int(x+w), int(y+h))

    def to_xywh(b: BoxLTRB) -> BoxXYWH:
        l,t,r,bm = b; return (int(l), int(t), int(r-l), int(bm-t))

    def union(a: BoxLTRB, b: BoxLTRB) -> BoxLTRB:
        return (min(a[0],b[0]), min(a[1],b[1]), max(a[2],b[2]), max(a[3],b[3]))

    def intersects(a: BoxLTRB, b: BoxLTRB) -> bool:
        return not (a[2] <= b[0] or b[2] <= a[0] or a[3] <= b[1] or b[3] <= a[1])

    def contains(big: BoxLTRB, small: BoxLTRB) -> bool:
        return (big[0] <= small[0]) and (big[1] <= small[1]) and (big[2] >= small[2]) and (big[3] >= small[3])

    def x_overlap_ratio(a: BoxLTRB, b: BoxLTRB) -> float:
        l = max(a[0], b[0]); r = min(a[2], b[2])
        if r <= l: return 0.0
        inter_w = r - l
        min_w = max(1, min(a[2]-a[0], b[2]-b[0]))
        return float(inter_w) / float(min_w)

    def is_below(role: BoxLTRB, sig: BoxLTRB) -> bool:
        return sig[1] >= role[3]

    def vgap(role: BoxLTRB, sig: BoxLTRB) -> int:
        return max(0, sig[1] - role[3])

    def dedup_merge_close(boxes_ltrb: List[BoxLTRB], px: int) -> List[BoxLTRB]:
        if not boxes_ltrb: return []
        boxes = boxes_ltrb[:]
        changed = True
        while changed:
            changed = False
            out: List[BoxLTRB] = []
            used = [False]*len(boxes)
            for i in range(len(boxes)):
                if used[i]: continue
                a = boxes[i]
                for j in range(i+1, len(boxes)):
                    if used[j]: continue
                    b = boxes[j]
                    # yalın yakınlık/temas (kategori içi!)
                    touch = not (a[2] < b[0]-px or b[2] < a[0]-px or
                                 a[3] < b[1]-px or b[3] < a[1]-px)
                    if touch:
                        a = union(a,b)
                        used[j] = True
                        changed = True
                out.append(a)
                used[i] = True
            boxes = out
        return boxes

    # ---------- normalize ----------
    roles_l: List[BoxLTRB] = [to_ltrb(b) for b in (role_blocks or [])]
    sigs_l:  List[BoxLTRB] = [to_ltrb(b) for b in (sig_boxes or [])]
    serm_l:  List[BoxLTRB] = [to_ltrb(b) for b in (sermaye_boxes or [])]

    used_roles: Set[int] = set()
    used_sigs:  Set[int] = set()
    pairs: List[Tuple[int,int]] = []

    unions_l: List[BoxLTRB] = []   # rol∪imza kutuları
    roles_rem_l: List[BoxLTRB] = []  # union’a girmeyen roller
    sigs_rem_l:  List[BoxLTRB] = []  # union’a girmeyen imzalar

    # ---------- 1) ROL → aşağı İMZA ile güvenli birleştirme ----------
    for ri, r in enumerate(roles_l):
        # aday imzalar
        best = None  # (score_tuple, si, s_ltrb, union_ltrb)
        for si, s in enumerate(sigs_l):
            if si in used_sigs: 
                continue
            if not is_below(r, s): 
                continue
            if max_vertical_gap is not None and vgap(r,s) > max_vertical_gap:
                continue
            xo = x_overlap_ratio(r, s)
            if xo < require_x_overlap:
                continue
            u = union(r, s)

            # *** BLOK KONTROLÜ (EN KATI): union başka bir ROL ile en ufak KESİŞİM yapıyorsa IP TAL ***
            blocked = False
            for rj, other in enumerate(roles_l):
                if rj == ri: 
                    continue
                if intersects(u, other):
                    blocked = True; break
            if blocked:
                continue

            score = (xo, -(vgap(r,s)), -(s[3]-s[1]))  # daha iyi hizalanan ve daha yakın olan önce
            if (best is None) or (score > best[0]):
                best = (score, si, s, u)

        if best is not None:
            _, best_si, best_s, best_u = best
            unions_l.append(best_u)
            used_roles.add(ri)
            used_sigs.add(best_si)
            pairs.append((ri, best_si))

    # ---------- 2) Eşleşmeyenleri kategoriye yaz ----------
    if include_unpaired_roles:
        for ri, r in enumerate(roles_l):
            if ri not in used_roles:
                roles_rem_l.append(r)

    if include_unpaired_sigs:
        for si, s in enumerate(sigs_l):
            if si not in used_sigs:
                sigs_rem_l.append(s)

    # ---------- 3) KATEGORİ İÇİ tekilleştirme ----------
    unions_l    = dedup_merge_close(unions_l,    dedup_near_px)
    roles_rem_l = dedup_merge_close(roles_rem_l, dedup_near_px)
    sigs_rem_l  = dedup_merge_close(sigs_rem_l,  dedup_near_px)
    serm_l      = dedup_merge_close(serm_l,      dedup_near_px)

    # ---------- 4) Nihai set (KATEGORİLER ARASI MERGE YOK) ----------
    final_l = unions_l + roles_rem_l + sigs_rem_l + serm_l

    # ---------- 5) Export ----------
    final_xywh = [to_xywh(b) for b in final_l]
    roles_xywh = [to_xywh(b) for b in roles_rem_l]
    sigs_xywh  = [to_xywh(b) for b in sigs_rem_l]
    serm_xywh  = [to_xywh(b) for b in serm_l]

    return {
        "final":   final_xywh,
        "pairs":   pairs,
        "roles":   roles_xywh,     # union’lar hariç
        "sigs":    sigs_xywh,      # union’lar hariç
        "sermaye": serm_xywh,
    }