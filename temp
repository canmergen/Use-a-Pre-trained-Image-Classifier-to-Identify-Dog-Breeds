# -*- coding: utf-8 -*-
import cv2, json, base64, requests, re, numpy as np, pandas as pd
import unicodedata
from typing import Any, List, Tuple, Dict, Optional

# =========================
# 1) Metin normalizasyonu
# =========================
def _strip_diacritics(s: str) -> str:
    return ''.join(c for c in unicodedata.normalize('NFD', s or "") if not unicodedata.combining(c))

def _norm_text(s: str) -> str:
    s = (s or "").upper()
    s = _strip_diacritics(s)
    s = re.sub(r"\s+", " ", s).strip()
    return s

def _lev(a: str, b: str) -> int:
    a, b = a or "", b or ""
    if a == b: return 0
    la, lb = len(a), len(b)
    if la == 0: return lb
    if lb == 0: return la
    dp = list(range(lb+1))
    for i, ca in enumerate(a, 1):
        prev = dp[0]
        dp[0] = i
        for j, cb in enumerate(b, 1):
            cur = dp[j]
            cost = 0 if ca == cb else 1
            dp[j] = min(dp[j]+1, dp[j-1]+1, prev+cost)
            prev = cur
    return dp[-1]

def _sim(a: str, b: str) -> float:
    a_n, b_n = _norm_text(a), _norm_text(b)
    if not a_n or not b_n: return 0.0
    m = max(len(a_n), len(b_n))
    d = _lev(a_n, b_n)
    return 1.0 - d / max(1, m)

# =========================
# 2) Rol & İsim heuristics
# =========================
ROLE_ALIASES: Dict[str, List[str]] = {
    "toplanti_baskani":    ["TOPLANTI BAŞKANI","TOPLANTI BASKANI","DIVAN BAŞKANI","DIVAN BASKANI"],
    "tutanak_yazmani":     ["TUTANAK YAZMANI","YAZMAN","OY TOPLAMA MEMURU","OY TOPLAYICI"],
    "bakanlik_temsilcisi": ["BAKANLIK TEMSİLCİSİ","TİCARET BAKANLIĞI TEMSİLCİSİ","TICARET BAKANLIGI TEMSILCISI"],
    "yk_uyesi":            ["YÖNETİM KURULU ÜYESİ","YONETIM KURULU UYESI","YK ÜYESİ","YK UYESI","YÖNETİM KURULU ÜYELERİ","YONETIM KURULU UYELERI"],
    "yk_baskani":          ["YÖNETİM KURULU BAŞKANI","YONETIM KURULU BASKANI","YK BAŞKANI","YK BASKANI"],
    "katip":               ["KÂTİP","KATİP","KATIP","OY TOPLAYICI","OY TOPLAMA MEMURU"],
    "divan_baskani":       ["DİVAN BAŞKANI","DIVAN BASKANI"],
}
ROLE_PRIORITY = ["toplanti_baskani","yk_baskani","bakanlik_temsilcisi","tutanak_yazmani","katip","yk_uyesi","divan_baskani"]

# ad-soyad yakalayıcı
NAME_TOKEN = re.compile(r"[A-ZÇĞİÖŞÜ]{2,}(?:\s+[A-ZÇĞİÖŞÜ]{2,})+")

# kutudaki etiket metninden sonra isim ara (1–3 satır)
def _extract_name_after_label(raw: str, label_aliases: List[str]) -> Optional[str]:
    lines = [ln.strip() for ln in (raw or "").splitlines() if ln.strip()]
    if not lines: return None
    norm_lines = [_norm_text(ln) for ln in lines]
    norm_alias = [_norm_text(a) for a in label_aliases]
    idx = None
    for i, nl in enumerate(norm_lines):
        if any(na in nl for na in norm_alias):
            idx = i; break
    if idx is None: return None
    for j in range(idx+1, min(idx+4, len(lines))):
        cand = lines[j]
        if sum(ch.isdigit() for ch in cand) > 3:   # TCKN/numara satırlarını at
            continue
        if NAME_TOKEN.search(_norm_text(cand)):
            return " ".join(tok.capitalize() for tok in cand.split())
    return None

# genel isim çıkarımı (etiket bağımsız)
DROP_WORDS = ["TOPLANTI","BAŞKANI","BASKANI","YÖNETİM","KURULU","ÜYESİ","UYESI","YK",
              "BAKANLIK","TEMSİLCİSİ","TEMSILCISI","KATİP","KATIP","YAZMANI",
              "DİVAN","DIVAN","İMZA","IMZA","KAŞE","KASE","MÜHÜR","MUHUR","STAMP",
              "ASALATEN","VEKALETEN","HAZIRUN","HAZİRUN","ÜYELERİ","UYELERI","ÜYELER","UYELER"]
def _extract_name_general(text_u: str) -> Optional[str]:
    t = text_u or ""
    for w in DROP_WORDS:
        t = re.sub(rf"\b{w}\b", " ", t, flags=re.IGNORECASE)
    t = re.sub(r"[^A-ZÇĞİÖŞÜa-zçğıöşü\.\-\'\s]", " ", t).upper()
    t = re.sub(r"\s+", " ", t).strip()
    m = NAME_TOKEN.search(t)
    if m: 
        return m.group(0).title()
    parts = [p for p in t.split() if len(p) >= 2]
    return " ".join(parts[-3:]).title() if len(parts) >= 2 else None

# metinden birden fazla isim bloğu çıkar (yk_uyesi için)
ROLE_PREFIX_PATTERNS = [
    r"YÖNETİM KURULU ÜYELERİ[:\-]?",
    r"YONETIM KURULU UYELERI[:\-]?",
    r"YÖNETİM KURULU ÜYESİ[:\-]?",
    r"YONETIM KURULU UYESI[:\-]?",
]
def extract_all_names(raw: str) -> List[str]:
    txt = (raw or "")
    # baştaki "Yönetim Kurulu Üyeleri:" vb. kaldır
    for pat in ROLE_PREFIX_PATTERNS:
        txt = re.sub(pat, " ", txt, flags=re.IGNORECASE)
    # parçalara böl
    blocks = re.split(r"[;,•\|]+", txt)
    names = []
    for b in blocks:
        nu = _norm_text(b)
        for w in DROP_WORDS:
            nu = re.sub(rf"\b{_norm_text(w)}\b", " ", nu)
        nu = re.sub(r"\s+", " ", nu).strip()
        m = NAME_TOKEN.search(nu)
        if m:
            names.append(" ".join(tok.capitalize() for tok in m.group(0).split()))
    # tekrarları sil
    uniq = []
    for n in names:
        if n not in uniq: uniq.append(n)
    return uniq

def cleanup_name(name: Optional[str]) -> Optional[str]:
    if not name: return None
    n = _strip_diacritics(name).strip()
    n = re.sub(r"\s+", " ", n)
    return " ".join(tok.capitalize() for tok in n.split())

# =========================
# 3) Kutu norm. & çizim
# =========================
def _to_xywh(b: Any) -> Optional[Tuple[int,int,int,int]]:
    if isinstance(b, (tuple, list, np.ndarray)) and len(b) == 4:
        x,y,w,h = [int(round(float(v))) for v in b];  return (x,y,w,h)
    for attrs in [("x","y","w","h"), ("left","top","width","height")]:
        if all(hasattr(b, a) for a in attrs):
            x,y,w,h = [int(round(float(getattr(b,a)))) for a in attrs];  return (x,y,w,h)
    for attrs in [("x0","y0","x1","y1"), ("left","top","right","bottom")]:
        if all(hasattr(b, a) for a in attrs):
            x0,y0,x1,y1 = [float(getattr(b,a)) for a in attrs]
            return (int(round(x0)), int(round(y0)), int(round(x1-x0)), int(round(y1-y0)))
    if isinstance(b, dict):
        if all(k in b for k in ("x","y","w","h")):
            return (int(b["x"]), int(b["y"]), int(b["w"]), int(b["h"]))
        if all(k in b for k in ("x0","y0","x1","y1")):
            return (int(b["x0"]), int(b["y0"]), int(b["x1"]-b["x0"]), int(b["y1"]-b["y0"]))
    return None

def normalize_boxes(boxes: List[Any]) -> List[Tuple[int,int,int,int]]:
    out=[]
    for b in boxes:
        nb = _to_xywh(b)
        if nb is None: continue
        x,y,w,h = nb
        if w>0 and h>0: out.append((x,y,w,h))
    return out

def draw_boxes_with_ids(img_bgr: np.ndarray,
                        boxes_xywh: List[Tuple[int,int,int,int]],
                        thickness: int = 2) -> np.ndarray:
    vis = img_bgr.copy()
    if vis.ndim == 2:
        vis = cv2.cvtColor(vis, cv2.COLOR_GRAY2BGR)
    for i,(x,y,w,h) in enumerate(boxes_xywh):
        cv2.rectangle(vis, (x,y), (x+w, y+h), (0,200,0), thickness)
        cv2.putText(vis, f"{i}", (x+4, y+18), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,120,0), 2, cv2.LINE_AA)
    return vis

# =========================
# 4) OCR (NEW_URL) & İmza
# =========================
def _ocr_remote_png(img_bgr: np.ndarray, url: str,
                    lang: str="tur", config: str="--psm 6 --oem 1") -> str:
    ok, buf = cv2.imencode(".png", img_bgr)
    if not ok: return ""
    img_b64 = base64.b64encode(buf).decode()
    payload = {"image": img_b64, "lang": lang, "config": config}
    try:
        r = requests.post(url, json=payload, timeout=30)
        if r.ok:
            j = json.loads(r.text)
            return (j.get("text") or "").strip()
    except Exception:
        pass
    return ""

def ocr_text_from_box_remote(img: np.ndarray, box_xywh: Tuple[int,int,int,int], url: str) -> str:
    x,y,w,h = box_xywh
    roi = img[y:y+h, x:x+w]
    if roi.ndim==2:
        roi = cv2.cvtColor(roi, cv2.COLOR_GRAY2BGR)
    return _ocr_remote_png(roi, url=url, lang="tur", config="--psm 6 --oem 1")

def has_signature_relaxed(
    img: np.ndarray, box_xywh: Tuple[int,int,int,int],
    ink_ratio_min: float = 0.002,  # daha esnek
    ink_ratio_max: float = 0.35,   # çok dolu (metin+kutu) alanlarını ele
    diag_deg_min: float = 10,      # en az bir eğik çizgi olsun
    ske_len_min: int = 40,
    debug: bool = False
) -> bool:
    x,y,w,h = box_xywh
    roi = img[y:y+h, x:x+w]
    gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY) if roi.ndim==3 else roi
    hh, ww = gray.shape[:2]
    if min(hh, ww) < 18:  # çok küçükse imza bekleme
        return False

    g2  = cv2.GaussianBlur(gray,(3,3),0)
    thr = cv2.threshold(g2, 0, 255, cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)[1]
    ink_ratio = cv2.countNonZero(thr) / float(max(1, hh*ww))
    if not (ink_ratio_min <= ink_ratio <= ink_ratio_max):
        return False

    # çizgi/iskelet ipucu (eğik stroke var mı?)
    edges = cv2.Canny(thr, 50, 150)
    lines = cv2.HoughLinesP(edges, 1, np.pi/180, threshold=18, minLineLength=18, maxLineGap=10)
    diag_ok = False
    if lines is not None:
        for l in lines[:80]:
            x1,y1,x2,y2 = l[0]
            ang = abs(np.degrees(np.arctan2((y2-y1), (x2-x1))))
            if 10 <= ang <= 170 and not (80 <= ang <= 100):  # eğik
                diag_ok = True; break

    # basit iskelet uzunluğu
    skel = cv2.ximgproc.thinning(thr) if hasattr(cv2, "ximgproc") else None
    ske_len = int(cv2.countNonZero(skel)/1.0) if skel is not None else int(cv2.countNonZero(edges)/2)

    if debug:
        print(f"[sig_debug] ink={ink_ratio:.3f} diag={diag_ok} skelen={ske_len}")
    return diag_ok and ske_len >= ske_len_min

# =========================
# 5) Rol skoru & kutu inceleme
# =========================
def _alias_score(text_u: str, alias: str) -> float:
    ta = _norm_text(text_u); aa = _norm_text(alias)
    if not ta or not aa: return 0.0
    toks_t = ta.split()
    toks_a = aa.split()
    # ortalama token benzerliği
    bests = []
    for a in toks_a:
        best = max((_sim(a, t) for t in toks_t), default=0.0)
        bests.append(best)
    base = float(np.mean(bests)) if bests else 0.0
    # bonus: alias tamamen içeriliyorsa
    if aa in ta: base = max(base, 1.0)
    return base

def best_role_for_text(text_u: str) -> Tuple[Optional[str], float]:
    scores = []
    for rk, aliases in ROLE_ALIASES.items():
        sc = max((_alias_score(text_u, a) for a in aliases), default=0.0)
        scores.append((rk, sc))
    scores.sort(key=lambda t: (t[1], -ROLE_PRIORITY.index(t[0]) if t[0] in ROLE_PRIORITY else 99), reverse=True)
    return scores[0]

def inspect_boxes(lower_img: np.ndarray,
                  boxes: List[Any],
                  NEW_URL: str,
                  role_threshold: float = 0.8,
                  debug: bool = True) -> Tuple[np.ndarray, pd.DataFrame]:
    """
    Dönüş:
      vis_img: kutular + indexlerin çizildiği görsel (BGR)
      per_box_df: i,bbox,sig,role_best,role_score,name_in_box,text_preview
    """
    boxes_xywh = normalize_boxes(boxes)
    vis_img = draw_boxes_with_ids(lower_img, boxes_xywh)

    rows = []
    for i,b in enumerate(boxes_xywh):
        txt = ocr_text_from_box_remote(lower_img, b, NEW_URL).strip()
        txt_u = _norm_text(txt)
        sig  = has_signature_relaxed(lower_img, b, debug=False)

        role_key, score = best_role_for_text(txt_u)
        if score >= role_threshold and role_key:
            nm_after = _extract_name_after_label(txt, ROLE_ALIASES.get(role_key, []))
            name_in = cleanup_name(nm_after) if nm_after else cleanup_name(_extract_name_general(txt_u))
        else:
            role_key, score, name_in = None, 0.0, None

        rows.append({
            "i": i, "bbox": b, "sig": bool(sig),
            "role_best": role_key, "role_score": float(score),
            "name_in_box": name_in,
            "text_preview": re.sub(r"\s+", " ", txt_u)[:200]
        })

    per_box_df = pd.DataFrame(rows, columns=["i","bbox","sig","role_best","role_score","name_in_box","text_preview"])
    if debug:
        print(f"[INFO] {len(boxes_xywh)} box")
        display(per_box_df)
    return vis_img, per_box_df

# =========================
# 6) Bilinen isimlerle doğrulama
# =========================
def best_name_from_candidates(ocr_name: str, known_names: List[str], sim_thr: float = 0.80) -> Optional[str]:
    if not ocr_name or not known_names: return cleanup_name(ocr_name)
    best = None; best_s = 0.0
    for kn in known_names:
        s = _sim(ocr_name, kn)
        if s > best_s:
            best_s, best = s, kn
    return best if best and best_s >= sim_thr else cleanup_name(ocr_name)

def map_names_to_known(names: List[str], known_names: List[str], sim_thr: float = 0.80) -> List[str]:
    out = []
    for n in names:
        m = best_name_from_candidates(n, known_names, sim_thr)
        if m:
            if m not in out: out.append(m)
    return out

# =========================
# 7) Rapor → bottom_df
# =========================
def build_bottom_df_from_report(
    lower_img: np.ndarray,
    boxes: List[Any],
    per_box_df: pd.DataFrame,
    known_names: Optional[List[str]] = None,  # tablodan gelen adlar
    role_threshold: float = 0.8
) -> pd.DataFrame:

    boxes_xywh = normalize_boxes(boxes)

    # --- Sermaye tamsayı olarak çek ---
    texts_u = [str(r.get("text_preview") or "") for _,r in per_box_df.iterrows()]
    def _parse_tl_int(text: str) -> Optional[int]:
        # 1.000.000,00 TL ; 50.000 TL ; 1000000 ₺ vb.
        nums = re.findall(r"(\d{1,3}(?:\.\d{3})+|\d+)(?:[,\.]\d{2})?\s*(?:TL|₺)?", text or "", flags=re.IGNORECASE)
        best = None
        for n in nums:
            v = int(re.sub(r"[^\d]", "", n))
            if best is None or v > best: best = v
        return best

    cap_keys = ["ŞİRKETİN SERMAYESİ","SERMAYESİ VE PAYLARIN TOPLAMI","TOPLAM İTİBARİ DEĞERİ","SERMAYE"]
    scores = [ (sum(k in t for k in cap_keys), idx) for idx,t in enumerate(texts_u) ]
    scores.sort(reverse=True)
    sermaye = None
    for sc, idx in scores[:3]:
        if sc == 0: break
        for j in [idx-1, idx, idx+1]:
            if 0 <= j < len(texts_u):
                v = _parse_tl_int(texts_u[j])
                if v is not None: sermaye = v; break
        if sermaye is not None: break
    if sermaye is None:
        vals = [_parse_tl_int(t) for t in texts_u]
        sermaye = max([v for v in vals if v is not None], default=None)

    out = {
        "sermaye_toplam_tl": sermaye,
        "toplanti_baskani_ad_soyad": None, "toplanti_baskani_imza_var_mi": None,
        "tutanak_yazmani_ad_soyad": None,  "tutanak_yazmani_imza_var_mi": None,
        "bakanlik_temsilcisi_ad_soyad": None, "bakanlik_temsilcisi_imza_var_mi": None,
        "yk_uyesi_ad_soyad": None, "yk_uyesi_imza_var_mi": None,
        "yk_baskani_ad_soyad": None, "yk_baskani_imza_var_mi": None,
        "katip_ad_soyad": None, "katip_imza_var_mi": None,
        "divan_baskani_ad_soyad": None, "divan_baskani_imza_var_mi": None,
    }

    key_map = {
        "toplanti_baskani": ("toplanti_baskani_ad_soyad","toplanti_baskani_imza_var_mi"),
        "tutanak_yazmani":  ("tutanak_yazmani_ad_soyad","tutanak_yazmani_imza_var_mi"),
        "bakanlik_temsilcisi": ("bakanlik_temsilcisi_ad_soyad","bakanlik_temsilcisi_imza_var_mi"),
        "yk_uyesi":         ("yk_uyesi_ad_soyad","yk_uyesi_imza_var_mi"),
        "yk_baskani":       ("yk_baskani_ad_soyad","yk_baskani_imza_var_mi"),
        "katip":            ("katip_ad_soyad","katip_imza_var_mi"),
        "divan_baskani":    ("divan_baskani_ad_soyad","divan_baskani_imza_var_mi"),
    }

    def _set_role(role_key: str, name_val: Optional[str], sig_val: Optional[bool]):
        if role_key not in key_map: return
        k_name, k_sig = key_map[role_key]
        if out[k_name] is None and name_val:
            out[k_name] = cleanup_name(name_val)
        # İMZA: sadece KENDİ kutusundan gelen değeri yazarız (komşudan ASLA devşirme yok)
        if out[k_sig] is None and sig_val is not None:
            out[k_sig] = bool(sig_val)

    # per_box_df’den tek tek ilerle
    for _, r in per_box_df.iterrows():
        rk   = r.get("role_best")
        scr  = float(r.get("role_score") or 0.0)
        if not rk or scr < role_threshold: 
            continue

        name_here = r.get("name_in_box")
        sig_here  = bool(r.get("sig", False))  # sadece bu box!

        # YK ÜYESİ → birden fazla isim olabilir
        if rk == "yk_uyesi":
            raw = str(r.get("text_preview") or "")
            extracted = extract_all_names(raw)           # OCR’dan isim adayları
            if known_names:
                mapped = map_names_to_known(extracted, [ _norm_text(n) for n in known_names ], sim_thr=0.80)
                # known_names Title Case değilse normalize et
                mapped = [ " ".join(t.capitalize() for t in _strip_diacritics(n).split()) for n in mapped ]
            else:
                mapped = [cleanup_name(n) for n in extracted]
            if mapped:
                _set_role(rk, "; ".join(mapped), sig_here)
            else:
                # fallback: tek isim varsa onu yaz
                if name_here:
                    # tek isim de known_names’e yakınsa düzelt
                    if known_names:
                        best = best_name_from_candidates(name_here, known_names, sim_thr=0.80)
                        name_here = best or name_here
                    _set_role(rk, name_here, sig_here)

        else:
            # tek kişi roller
            if name_here and known_names:
                name_here = best_name_from_candidates(name_here, known_names, sim_thr=0.80)
            _set_role(rk, name_here, sig_here)

    return pd.DataFrame([out])