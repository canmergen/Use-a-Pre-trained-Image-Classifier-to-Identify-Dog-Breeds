# pip: rapidfuzz
from typing import List, Dict, Any, Tuple, Optional
import re
import pandas as pd
from rapidfuzz import fuzz

DIGIT_RX = re.compile(r"[\d][\d\.\,\s]*")

def _norm(s: str) -> str:
    return (s or "").casefold()

def _has_digits(s: str) -> bool:
    return bool(DIGIT_RX.search(s or ""))

def _extract_number_str(s: str) -> Optional[str]:
    m = DIGIT_RX.search(s or "")
    return m.group(0).strip() if m else None

def _parse_tr_number(num_str: str) -> Optional[float]:
    """
    Turkish-style parsing:
      12.050,00  -> 12050.00
      12,050.00  -> 12050.00 (fallback)
      12050      -> 12050.0
    """
    if not num_str:
        return None
    s = num_str.strip()
    # Choose pattern by last separator
    if "," in s and s.rfind(",") > s.rfind("."):
        # comma decimal, dot thousands
        s = s.replace(".", "").replace(",", ".")
    else:
        # dot decimal, comma thousands
        s = s.replace(",", "")
    try:
        return float(s)
    except Exception:
        return None

def _get_center(b: Dict[str, int]) -> Tuple[float, float]:
    return ( (b["x_min"] + b["x_max"]) / 2.0, (b["y_min"] + b["y_max"]) / 2.0 )

def _height(b: Dict[str, int]) -> int:
    return b.get("height", b["y_max"] - b["y_min"])

def _reading_order(items: List[Dict[str, Any]]) -> List[int]:
    # Sort top-to-bottom, then left-to-right
    return sorted(range(len(items)), key=lambda i: (items[i]["bbox"]["y_min"], items[i]["bbox"]["x_min"]))

def _same_line(a: Dict[str,int], b: Dict[str,int], line_tol: float) -> bool:
    # same line if vertical centers within tolerance of label height
    ya = (a["y_min"] + a["y_max"]) / 2
    yb = (b["y_min"] + b["y_max"]) / 2
    h  = max(_height(a), 1)
    return abs(ya - yb) <= line_tol * h

def _nearest_value_on_right(items, idx_label, max_dx: int, line_tol: float) -> Optional[int]:
    A = items[idx_label]["bbox"]
    cxA, _ = _get_center(A)
    best_i, best_dx = None, None
    for i, it in enumerate(items):
        if i == idx_label:
            continue
        B = it["bbox"]
        # must be on right, same line
        if B["x_min"] <= cxA:
            continue
        if not _same_line(A, B, line_tol):
            continue
        if not _has_digits(it.get("text","")):
            continue
        dx = B["x_min"] - cxA
        if 0 <= dx <= max_dx and (best_dx is None or dx < best_dx):
            best_i, best_dx = i, dx
    return best_i

def extract_sermaye_df(
    pages_scaled: List[List[Dict[str, Any]]],
    fuzzy_threshold: int = 80,
    line_tol: float = 0.8,
    max_dx: int = 1600,    # pixels to the right to search
) -> pd.DataFrame:
    """
    Returns a DataFrame with:
      page_idx, label_text, label_bbox, value_text, value_bbox, value_str, value_num
    """
    rows = []
    for pidx, items in enumerate(pages_scaled):
        if not items:
            continue

        # prepare reading order
        order = _reading_order(items)
        pos = {i: k for k, i in enumerate(order)}

        for i, itm in enumerate(items):
            txt = _norm(itm.get("text",""))
            if not txt:
                continue

            # fuzzy match against 'sermaye' variants
            score = max(
                fuzz.partial_ratio(txt, "sermaye"),
                fuzz.partial_ratio(txt, "sermayesi"),
                fuzz.partial_ratio(txt, "ödenmiş sermaye"),
                fuzz.partial_ratio(txt, "çıkarılmış sermaye"),
            )

            if score < fuzzy_threshold:
                continue  # not a sermaye label

            label_bbox = itm["bbox"]
            value_i = None
            value_txt = None
            value_bbox = None
            value_str = None
            value_num = None

            # 1) try same box
            value_str = _extract_number_str(itm.get("text",""))
            if value_str:
                value_txt = itm.get("text","")
                value_bbox = label_bbox
                value_num = _parse_tr_number(value_str)
            else:
                # 2) try right neighbor on same line
                cand = _nearest_value_on_right(items, i, max_dx=max_dx, line_tol=line_tol)
                if cand is not None:
                    value_i = cand
                else:
                    # 3) fall back to reading-order neighbor (next then previous)
                    k = pos[i]
                    neigh = []
                    if k+1 < len(order): neigh.append(order[k+1])
                    if k-1 >= 0:        neigh.append(order[k-1])
                    for j in neigh:
                        if _has_digits(items[j].get("text","")):
                            value_i = j
                            break

                if value_i is not None:
                    value_txt = items[value_i].get("text","")
                    value_bbox = items[value_i]["bbox"]
                    value_str  = _extract_number_str(value_txt)
                    value_num  = _parse_tr_number(value_str) if value_str else None

            rows.append({
                "page_idx": pidx,
                "label_text": itm.get("text",""),
                "label_bbox": label_bbox,
                "value_text": value_txt,
                "value_bbox": value_bbox,
                "value_str":  value_str,
                "value_num":  value_num,
            })

    return pd.DataFrame(rows)

def merge_into_bottom_df(bottom_df: pd.DataFrame, sermaye_df: pd.DataFrame) -> pd.DataFrame:
    """
    Example merge policy:
      - keep only rows with a parsed numeric value
      - pick the largest 'value_num' per page (often the correct capital figure)
      - append/merge into bottom_df with columns ['page_idx','sermaye_value','sermaye_bbox']
    Adjust to your schema.
    """
    valid = sermaye_df.dropna(subset=["value_num"]).copy()
    if valid.empty:
        return bottom_df

    best = (valid.sort_values(["page_idx","value_num"], ascending=[True,False])
                 .groupby("page_idx", as_index=False)
                 .first()[["page_idx","value_num","value_bbox"]]
                 .rename(columns={"value_num":"sermaye_value","value_bbox":"sermaye_bbox"}))

    # left-join on page_idx; create if missing
    if bottom_df is None or bottom_df.empty:
        return best
    out = bottom_df.merge(best, on="page_idx", how="left")
    return out

sermaye_df = extract_sermaye_df(pages_scaled, fuzzy_threshold=80, line_tol=0.8, max_dx=1600)
# Inspect
display(sermaye_df.head(10))

# Merge into your bottom_df (adapt to your schema)
bottom_df = merge_into_bottom_df(bottom_df, sermaye_df)

import re

# Recognize common Turkish/EN money formats
_RX_COMMA_DEC  = re.compile(r"^\s*\d{1,3}(?:\.\d{3})*,\d{1,2}\s*")   # 1.234,56
_RX_DOT_DEC    = re.compile(r"^\s*\d{1,3}(?:,\d{3})*\.\d{1,2}\s*")   # 1,234.56
_RX_DOTS_THOUS = re.compile(r"^\s*\d{1,3}(?:\.\d{3})+\s*$")          # 12.050.000
_RX_COMM_THOUS = re.compile(r"^\s*\d{1,3}(?:,\d{3})+\s*$")           # 12,050,000
_RX_INTEGER    = re.compile(r"^\s*\d+\s*$")                          # 12050000

def _parse_tr_number(num_str: str) -> float | None:
    """
    Robust parsing for:
      - '12.050.000' -> 12050000
      - '12,050,000' -> 12050000
      - '12.050,00'  -> 12050.00
      - '12,050.00'  -> 12050.00
      - '12050000'   -> 12050000
    Ignores currency symbols and spaces.
    """
    if not num_str:
        return None

    s = num_str.strip()
    # remove currency/text noise
    s = s.replace("TL", "").replace("₺", "").replace("TRY", "")
    s = s.replace("tL", "").replace("Tl", "")
    s = s.strip()

    # Detect patterns in priority order
    if _RX_COMMA_DEC.match(s):
        # comma is decimal, dots are thousands
        s = s.replace(".", "").replace(",", ".")
        try:
            return float(s)
        except ValueError:
            return None

    if _RX_DOT_DEC.match(s):
        # dot is decimal, commas are thousands
        s = s.replace(",", "")
        try:
            return float(s)
        except ValueError:
            return None

    if _RX_DOTS_THOUS.match(s):
        # only thousands dots
        s = s.replace(".", "")
        try:
            return float(s)
        except ValueError:
            return None

    if _RX_COMM_THOUS.match(s):
        # only thousands commas
        s = s.replace(",", "")
        try:
            return float(s)
        except ValueError:
            return None

    if _RX_INTEGER.match(s):
        try:
            return float(s)
        except ValueError:
            return None

    # Fallback: last separator heuristic
    last_dot   = s.rfind(".")
    last_comma = s.rfind(",")
    if last_comma > last_dot >= 0:
        # treat comma as decimal, dots as thousands
        s = s.replace(".", "").replace(",", ".")
    elif last_dot > last_comma >= 0:
        # treat dot as decimal, commas as thousands
        s = s.replace(",", "")
    else:
        # no clear decimal: strip both
        s = s.replace(".", "").replace(",", "")

    try:
        return float(s)
    except ValueError:
        return None