# -*- coding: utf-8 -*-
import cv2, json, base64, requests, re, numpy as np, pandas as pd
import unicodedata
from typing import Any, List, Tuple, Dict, Optional

# ----------------------------
# Metin normalizasyonu & benzerlik
# ----------------------------
def _strip_diacritics(s: str) -> str:
    return ''.join(c for c in unicodedata.normalize('NFKD', s) if not unicodedata.combining(c))

def _norm_text(s: str) -> str:
    s = (s or "").upper()
    s = _strip_diacritics(s)
    s = re.sub(r"\s+", " ", s).strip()
    return s

def _lev(a: str, b: str) -> int:
    if a == b: return 0
    la, lb = len(a), len(b)
    if la == 0: return lb
    if lb == 0: return la
    dp = list(range(lb + 1))
    for i, ca in enumerate(a, 1):
        prev = dp[0]
        dp[0] = i
        for j, cb in enumerate(b, 1):
            cur = dp[j]
            cost = 0 if ca == cb else 1
            dp[j] = min(dp[j] + 1, dp[j-1] + 1, prev + cost)
            prev = cur
    return dp[-1]

def _sim(a: str, b: str) -> float:
    a = _norm_text(a); b = _norm_text(b)
    if not a or not b: return 0.0
    d = _lev(a, b)
    return 1.0 - d / max(len(a), len(b))

# ----------------------------
# Roller & label eşlemesi
# ----------------------------
ROLE_ALIASES: Dict[str, List[str]] = {
    "toplanti_baskani":    ["TOPLANTI BAŞKANI", "TOPLANTI BASKANI", "DIVAN BAŞKANI", "DIVAN BASKANI"],
    "tutanak_yazmani":     ["TUTANAK YAZMANI", "YAZMAN"],
    "bakanlik_temsilcisi": ["BAKANLIK TEMSİLCİSİ", "TİCARET BAKANLIĞI TEMSİLCİSİ", "TICARET BAKANLIGI TEMSILCISI"],
    "yk_uyesi":            ["YÖNETİM KURULU ÜYESİ", "YONETIM KURULU UYESI", "YK ÜYESİ", "YK UYESI", "YÖNETİM KURULU ÜYELERİ"],
    "yk_baskani":          ["YÖNETİM KURULU BAŞKANI", "YONETIM KURULU BASKANI", "YK BAŞKANI", "YK BASKANI"],
    "katip":               ["KÂTİP", "KATİP", "OY TOPLAYICI", "OY TOPLAMA MEMURU", "OY TOPLAYAN"],
    "divan_baskani":       ["DİVAN BAŞKANI", "DIVAN BASKANI"],
}

ROLE_NGRAMS = [
    "TOPLANTI", "TOPLANTİ", "TOPLANTl", "BAŞKANI", "BASKANI",
    "DİVAN", "DIVAN", "YÖNETİM", "KURULU", "ÜYESİ", "UYESI", "ÜYELERİ", "UYE", "UYESI",
    "BAKANLIK", "TEMSİLCİSİ", "TEMSILCISI", "KÂTİP", "KATİP", "YAZMANI", "YK",
]

NAME_TOKEN = re.compile(r"[A-ZÇĞİÖŞÜ]{2,}(?:\s+[A-ZÇĞİÖŞÜ]{2,})+")

def looks_like_role_text(t: str) -> bool:
    t = _norm_text(t)
    if not t: return False
    return any(g in t for g in ROLE_NGRAMS)

def alias_score(text_u: str, alias: str) -> float:
    # token overlap + edit-sim karışımı
    ta = _norm_text(text_u).split()
    tb = _norm_text(alias).split()
    if not ta or not tb: return 0.0
    overlap = len(set(ta) & set(tb)) / max(1, len(tb))
    ed = _sim(text_u, alias)
    return 0.6 * overlap + 0.4 * ed

def best_role_for_text(text_u: str, role_threshold: float=0.8) -> Tuple[Optional[str], float]:
    if not looks_like_role_text(text_u):
        return None, 0.0
    best_role, best_score = None, 0.0
    for rk, aliases in ROLE_ALIASES.items():
        sc = max((alias_score(text_u, a) for a in aliases), default=0.0)
        if sc > best_score:
            best_role, best_score = rk, sc
    if best_score >= role_threshold:
        return best_role, best_score
    return None, best_score

# ----------------------------
# İsim çıkarma (OCR metninden)
# ----------------------------
DROP_WORDS = ["TOPLANTI","BAŞKANI","BASKANI","YÖNETİM","KURULU","ÜYESİ","UYESI","ÜYELERİ",
              "BAKANLIK","TEMSİLCİSİ","TEMSILCISI","KATİP","KÂTİP","YAZMANI",
              "DİVAN","DIVAN","İMZA","IMZA","KAŞE","MÜHÜR","STAMP",
              "ASALATEN","VEKALETEN","HAZIRUN","HAZİRUN","ÜYELERİ","U YELERİ"]

def extract_name_general(text_u: str) -> Optional[str]:
    t = text_u or ""
    for w in DROP_WORDS:
        t = re.sub(rf"\b{w}\b", " ", t, flags=re.IGNORECASE)
    t = re.sub(r"[^A-ZÇĞİÖŞÜa-zçğıöşü\.\-\'\s]", " ", t).upper()
    t = re.sub(r"\s+", " ", t).strip()
    m = NAME_TOKEN.search(t)
    if m:
        return " ".join(p.capitalize() for p in m.group(0).split())
    # fallback: sondan 2-3 kelime
    parts = [p for p in t.split() if len(p) >= 2]
    return " ".join(parts[-3:]).title() if len(parts) >= 2 else None

def extract_all_names(text: str) -> List[str]:
    """Metindeki tüm olası ad-soyad bloklarını sırayla döndürür."""
    raw = text or ""
    # başlık türevlerini temizle
    t = raw
    for w in DROP_WORDS:
        t = re.sub(rf"\b{_norm_text(w)}\b", " ", _norm_text(t))
    # orijinal hamdan isim yakala
    names = []
    for m in NAME_TOKEN.finditer(_norm_text(raw)):
        nm = m.group(0)
        nm = " ".join(p.capitalize() for p in nm.split())
        if nm not in names:
            names.append(nm)
    return names

def extract_name_after_label(text: str, label_aliases: List[str]) -> Optional[str]:
    raw = text or ""
    lines = [ln.strip() for ln in raw.splitlines() if ln.strip()]
    if not lines:
        return None
    norm_lines = [_norm_text(ln) for ln in lines]
    norm_aliases = [_norm_text(a) for a in label_aliases]
    label_idx = None
    for i, nl in enumerate(norm_lines):
        if any(na in nl for na in norm_aliases):
            label_idx = i; break
    if label_idx is None:
        return None
    for j in range(label_idx + 1, min(label_idx + 4, len(lines))):
        cand = lines[j]
        if sum(ch.isdigit() for ch in cand) > 3:
            continue
        if NAME_TOKEN.search(_norm_text(cand)):
            return " ".join(tok.capitalize() for tok in cand.split())
    return None

def cleanup_name(name: Optional[str]) -> Optional[str]:
    if not name: return None
    name = _strip_diacritics(name).strip()
    name = re.sub(r"\s+", " ", name)
    return " ".join(tok.capitalize() for tok in name.split())

# known_names → tek doğru kaynak
def best_name_from_candidates(raw: str, known_names: List[str], sim_thr: float=0.80) -> Optional[str]:
    if not raw or not known_names: return None
    rn = _norm_text(raw)
    best, best_s = None, 0.0
    for kn in known_names:
        s = _sim(rn, _norm_text(kn))
        if s > best_s:
            best, best_s = kn, s
    return best if best_s >= sim_thr else None

def match_names_to_known(raw_names: List[str], known_names: List[str], sim_thr: float=0.80) -> List[str]:
    out = []
    for cand in raw_names:
        best = best_name_from_candidates(cand, known_names, sim_thr=sim_thr)
        if best and best not in out:
            out.append(best)
    return out

# ----------------------------
# Box normalizasyonu & çizim
# ----------------------------
def _to_xywh(b: Any) -> Optional[Tuple[int,int,int,int]]:
    if isinstance(b, (tuple, list, np.ndarray)) and len(b) == 4:
        x,y,w,h = [int(round(float(v))) for v in b];  return (x,y,w,h)
    for attrs in [("x","y","w","h"), ("left","top","width","height")]:
        if all(hasattr(b, a) for a in attrs):
            x,y,w,h = [int(round(float(getattr(b,a)))) for a in attrs];  return (x,y,w,h)
    for attrs in [("x0","y0","x1","y1"), ("left","top","right","bottom")]:
        if all(hasattr(b, a) for a in attrs):
            x0,y0,x1,y1 = [float(getattr(b,a)) for a in attrs]
            return (int(round(x0)), int(round(y0)), int(round(x1-x0)), int(round(y1-y0)))
    if isinstance(b, dict):
        if all(k in b for k in ("x","y","w","h")):
            return (int(b["x"]), int(b["y"]), int(b["w"]), int(b["h"]))
        if all(k in b for k in ("x0","y0","x1","y1")):
            return (int(b["x0"]), int(b["y0"]), int(b["x1"]-b["x0"]), int(b["y1"]-b["y0"]))
    return None

def normalize_boxes(boxes: List[Any]) -> List[Tuple[int,int,int,int]]:
    out=[]
    for b in boxes:
        nb = _to_xywh(b)
        if nb is None: continue
        x,y,w,h = nb
        if w>0 and h>0: out.append((x,y,w,h))
    return out

def draw_boxes_with_ids(img_bgr: np.ndarray,
                        boxes_xywh: List[Tuple[int,int,int,int]],
                        thickness: int = 2) -> np.ndarray:
    vis = img_bgr.copy()
    if vis.ndim == 2:
        vis = cv2.cvtColor(vis, cv2.COLOR_GRAY2BGR)
    for i,(x,y,w,h) in enumerate(boxes_xywh):
        cv2.rectangle(vis, (x,y), (x+w, y+h), (0,200,0), thickness)
        cv2.putText(vis, f"{i}", (x+4, y+18), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,120,0), 2, cv2.LINE_AA)
    return vis

# ----------------------------
# OCR (NEW_URL) & imza (yalnızca kendi kutusu)
# ----------------------------
def _ocr_remote_png(img_bgr: np.ndarray, url: str,
                    lang: str="tur", config: str="--psm 6 --oem 1") -> str:
    ok, buf = cv2.imencode(".png", img_bgr)
    if not ok: return ""
    img_b64 = base64.b64encode(buf).decode()
    payload = {"image": img_b64, "lang": lang, "config": config}
    try:
        r = requests.post(url, json=payload, timeout=30)
        if r.ok:
            j = json.loads(r.text)
            return (j.get("text") or "").strip()
    except Exception:
        pass
    return ""

def ocr_text_from_box_remote(img: np.ndarray, box_xywh: Tuple[int,int,int,int], url: str) -> str:
    x,y,w,h = box_xywh
    roi = img[y:y+h, x:x+w]
    if roi.ndim==2:
        roi = cv2.cvtColor(roi, cv2.COLOR_GRAY2BGR)
    return _ocr_remote_png(roi, url=url, lang="tur", config="--psm 6 --oem 1")

def has_signature_strict(img: np.ndarray, box_xywh: Tuple[int,int,int,int],
                         ink_ratio_min: float=0.010,
                         thinness_max: float=0.50,
                         diag_deg_min: float=20) -> bool:
    """Sadece KENDİ kutusunda imza arar; komşudan asla devralmaz."""
    x,y,w,h = box_xywh
    roi = img[y:y+h, x:x+w]
    gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY) if roi.ndim==3 else roi

    # ikili eşik + satırları bastırma
    thr_otsu = cv2.threshold(cv2.GaussianBlur(gray,(3,3),0), 0, 255,
                             cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)[1]
    k = max(3, int(0.03 * min(w,h)))
    if k % 2 == 0: k += 1
    thr_adp = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                    cv2.THRESH_BINARY_INV, k, 8)
    ink = cv2.bitwise_or(thr_otsu, thr_adp)

    # yatay çizgileri (satır) zayıflat
    hk = max(15, int(w*0.15))
    lines = cv2.morphologyEx(ink, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_RECT, (hk, 2)))
    ink = cv2.bitwise_and(ink, cv2.bitwise_not(lines))

    ink_ratio = cv2.countNonZero(ink) / max(1, w*h)
    if ink_ratio < ink_ratio_min:
        return False

    cnts,_ = cv2.findContours(ink, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts: return False
    c = max(cnts, key=cv2.contourArea)
    A = cv2.contourArea(c); P = max(1.0, cv2.arcLength(c, True))
    thinness = 4*np.pi*A/(P*P)
    if thinness >= thinness_max:
        return False

    # diyagonal çizgi var mı (imza eğriliği)
    edges = cv2.Canny(ink, 50, 150)
    linesP = cv2.HoughLinesP(edges, 1, np.pi/180, threshold=40, minLineLength=int(0.15*min(w,h)), maxLineGap=10)
    if linesP is not None:
        for ln in linesP[:,0,:]:
            x1,y1,x2,y2 = ln
            ang = abs(np.degrees(np.arctan2(y2-y1, x2-x1)))
            if 15 < ang < 165 and abs(ang-90) > 10:  # diyagonal/açılı
                return True
    # kenar-sayımı fallback
    skel = (cv2.ximgproc.thinning(ink) if hasattr(cv2, "ximgproc") else ink)
    if cv2.countNonZero(skel) / max(1,w*h) > 0.012:
        return True
    return False

# ----------------------------
# 1) DEBUG: kutuları göstermek + per-box rapor
# ----------------------------
def inspect_boxes(lower_img: np.ndarray,
                  boxes: List[Any],
                  NEW_URL: str,
                  role_threshold: float=0.80,
                  debug: bool=True) -> Tuple[np.ndarray, pd.DataFrame]:
    """
    vis_img: kutular + index
    per_box_df: i, bbox, sig(=sadece kendi kutusundan), role_best, role_score, name_in_box, text_preview
    """
    boxes_xywh = normalize_boxes(boxes)
    vis_img = draw_boxes_with_ids(lower_img, boxes_xywh)

    rows = []
    for i,b in enumerate(boxes_xywh):
        txt = ocr_text_from_box_remote(lower_img, b, NEW_URL).strip()
        txt_u = _norm_text(txt)
        sig  = has_signature_strict(lower_img, b)
        role_key, score = best_role_for_text(txt_u, role_threshold=role_threshold)

        name_in_box = None
        if role_key:
            # önce label sonrasından dene; yoksa genel isim
            name_after = extract_name_after_label(txt, ROLE_ALIASES.get(role_key, []))
            name_in_box = cleanup_name(name_after) if name_after else cleanup_name(extract_name_general(txt_u))

        rows.append({
            "i": i,
            "bbox": b,
            "sig": bool(sig),
            "role_best": role_key,
            "role_score": score,
            "name_in_box": name_in_box,
            "text_preview": re.sub(r"\s+", " ", txt)[:160]
        })
    per_box_df = pd.DataFrame(rows, columns=["i","bbox","sig","role_best","role_score","name_in_box","text_preview"])
    if debug:
        print(f"[INFO] {len(boxes_xywh)} box")
        display(per_box_df)
    return vis_img, per_box_df

# ----------------------------
# 2) Sermaye sayısı çıkarıcı (yakın kutular dahil)
# ----------------------------
_AMOUNT_RE = re.compile(r"(\d{1,3}(?:\.\d{3})*(?:,\d{2})?|\d+)\s*(?:TL|₺|EUR|€)?", re.IGNORECASE)
_CAP_KEYS = ["ŞİRKETİN SERMAYESİ", "SERMAYESİ", "SERMAYE", "PAYLARIN TOPLAMI", "TOPLAM", "İTİBARİ DEĞER", "ITIBARI DEGER", "DEĞER", "DEGER"]

def _parse_amount_int(s: str) -> Optional[int]:
    if not s: return None
    m = _AMOUNT_RE.search(s)
    if not m: return None
    raw = m.group(1)
    # TR format → 1.000.000,00  ; EU/karışık → 1,000,000.00
    v = raw.replace(" ", "")
    # önce binlik . kaldır
    v = v.replace(".", "")
    # sonra , ondalık olabilir → kaldır
    if "," in v and v.count(",")==1 and v.split(",")[1].isdigit():
        v = v.split(",")[0]
    try:
        return int(v)
    except:
        try:
            return int(float(v))
        except:
            return None

def pick_sermaye_from_texts(texts: List[str]) -> Optional[int]:
    # içinde sermaye/toplam/deger geçen kutular + komşuları tara
    idx_scores = []
    for i,t in enumerate(texts):
        tu = _norm_text(t)
        score = sum(1 for k in _CAP_KEYS if k in tu)
        idx_scores.append((score,i))
    idx_scores.sort(reverse=True)

    # en iyi 3 kutunun kendisi ve komşularında miktar ara
    for score,i in idx_scores[:3]:
        for j in [i-1, i, i+1]:
            if 0 <= j < len(texts):
                val = _parse_amount_int(texts[j] or "")
                if val is not None:
                    return val
    # yine yoksa tüm metinlerdeki en büyük sayı
    vals = [_parse_amount_int(t or "") for t in texts]
    vals = [v for v in vals if v is not None]
    return max(vals) if vals else None

# ----------------------------
# 3) Rapor → bottom_df
# ----------------------------
def build_bottom_df_from_report(lower_img: np.ndarray,
                                boxes: List[Any],
                                per_box_df: pd.DataFrame,
                                known_names: Optional[Dict[str, List[str]]] = None,
                                name_sim_threshold: float = 0.80) -> pd.DataFrame:
    """
    known_names: {'yk_uyesi': [..], 'yk_baskani':[...], 'toplanti_baskani':[...], ...}
      - ad/soyad alanları sadece bu listedeki isim(ler)den seçilir
    """
    boxes_xywh = normalize_boxes(boxes)

    # kutu metinleri (sermaye araması için)
    texts = ["" for _ in boxes_xywh]
    sigs  = [False for _ in boxes_xywh]
    roles = [None for _ in boxes_xywh]
    names = [None for _ in boxes_xywh]
    for _,r in per_box_df.iterrows():
        i = int(r["i"])
        texts[i] = str(r.get("text_preview") or "")
        sigs[i]  = bool(r.get("sig", False))
        roles[i] = r.get("role_best")
        names[i] = r.get("name_in_box")

    # --- sermaye ---
    sermaye = pick_sermaye_from_texts(texts)

    out = {
        "sermaye_toplam_tl": sermaye,
        "toplanti_baskani_ad_soyad": None, "toplanti_baskani_imza_var_mi": None,
        "tutanak_yazmani_ad_soyad":  None, "tutanak_yazmani_imza_var_mi":  None,
        "bakanlik_temsilcisi_ad_soyad": None, "bakanlik_temsilcisi_imza_var_mi": None,
        "yk_uyesi_ad_soyad": None, "yk_uyesi_imza_var_mi": None,
        "yk_baskani_ad_soyad": None, "yk_baskani_imza_var_mi": None,
        "katip_ad_soyad": None, "katip_imza_var_mi": None,
        "divan_baskani_ad_soyad": None, "divan_baskani_imza_var_mi": None,
    }

    def _set(k_name: str, k_sig: str, nm: Optional[str], sg: Optional[bool]):
        if nm and out[k_name] is None:
            out[k_name] = nm
        if sg is not None and out[k_sig] is None:
            out[k_sig] = bool(sg)

    KN = known_names or {}

    for _,r in per_box_df.iterrows():
        role = r.get("role_best")
        if not role:
            continue
        i   = int(r["i"])
        sg  = bool(r.get("sig", False))           # SADECE kendi kutusundan
        raw = str(r.get("text_preview") or "")
        nm_in = r.get("name_in_box")

        # eşleşme daima known_names'ten gelsin
        if role == "yk_uyesi":
            raw_list = extract_all_names(raw)
            matched = match_names_to_known(raw_list, KN.get("yk_uyesi", []), sim_thr=name_sim_threshold)
            nm = "; ".join(matched) if matched else None
        else:
            src = nm_in or extract_name_general(_norm_text(raw))
            nm = best_name_from_candidates(src, KN.get(role, []), sim_thr=name_sim_threshold) if KN.get(role) else cleanup_name(src)

        if role == "toplanti_baskani":
            _set("toplanti_baskani_ad_soyad", "toplanti_baskani_imza_var_mi", nm, sg)
        elif role == "tutanak_yazmani":
            _set("tutanak_yazmani_ad_soyad", "tutanak_yazmani_imza_var_mi", nm, sg)
        elif role == "bakanlik_temsilcisi":
            _set("bakanlik_temsilcisi_ad_soyad", "bakanlik_temsilcisi_imza_var_mi", nm, sg)
        elif role == "yk_uyesi":
            _set("yk_uyesi_ad_soyad", "yk_uyesi_imza_var_mi", nm, sg)
        elif role == "yk_baskani":
            _set("yk_baskani_ad_soyad", "yk_baskani_imza_var_mi", nm, sg)
        elif role == "katip":
            _set("katip_ad_soyad", "katip_imza_var_mi", nm, sg)
        elif role == "divan_baskani":
            _set("divan_baskani_ad_soyad", "divan_baskani_imza_var_mi", nm, sg)

    return pd.DataFrame([out])