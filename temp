import cv2
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, Optional

def return_binary_mask(
    table: np.ndarray,
    ver_kernels: Optional[Tuple[int, int]] = None,
    hor_kernels: Optional[Tuple[int, int]] = None,
    hor_erode_iter: int = 2,
    ver_erode_iter: int = 1,
    handle_inv: bool = True,
    min_cov_h: float = 0.4,
    min_cov_v: float = 0.4,
    min_gap_frac: float = 0.015,
    debug: bool = False,
):
    """
    Girdi
    -----
    table : BGR veya gri tablo görüntüsü.

    Çıktı
    -----
    binary_lines      : yatay+dikey çizgi maskesi
    binary_horizontal : yatay çizgi maskesi
    binary_vertical   : dikey çizgi maskesi
    rows_y            : grid yatay eksenlerinin y koordinatları (üst + iç + alt)
    cols_x            : grid dikey eksenlerinin x koordinatları (sol + iç + sağ)
    """

    # ----------------- yardımcılar -----------------

    def add_borders(img: np.ndarray, border: int = 2) -> np.ndarray:
        img[:border, :] = 255
        img[-border:, :] = 255
        img[:, :border] = 255
        img[:, -border:] = 255
        return img

    def extract_axes_from_mask(mask: np.ndarray,
                               axis: str,
                               min_coverage: float,
                               min_gap_px: int,
                               title: str = "",
                               dbg: bool = False) -> np.ndarray:
        """
        mask üzerinde 1D projeksiyon ile eksen merkezlerini bulur.
        axis = 'h' -> satır eksenleri (y)
        axis = 'v' -> sütun eksenleri (x)
        """
        H, W = mask.shape

        if axis == "h":
            proj = mask.sum(axis=1) / (255.0 * max(1, W))  # satır bazlı
            length = H
        else:
            proj = mask.sum(axis=0) / (255.0 * max(1, H))  # sütun bazlı
            length = W

        is_line = proj > min_coverage

        centers = []
        i = 0
        while i < length:
            if not is_line[i]:
                i += 1
                continue
            j = i + 1
            while j < length and is_line[j]:
                j += 1
            c = (i + j - 1) // 2
            centers.append(c)
            i = j

        # yakın merkezleri birleştir
        merged = []
        for c in centers:
            if not merged or c - merged[-1] >= min_gap_px:
                merged.append(c)
            else:
                merged[-1] = int((merged[-1] + c) / 2)

        merged = np.array(merged, dtype=int)

        if dbg:
            xs = np.arange(length)
            plt.figure(figsize=(10, 3))
            plt.plot(xs, proj, label="projection")
            if len(merged) > 0:
                plt.scatter(merged, proj[merged], c="red", s=30, label="axes")
            plt.title(title)
            plt.legend()
            plt.tight_layout()
            plt.show()

        return merged

    # ----------------- 1) gri + threshold -----------------

    if table.ndim == 3:
        gray = cv2.cvtColor(table, cv2.COLOR_BGR2GRAY)
    else:
        gray = table.copy()

    _, binary = cv2.threshold(gray, 240, 255, cv2.THRESH_BINARY_INV)
    binary = add_borders(binary)

    H, W = binary.shape[:2]

    # ----------------- 2) kernel boyutlarını dinamik seç -----------------

    if hor_kernels is None:
        # genişliğin ~1/20'si kadar bir kernel, min 25
        kw = max(25, W // 20)
        hor_kernels = (kw, 1)

    if ver_kernels is None:
        kh = max(25, H // 20)
        ver_kernels = (1, kh)

    kernel_hor = cv2.getStructuringElement(cv2.MORPH_RECT, hor_kernels)
    kernel_ver = cv2.getStructuringElement(cv2.MORPH_RECT, ver_kernels)

    # ----------------- 3) yatay / dikey çizgiler -----------------

    binary_horizontal = cv2.erode(binary, kernel_hor, iterations=hor_erode_iter)
    binary_horizontal = cv2.dilate(binary_horizontal, kernel_hor, iterations=20)

    binary_vertical = cv2.erode(binary, kernel_ver, iterations=ver_erode_iter)
    binary_vertical = cv2.dilate(binary_vertical, kernel_ver, iterations=20)

    # ----------------- 4) sağ taraftaki anomalik kolon kırpma -----------------

    if handle_inv:
        inv_x_range = 0
        for x in range(W):
            if np.mean(binary_vertical[:, x]) == 0:
                inv_x_range = x
                break

        if inv_x_range >= W * 0.15:
            binary_vertical[:, :max(0, 2 * inv_x_range - 2)] = 0

    # ----------------- 5) birleşik maske -----------------

    binary_lines = cv2.addWeighted(binary_vertical, 0.5,
                                   binary_horizontal, 0.5, 0.0)

    # ----------------- 6) grid eksenlerini otomatik bul -----------------

    min_gap_h = max(3, int(H * min_gap_frac))
    min_gap_v = max(3, int(W * min_gap_frac))

    rows_y = extract_axes_from_mask(
        binary_horizontal,
        axis="h",
        min_coverage=min_cov_h,
        min_gap_px=min_gap_h,
        title="Row projection",
        dbg=debug,
    )

    cols_x = extract_axes_from_mask(
        binary_vertical,
        axis="v",
        min_coverage=min_cov_v,
        min_gap_px=min_gap_v,
        title="Column projection",
        dbg=debug,
    )

    if debug:
        print(f"rows_y (len={len(rows_y)}):", rows_y)
        print(f"cols_x (len={len(cols_x)}):", cols_x)

        # grid’i görüntü üzerinde de göster
        rgb = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
        vis = rgb.copy()
        for y in rows_y:
            cv2.line(vis, (0, y), (W-1, y), (0, 255, 0), 1)
        for x in cols_x:
            cv2.line(vis, (x, 0), (x, H-1), (255, 0, 0), 1)

        plt.figure(figsize=(8, 6))
        plt.title("Detected grid axes")
        plt.imshow(vis[:, :, ::-1])
        plt.axis('off')
        plt.tight_layout()
        plt.show()

    return binary_lines, binary_horizontal, binary_vertical, rows_y, cols_x

for i in range(len(binarized_tables)):
    bin_lines, hmask, vmask, rows_y, cols_x = return_binary_mask(
        binarized_tables[i],
        debug=True   # hem projeksiyon hem de grid çizgilerini gösterir
    )

    n_rows = len(rows_y) - 1   # üst + alt kenar varsa
    n_cols = len(cols_x) - 1

    print(f"Page {i}: rows={n_rows}, cols={n_cols}")