# -*- coding: utf-8 -*-
import cv2, re, json, base64, requests, numpy as np, pandas as pd
import unicodedata
from typing import Any, List, Tuple, Dict, Optional

# ----------------------------
# Metin normalizasyonu
# ----------------------------
def _strip_diacritics(s: str) -> str:
    return ''.join(c for c in unicodedata.normalize('NFKD', s) if not unicodedata.combining(c))

def _norm_text(s: str) -> str:
    s = (s or "").upper()
    s = _strip_diacritics(s)
    s = re.sub(r"\s+", " ", s).strip()
    return s

NAME_TOKEN = re.compile(r"[A-ZÇĞİÖŞÜ]{2,}(?:\s+[A-ZÇĞİÖŞÜ]{2,})+")
DROP_WORDS = [
    "TOPLANTI","BAŞKANI","BASKANI","YÖNETİM","KURULU","ÜYESİ","UYESI","YK",
    "BAKANLIK","TEMSİLCİSİ","TEMSILCISI","KATİP","KÂTİP","YAZMANI","OY",
    "DİVAN","DIVAN","İMZA","IMZA","KAŞE","MÜHÜR","STAMP","ASALATEN","VEKALETEN",
    "HAZIRUN","HAZİRUN"
]

ROLE_ALIASES: Dict[str, List[str]] = {
    "toplanti_baskani":    ["TOPLANTI BAŞKANI","TOPLANTI BASKANI","DİVAN BAŞKANI","DIVAN BASKANI"],
    "tutanak_yazmani":     ["TUTANAK YAZMANI","YAZMAN"],
    "bakanlik_temsilcisi": ["BAKANLIK TEMSİLCİSİ","TİCARET BAKANLIĞI TEMSİLCİSİ","TICARET BAKANLIGI TEMSILCISI"],
    "yk_uyesi":            ["YÖNETİM KURULU ÜYESİ","YONETIM KURULU UYESI","YK ÜYESİ","YK UYESI","ÜYELERİ","U Y E L E R I"],
    "yk_baskani":          ["YÖNETİM KURULU BAŞKANI","YONETIM KURULU BASKANI","YK BAŞKANI","YK BASKANI"],
    "katip":               ["KÂTİP","KATİP","OY TOPLAYICI","OY TOPLAMA MEMURU","OY TOPLAYAN"],
    "divan_baskani":       ["DİVAN BAŞKANI","DIVAN BASKANI"],
}

def _contains_any_norm(text_u: str, aliases: List[str]) -> bool:
    t = _norm_text(text_u)
    return any(_norm_text(a) in t for a in aliases)

def cleanup_name(s: Optional[str]) -> Optional[str]:
    if not s: return s
    t = _norm_text(s)
    # rol sözcüklerini ayıkla
    for w in DROP_WORDS:
        t = re.sub(rf"\b{_norm_text(w)}\b", " ", t)
    # 'Üyeleri' gibi toplu etiketleri uçur
    t = re.sub(r"\bUYE(LERI|LERİ)\b", " ", t)
    t = re.sub(r"\s+", " ", t).strip()
    # yan yana 2+ büyük harf bloklarından en uzun olan(lar)
    cands = NAME_TOKEN.findall(t)
    if cands:
        return max(cands, key=len).title()
    # son çare: sondan 2-3 token
    parts = [p for p in t.split() if len(p) >= 2]
    return " ".join(parts[-3:]).title() if parts else None

def extract_name_after_label(text: str, label_aliases: List[str]) -> Optional[str]:
    raw = text or ""
    lines = [ln.strip() for ln in raw.splitlines() if ln.strip()]
    if not lines: return None
    norm_lines = [_norm_text(ln) for ln in lines]
    norm_aliases = [_norm_text(a) for a in label_aliases]

    label_idx = None
    for i, nl in enumerate(norm_lines):
        if any(na in nl for na in norm_aliases):
            label_idx = i; break
    if label_idx is None: return None

    for j in range(label_idx + 1, min(label_idx + 4, len(lines))):
        cand = cleanup_name(lines[j])
        if cand: return cand
    return None

# ----------------------------
# Kutu yardımcıları
# ----------------------------
def _to_xywh(b: Any) -> Optional[Tuple[int,int,int,int]]:
    if isinstance(b, (tuple, list, np.ndarray)) and len(b) == 4:
        x,y,w,h = [int(round(float(v))) for v in b];  return (x,y,w,h)
    for attrs in [("x","y","w","h"), ("left","top","width","height")]:
        if all(hasattr(b, a) for a in attrs):
            x,y,w,h = [int(round(float(getattr(b,a)))) for a in attrs];  return (x,y,w,h)
    for attrs in [("x0","y0","x1","y1"), ("left","top","right","bottom")]:
        if all(hasattr(b, a) for a in attrs):
            x0,y0,x1,y1 = [float(getattr(b,a)) for a in attrs]
            return (int(round(x0)), int(round(y0)), int(round(x1-x0)), int(round(y1-y0)))
    if isinstance(b, dict):
        if all(k in b for k in ("x","y","w","h")):
            return (int(b["x"]), int(b["y"]), int(b["w"]), int(b["h"]))
        if all(k in b for k in ("x0","y0","x1","y1")):
            return (int(b["x0"]), int(b["y0"]), int(b["x1"]-b["x0"]), int(b["y1"]-b["y0"]))
    return None

def normalize_boxes(boxes: List[Any]) -> List[Tuple[int,int,int,int]]:
    out=[]
    for b in boxes:
        nb = _to_xywh(b)
        if nb is None: continue
        x,y,w,h = nb
        if w>0 and h>0: out.append((x,y,w,h))
    return out

def draw_boxes_with_ids(img_bgr: np.ndarray,
                        boxes_xywh: List[Tuple[int,int,int,int]],
                        thickness: int = 2) -> np.ndarray:
    vis = img_bgr.copy()
    if vis.ndim == 2:
        vis = cv2.cvtColor(vis, cv2.COLOR_GRAY2BGR)
    for i,(x,y,w,h) in enumerate(boxes_xywh):
        cv2.rectangle(vis, (x,y), (x+w, y+h), (0,200,0), thickness)
        cv2.putText(vis, f"{i}", (x+4, y+18), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,120,0), 2, cv2.LINE_AA)
    return vis

# ----------------------------
# OCR (remote) ve imza v3
# ----------------------------
def _ocr_remote_png(img_bgr: np.ndarray, url: str,
                    lang: str="tur", config: str="--psm 6 --oem 1") -> str:
    ok, buf = cv2.imencode(".png", img_bgr)
    if not ok: return ""
    img_b64 = base64.b64encode(buf).decode()
    payload = {"image": img_b64, "lang": lang, "config": config}
    try:
        r = requests.post(url, json=payload, timeout=30)
        if r.ok:
            j = json.loads(r.text)
            return (j.get("text") or "").strip()
    except Exception:
        pass
    return ""

def ocr_text_from_box_remote(img: np.ndarray, box_xywh: Tuple[int,int,int,int], url: str) -> str:
    x,y,w,h = box_xywh
    roi = img[y:y+h, x:x+w]
    if roi.ndim==2:
        roi = cv2.cvtColor(roi, cv2.COLOR_GRAY2BGR)
    return _ocr_remote_png(roi, url=url, lang="tur", config="--psm 6 --oem 1")

# ---- imza v3 (yalnızca kutu içi) ----
def _remove_table_lines(bin_inv: np.ndarray) -> np.ndarray:
    h, w = bin_inv.shape
    out = bin_inv.copy()
    kh = max(15, w // 80)
    horiz = cv2.morphologyEx(out, cv2.MORPH_OPEN,
                             cv2.getStructuringElement(cv2.MORPH_RECT, (kh, 1)))
    out = cv2.subtract(out, horiz)
    kv = max(15, h // 80)
    vert = cv2.morphologyEx(out, cv2.MORPH_OPEN,
                            cv2.getStructuringElement(cv2.MORPH_RECT, (1, kv)))
    out = cv2.subtract(out, vert)
    return out

def _suppress_small_text(bin_inv: np.ndarray) -> np.ndarray:
    out = cv2.morphologyEx(bin_inv, cv2.MORPH_CLOSE,
                           cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3,3)), iterations=1)
    num, labels, stats, _ = cv2.connectedComponentsWithStats(out, connectivity=8)
    h, w = out.shape
    a_min = max(40, (h*w)//20000)
    keep = np.zeros_like(out)
    for i in range(1, num):
        if stats[i, cv2.CC_STAT_AREA] >= a_min:
            keep[labels==i] = 255
    return keep

def _skeleton_length(mask: np.ndarray) -> float:
    m = (mask>0).astype(np.uint8)*255
    length = 0
    kern = cv2.getStructuringElement(cv2.MORPH_CROSS, (3,3))
    prev = m.copy()
    for _ in range(40):
        ero = cv2.erode(prev, kern)
        skel = cv2.subtract(prev, ero)
        length += float(cv2.countNonZero(skel))
        if cv2.countNonZero(ero) == 0: break
        prev = ero
    return length

def has_signature_v3(img: np.ndarray,
                     box_xywh: tuple,
                     *,
                     ink_ratio_thr: float = 0.006,
                     sig_score_thr: float = 0.22) -> Tuple[bool, float]:
    x,y,w,h = box_xywh
    roi = img[y:y+h, x:x+w]
    gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY) if roi.ndim==3 else roi
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    gray = clahe.apply(gray)
    thr = cv2.threshold(cv2.GaussianBlur(gray,(3,3),0), 0, 255,
                        cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)[1]
    no_lines = _remove_table_lines(thr)
    clean = _suppress_small_text(no_lines)

    ink_ratio = cv2.countNonZero(clean) / max(1, w*h)
    if ink_ratio < ink_ratio_thr:
        return False, 0.0

    num, labels, stats, _ = cv2.connectedComponentsWithStats(clean, connectivity=8)
    H,W = clean.shape
    area_tot = float(cv2.countNonZero(clean))
    score = 0.0

    for i in range(1, num):
        a   = float(stats[i, cv2.CC_STAT_AREA])
        lw  = stats[i, cv2.CC_STAT_WIDTH]
        lh  = stats[i, cv2.CC_STAT_HEIGHT]
        if a < max(60, (H*W)//30000): 
            continue
        comp = np.zeros_like(clean); comp[labels==i]=255
        cnts,_ = cv2.findContours(comp, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if not cnts: continue
        c = cnts[0]
        peri = cv2.arcLength(c, True)
        if peri < 60: continue
        A = cv2.contourArea(c)
        if A <= 0:  continue
        solidity   = A / (lw*lh)
        comp_ratio = peri / (A+1e-3)
        if solidity > 0.7:   # dolu yamalar
            continue
        if comp_ratio < 0.25:
            continue
        score += a

    sk_len = _skeleton_length(clean) / max(1.0, H*W)
    score = (score / max(1.0, area_tot)) + 0.5*sk_len
    return (score >= sig_score_thr, score)

# ----------------------------
# Komşudan isim (opsiyonel) — imza asla devralınmaz
# ----------------------------
def nearest_name_from_neighbors(i: int,
                                boxes_xywh: List[Tuple[int,int,int,int]],
                                texts_u: List[str],
                                same_row_tol: int = 20,
                                dx_max_factor: float = 1.7) -> Optional[str]:
    xi, yi, wi, hi = boxes_xywh[i]
    row_y_min = yi - same_row_tol
    row_y_max = yi + hi + same_row_tol
    dx_max = int(wi * dx_max_factor)

    cands=[]
    for j,(xj,yj,wj,hj) in enumerate(boxes_xywh):
        if j==i: continue
        if not (row_y_min <= yj <= row_y_max): continue
        if xj <= xi or (xj-xi) > dx_max: continue
        cands.append((j, xj-xi))
    cands.sort(key=lambda t:t[1])

    for j,_ in cands:
        cand = cleanup_name(texts_u[j])
        if cand: return cand
    # alt satır fallback
    below=[]
    for j,(xj,yj,wj,hj) in enumerate(boxes_xywh):
        if j==i: continue
        gap = yj - (yi+hi)
        if 0 < gap < int(1.2*hi):
            below.append((j, abs(xj-xi)))
    below.sort(key=lambda t:t[1])
    for j,_ in below:
        cand = cleanup_name(texts_u[j])
        if cand: return cand
    return None

# ----------------------------
# 1) DEBUG/rapor: kutuları ve OCR + rol + imza
# ----------------------------
def inspect_boxes(lower_img: np.ndarray,
                  boxes: List[Any],
                  NEW_URL: str,
                  role_threshold: float = 0.80,
                  debug: bool=True) -> Tuple[np.ndarray, pd.DataFrame]:
    boxes_xywh = normalize_boxes(boxes)
    vis_img = draw_boxes_with_ids(lower_img, boxes_xywh)

    rows = []
    for i,b in enumerate(boxes_xywh):
        text = ocr_text_from_box_remote(lower_img, b, NEW_URL).strip()
        text_u = _norm_text(text)
        # rol skoru
        role_best, role_score = None, 0.0
        for rk, aliases in ROLE_ALIASES.items():
            hit = any(_norm_text(a) in text_u for a in aliases)
            if hit:
                # kaba skor: alias sayısı / toplam
                score = sum(_norm_text(a) in text_u for a in aliases) / max(1,len(aliases))
                if score > role_score:
                    role_best, role_score = rk, score
        # isim (kutu içi)
        name_in_box = None
        if role_best and role_score >= role_threshold:
            name_in_box = extract_name_after_label(text, ROLE_ALIASES.get(role_best, [])) or cleanup_name(text)

        # İMZA yalnıza bu kutudan
        sig_bool, sig_score = has_signature_v3(lower_img, b, ink_ratio_thr=0.006, sig_score_thr=0.22)

        rows.append({
            "i": i, "bbox": b, "sig": bool(sig_bool), "sig_score": float(sig_score),
            "role_best": role_best if role_score >= role_threshold else None,
            "role_score": role_score if role_score >= role_threshold else 0.0,
            "name_in_box": name_in_box,
            "text_preview": re.sub(r"\s+", " ", text)[:140]
        })

    per_box_df = pd.DataFrame(rows, columns=["i","bbox","sig","sig_score","role_best","role_score","name_in_box","text_preview"])
    if debug:
        print(f"[INFO] {len(boxes_xywh)} box")
        display(per_box_df)
    return vis_img, per_box_df

# ----------------------------
# 2) bottom_df üret (imza sadece kutudan)
# ----------------------------
def build_bottom_df_from_report(lower_img: np.ndarray,
                                boxes: List[Any],
                                per_box_df: pd.DataFrame,
                                use_neighbor_name: bool=True) -> pd.DataFrame:
    boxes_xywh = normalize_boxes(boxes)
    N = len(boxes_xywh)

    texts_u = ["" for _ in range(N)]
    names   = [None for _ in range(N)]
    roles   = [None for _ in range(N)]
    sigs    = [None for _ in range(N)]      # bool/None
    for _,r in per_box_df.iterrows():
        i = int(r["i"])
        texts_u[i] = _norm_text(str(r.get("text_preview") or ""))
        roles[i]   = r.get("role_best")
        names[i]   = r.get("name_in_box")
        sigs[i]    = bool(r.get("sig", False))  # <<< SADECE KENDI KUTUSU

    # --- Sermaye ---
    def _parse_tl(text: str) -> Optional[int]:
        TL_NUM = re.compile(r"(\d{1,3}(?:\.\d{3})*(?:,\d{2})?|\d+)\s*(TL|₺|EUR|€|TRY)?", re.IGNORECASE)
        best=None
        for m in TL_NUM.finditer(text or ""):
            raw = m.group(1)
            v = raw.replace(".", "").replace(" ", "").replace(",", ".")
            try:
                val = float(v)
                val_int = int(round(val))
                best = val_int if (best is None or val_int > best) else best
            except: pass
        return best

    cap_keys = ["ŞİRKETİN SERMAYESİ","SERMAYESİ VE PAYLARIN TOPLAMI","SERMAYE","TOPLAM İTİBARİ DEĞERİ"]
    idxs = sorted([(sum(k in (t or "") for k in cap_keys), i) for i,t in enumerate(texts_u)], reverse=True)
    sermaye = None
    for score,i in idxs[:3]:
        if score==0: break
        for j in [i-1,i,i+1]:
            if 0 <= j < N:
                v = _parse_tl(texts_u[j] or "")
                if v is not None: sermaye=v; break
        if sermaye is not None: break
    if sermaye is None:
        vals = [_parse_tl(t or "") for t in texts_u]
        sermaye = max([v for v in vals if v is not None], default=None)

    out = {
        "sermaye_toplam_tl": sermaye,
        "toplanti_baskani_ad_soyad": None, "toplanti_baskani_imza_var_mi": None,
        "tutanak_yazmani_ad_soyad": None,  "tutanak_yazmani_imza_var_mi": None,
        "bakanlik_temsilcisi_ad_soyad": None, "bakanlik_temsilcisi_imza_var_mi": None,
        "yk_uyesi_ad_soyad": None, "yk_uyesi_imza_var_mi": None,
        "yk_baskani_ad_soyad": None, "yk_baskani_imza_var_mi": None,
        "katip_ad_soyad": None, "katip_imza_var_mi": None,
        "divan_baskani_ad_soyad": None, "divan_baskani_imza_var_mi": None,
    }
    key_map = {
        "toplanti_baskani": ("toplanti_baskani_ad_soyad","toplanti_baskani_imza_var_mi"),
        "tutanak_yazmani":  ("tutanak_yazmani_ad_soyad","tutanak_yazmani_imza_var_mi"),
        "bakanlik_temsilcisi": ("bakanlik_temsilcisi_ad_soyad","bakanlik_temsilcisi_imza_var_mi"),
        "yk_uyesi": ("yk_uyesi_ad_soyad","yk_uyesi_imza_var_mi"),
        "yk_baskani": ("yk_baskani_ad_soyad","yk_baskani_imza_var_mi"),
        "katip": ("katip_ad_soyad","katip_imza_var_mi"),
        "divan_baskani": ("divan_baskani_ad_soyad","divan_baskani_imza_var_mi"),
    }

    def _set_role(rk: str, name: Optional[str], sig: Optional[bool]):
        if rk not in key_map: return
        kn, ks = key_map[rk]
        if out[kn] is None and name:
            out[kn] = name
        # İmza kararı: sadece kendi kutusundan gelen sig kullanılır
        if name is not None:
            out[ks] = bool(sig)
        else:
            # isim yoksa imza değeri yazma (None kalsın)
            if out[ks] is None:
                out[ks] = None

    # roller üzerinden geç
    for i,rk in enumerate(roles):
        if not rk: 
            continue
        nm = names[i]
        if nm is None and use_neighbor_name:
            nm = nearest_name_from_neighbors(i, boxes_xywh, texts_u)
            if nm:
                nm = cleanup_name(nm)
        _set_role(rk, nm, sigs[i])

    return pd.DataFrame([out])