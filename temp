from collections import defaultdict

def _reindex_compact(cells):
    """
    rows/cols'u sıkıştırır; (n_rows, n_cols) döner.
    cells: list of dict, her biri {row, col, x, y, w, h, ...}
    """
    if not cells:
        return 0, 0

    rkeep = sorted({c["row"] for c in cells})
    ckeep = sorted({c["col"] for c in cells})

    rmap = {r: i for i, r in enumerate(rkeep)}
    cmap = {c: i for i, c in enumerate(ckeep)}

    for cell in cells:
        cell["row"] = rmap[cell["row"]]
        cell["col"] = cmap[cell["col"]]

    return len(rkeep), len(ckeep)


def _prune_rows_y_from_cells(rows_y, cells):
    """
    rows_y'yi, elde kalan hücrelere göre yeniden oluştur.
    rows_y: 1D array/list (grid eksenleri)
    cells : list of dict
    """
    if not cells:
        return rows_y

    kept_rows = sorted({c["row"] for c in cells})

    out = [rows_y[kept_rows[0]]]  # üst kenar
    for r in kept_rows:
        out.append(rows_y[r + 1])  # ilgili bandın alt kenarı

    # rows_y np.array ise np.array döndür
    import numpy as np
    return np.array(out) if hasattr(rows_y, "dtype") else out

def prune_rows_and_cols_fully_empty(
    table_img,
    rows_y,
    cols_x,
    cells,
    signature_col=-1,          # imza hep son sütun ise -1
    ink_thr_cell=0.002,        # %0.2 alan
    min_cc=2,
    min_cc_area_frac=1/6000,   # ROI oranı
    inset_px=4,
    inset_frac=0.02,
    debug=False,
):
    """
    Dönüş:
        cells_pruned, rows_y_pruned, cols_x_pruned (aynı),
        n_rows, n_cols
    """
    if not cells:
        return cells, rows_y, cols_x, 0, 0

    # 1) Çizgileri silip sadece içerik maskesi üret
    content = _content_mask_no_lines(table_img)
    H, W = content.shape

    # 2) Orijinal sütun sayısı + imza sütunu index'i
    n_cols_orig = max(c["col"] for c in cells) + 1
    sig_c = (n_cols_orig - 1) if signature_col == -1 else signature_col

    # 3) Satır/sütun bazlı doluluk istatistikleri
    row_nonempty = defaultdict(int)
    col_nonempty = defaultdict(int)
    cell_is_text = {}

    for cell in cells:
        x, y, w, h = cell["x"], cell["y"], cell["w"], cell["h"]

        x0, y0, w0, h0 = _inner_box(x, y, w, h, inset_px, inset_frac)
        roi = content[max(0, y0): y0 + h0, max(0, x0): x0 + w0]

        if roi.size == 0:
            ir = 0.0
            is_text = False
        else:
            cnt = int(np.count_nonzero(roi))
            ir = cnt / float(roi.size)
            min_area = max(12, int(roi.size * min_cc_area_frac))
            is_text = (ir > ink_thr_cell) and _is_textlike(roi, min_area, min_cc=min_cc)

        r, c = cell["row"], cell["col"]
        cell_is_text[(r, c)] = is_text

        # imza sütununu doluluk hesabına katma
        if c != sig_c and is_text:
            row_nonempty[r] += 1
            col_nonempty[c] += 1

        if debug:
            print(f"cell ({r},{c}) ink_ratio={ir:.4f} textlike={is_text}")

    # 4) Tamamen boş satır/sütun listeleri
    max_row = max(c["row"] for c in cells)
    max_col = max(c["col"] for c in cells)

    rows_to_drop = [r for r in range(max_row + 1) if row_nonempty.get(r, 0) == 0]
    cols_to_drop = [c for c in range(max_col + 1) if col_nonempty.get(c, 0) == 0]

    # 5) Özel kural: r0 c0 ve r0 clast ikisi de boş ise r0 row'u düşme (başlık satırı)
    last_col = max_col
    first_cell_ok = cell_is_text.get((0, 0), False)
    last_cell_ok = cell_is_text.get((0, last_col), False)

    if (not first_cell_ok) and (not last_cell_ok):
        # sadece header row kalsın
        if 0 in rows_to_drop:
            rows_to_drop.remove(0)

    if debug:
        print(f"rows_to_drop: {rows_to_drop}  cols_to_drop: {cols_to_drop}")

    # 6) Hücreleri filtrele
    kept_cells = [
        dict(cell)  # kopya
        for cell in cells
        if (cell["row"] not in rows_to_drop) and (cell["col"] not in cols_to_drop)
    ]

    # 7) row/col indexlerini sıkıştır
    n_rows, n_cols = _reindex_compact(kept_cells)

    # 8) rows_y güncelle (istenirse cols_x de ayrı sıkıştırılabilir;
    #    senin orijinal kodunda cols_x genelde aynen bırakılıyordu)
    rows_y_pruned = _prune_rows_y_from_cells(rows_y, kept_cells)
    cols_x_pruned = cols_x

    if debug:
        print(f"Final grid: (n_rows={n_rows} x n_cols={n_cols})")

    return kept_cells, rows_y_pruned, cols_x_pruned, n_rows, n_cols

pruned_all = []

for p, page in enumerate(grid_info):
    rows_y = page["rows_y"]
    cols_x = page["cols_x"]

    # all_cells[p] mutlaka "list of dict" olsun
    cells = all_cells[p]          # veya list(all_cells[p].values()) eğer dict ise

    cells_pruned, r_pruned, c_pruned, n_rows, n_cols = prune_rows_and_cols_fully_empty(
        table_img      = binarized_tables[p],  # o sayfanın tablo imajı
        rows_y         = rows_y,
        cols_x         = cols_x,
        cells          = cells,
        signature_col  = -1,
        debug          = False
    )

    pruned_all.append({
        "page_index": p,
        "cells":  cells_pruned,
        "rows_y": r_pruned,
        "cols_x": c_pruned,
        "n_rows": n_rows,
        "n_cols": n_cols,
    })