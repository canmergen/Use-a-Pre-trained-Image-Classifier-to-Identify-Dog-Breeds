# -*- coding: utf-8 -*-
import cv2, json, base64, requests, re, numpy as np, pandas as pd
import unicodedata
from typing import Any, List, Tuple, Dict, Optional

# =========================
# 0) METİN NORMALİZASYON
# =========================
def _strip_diacritics(s: str) -> str:
    return ''.join(c for c in unicodedata.normalize('NFKD', s) if not unicodedata.combining(c))

def _norm_text(s: str) -> str:
    s = (s or "")
    s = _strip_diacritics(s)
    s = s.upper()
    s = re.sub(r"\s+", " ", s).strip()
    return s

def _lev(a: str, b: str) -> int:
    # ufak, bağımlılıksız Levenshtein
    if a == b: return 0
    if not a: return len(b)
    if not b: return len(a)
    dp = range(len(b) + 1)
    for i, ca in enumerate(a, 1):
        prev, cur = i, [i]
        for j, cb in enumerate(b, 1):
            ins = cur[j-1] + 1
            dele = dp[j] + 1
            sub = dp[j-1] + (ca != cb)
            cur.append(min(ins, dele, sub))
        dp = cur
    return dp[-1]

# =========================
# 1) ROL & İSİM HEURISTICS
# =========================
ROLE_ALIASES: Dict[str, List[str]] = {
    "toplanti_baskani":    ["TOPLANTI BAŞKANI", "TOPLANTI BASKANI", "DİVAN BAŞKANI", "DIVAN BASKANI"],
    "tutanak_yazmani":     ["TUTANAK YAZMANI", "YAZMAN"],
    "bakanlik_temsilcisi": ["BAKANLIK TEMSİLCİSİ", "TİCARET BAKANLIĞI TEMSİLCİSİ",
                            "TICARET BAKANLIGI TEMSILCISI"],
    "yk_uyesi":            ["YÖNETİM KURULU ÜYESİ", "YONETIM KURULU UYESI", "YK ÜYESİ", "YK UYESI"],
    "yk_baskani":          ["YÖNETİM KURULU BAŞKANI", "YONETIM KURULU BASKANI", "YK BAŞKANI", "YK BASKANI"],
    "katip":               ["KÂTİP", "KATİP", "OY TOPLAYICI", "OY TOPLAMA MEMURU"],
    "divan_baskani":       ["DİVAN BAŞKANI", "DIVAN BASKANI"],
}

# rol kelime havuzu (tek kelime + yaygın OCR sapmaları)
_ROLE_UNIGRAMS = {
    "TOPLANTI","TOPLAN","TOPLANT","TOPLANI","TOPLANII","TOPLANTl","TOPLAHTI",
    "BASKANI","BASKAN","BASKANl","DIVAN","YONETIM","KURULU","UYESI",
    "BAKANLIK","TEMSILCISI","KATIP","YAZMAN","OY","TOPLAYICI","MEMURU","HAZIRUN"
}
NAME_TOKEN = re.compile(r"[A-ZÇĞİÖŞÜ]{2,}(?:\s+[A-ZÇĞİÖŞÜ]{2,})+")

def _looks_like_role_token(tok: str) -> bool:
    t = _norm_text(tok)
    if t in _ROLE_UNIGRAMS:
        return True
    return any(_lev(t, r) <= 2 for r in _ROLE_UNIGRAMS)

def _alias_score(text_u: str, alias: str) -> float:
    # fuzzy skor (token örtüşmesi + edit distance)
    A = _norm_text(alias)
    T = _norm_text(text_u)
    if not A or not T:
        return 0.0
    toks_a = A.split()
    toks_t = T.split()
    if not toks_a or not toks_t:
        return 0.0
    hit = 0
    for ta in toks_a:
        best = max((1 - _lev(ta, tt)/max(len(ta), len(tt)) for tt in toks_t), default=0.0)
        hit += best
    return hit / len(toks_a)

def best_role_for_text(text_u: str, role_threshold: float = 0.8) -> Tuple[Optional[str], float]:
    # öncelik: olası çakışmaları mantıklı çözer
    priority = ["yk_baskani","toplanti_baskani","bakanlik_temsilcisi",
                "yk_uyesi","katip","tutanak_yazmani","divan_baskani"]
    best = (None, 0.0)
    for rk, aliases in ROLE_ALIASES.items():
        s = max((_alias_score(text_u, a) for a in aliases), default=0.0)
        if s > best[1] or (abs(s - best[1]) < 1e-6 and rk in priority and
                           (best[0] is None or priority.index(rk) < priority.index(best[0]))):
            best = (rk, s)
    return best if best[1] >= role_threshold else (None, 0.0)

def _extract_name_general(text_u: str) -> Optional[str]:
    t = _norm_text(text_u)
    # rakam / noktalama temizle (harf+boşluk bırak)
    t = re.sub(r"[^A-ZÇĞİÖŞÜ\s]", " ", t)
    t = re.sub(r"\s+", " ", t).strip()
    m = NAME_TOKEN.search(t)
    if m:
        return " ".join(p.capitalize() for p in m.group(0).split())
    # fallback: son 2-3 token
    parts = [p for p in t.split() if len(p) >= 2]
    return " ".join(parts[-3:]).title() if len(parts) >= 2 else None

def _extract_name_after_label(raw: str, label_aliases: List[str]) -> Optional[str]:
    lines = [ln.strip() for ln in (raw or "").splitlines() if ln.strip()]
    if not lines:
        return None
    norm_lines = [_norm_text(ln) for ln in lines]
    norm_aliases = [_norm_text(a) for a in label_aliases]
    # etiketi bul
    label_idx = None
    for i, nl in enumerate(norm_lines):
        if any(na in nl for na in norm_aliases):
            label_idx = i; break
    if label_idx is None:
        return None
    # sonraki 1–3 satırda isim ara, TCKN/metin içerenleri atla
    for j in range(label_idx + 1, min(label_idx + 4, len(lines))):
        cand = lines[j]
        if sum(ch.isdigit() for ch in cand) > 3:
            continue
        nt = _norm_text(cand)
        if NAME_TOKEN.search(nt):
            return " ".join(tok.capitalize() for tok in re.split(r"\s+", nt) if tok)
    return None

def cleanup_name(name: Optional[str]) -> Optional[str]:
    if not name:
        return None
    toks = [t for t in re.split(r"\s+", _norm_text(name)) if t]
    toks = [t for t in toks if not _looks_like_role_token(t)]      # rol kırıntılarını düş
    toks = [re.sub(r"[^A-ZÇĞİÖŞÜ]", "", t) for t in toks]          # harf dışını at
    toks = [t for t in toks if len(t) >= 2]
    if len(toks) < 2:
        return None
    return " ".join(w.capitalize() for w in toks[:3])

# =========================
# 2) BOX NORMALİZASYON & ÇİZİM
# =========================
def _to_xywh(b: Any) -> Optional[Tuple[int,int,int,int]]:
    if isinstance(b, (tuple, list, np.ndarray)) and len(b) == 4:
        x,y,w,h = [int(round(float(v))) for v in b];  return (x,y,w,h)
    for attrs in [("x","y","w","h"), ("left","top","width","height")]:
        if all(hasattr(b, a) for a in attrs):
            x,y,w,h = [int(round(float(getattr(b,a)))) for a in attrs];  return (x,y,w,h)
    for attrs in [("x0","y0","x1","y1"), ("left","top","right","bottom")]:
        if all(hasattr(b, a) for a in attrs):
            x0,y0,x1,y1 = [float(getattr(b,a)) for a in attrs]
            return (int(round(x0)), int(round(y0)), int(round(x1-x0)), int(round(y1-y0)))
    if isinstance(b, dict):
        if all(k in b for k in ("x","y","w","h")):
            return (int(b["x"]), int(b["y"]), int(b["w"]), int(b["h"]))
        if all(k in b for k in ("x0","y0","x1","y1")):
            return (int(b["x0"]), int(b["y0"]), int(b["x1"]-b["x0"]), int(b["y1"]-b["y0"]))
    return None

def normalize_boxes(boxes: List[Any]) -> List[Tuple[int,int,int,int]]:
    out=[]
    for b in boxes:
        nb = _to_xywh(b)
        if nb is None: continue
        x,y,w,h = nb
        if w>0 and h>0: out.append((x,y,w,h))
    return out

def draw_boxes_with_ids(img_bgr: np.ndarray,
                        boxes_xywh: List[Tuple[int,int,int,int]],
                        thickness: int = 2) -> np.ndarray:
    vis = img_bgr.copy()
    if vis.ndim == 2:
        vis = cv2.cvtColor(vis, cv2.COLOR_GRAY2BGR)
    for i,(x,y,w,h) in enumerate(boxes_xywh):
        cv2.rectangle(vis, (x,y), (x+w, y+h), (0,200,0), thickness)
        cv2.putText(vis, f"{i}", (x+4, y+18), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,120,0), 2, cv2.LINE_AA)
    return vis

# =========================
# 3) OCR (NEW_URL) & İMZA
# =========================
def _ocr_remote_png(img_bgr: np.ndarray, url: str,
                    lang: str="tur", config: str="--psm 6 --oem 1") -> str:
    ok, buf = cv2.imencode(".png", img_bgr)
    if not ok: return ""
    img_b64 = base64.b64encode(buf).decode()
    payload = {"image": img_b64, "lang": lang, "config": config}
    try:
        r = requests.post(url, json=payload, timeout=30)
        if r.ok:
            j = json.loads(r.text)
            return (j.get("text") or "").strip()
    except Exception:
        pass
    return ""

def ocr_text_from_box_remote(img: np.ndarray, box_xywh: Tuple[int,int,int,int], url: str) -> str:
    x,y,w,h = box_xywh
    roi = img[y:y+h, x:x+w]
    if roi.ndim == 2:
        roi = cv2.cvtColor(roi, cv2.COLOR_GRAY2BGR)
    return _ocr_remote_png(roi, url=url, lang="tur", config="--psm 6 --oem 1")

def has_signature(img: np.ndarray, box_xywh: Tuple[int,int,int,int],
                  ink_ratio_thr: float=0.02,
                  thinness_max: float=0.40,
                  min_blob_area_ratio: float=0.003,
                  max_blob_area_ratio: float=0.30) -> bool:
    x,y,w,h = box_xywh
    roi = img[y:y+h, x:x+w]
    gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY) if roi.ndim==3 else roi

    thr_ad = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                                   cv2.THRESH_BINARY_INV, 25, 10)
    thr_os = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)[1]
    thr = cv2.max(thr_ad, thr_os)

    ink_ratio = cv2.countNonZero(thr) / max(1, w*h)
    if ink_ratio < ink_ratio_thr:
        return False

    cnts,_ = cv2.findContours(thr, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts: 
        return False

    areas = [cv2.contourArea(c) for c in cnts]
    areas.sort(reverse=True)
    H, W = h, w
    largest = areas[0] / float(W*H)
    median  = (areas[len(areas)//2] / float(W*H)) if len(areas) >= 3 else 0.0

    # tipik metin -> çok küçük, çok sayıda
    if len(cnts) > 25 and largest < 0.02 and median < 0.0015:
        return False

    cnts = sorted(cnts, key=cv2.contourArea, reverse=True)[:3]
    for c in cnts:
        A = cv2.contourArea(c)
        if A <= 0:
            continue
        x0,y0,w0,h0 = cv2.boundingRect(c)
        area_ratio = A / float(W*H)
        if not (min_blob_area_ratio <= area_ratio <= max_blob_area_ratio):
            continue
        P = max(1.0, cv2.arcLength(c, True))
        thinness = 4*np.pi*A/(P*P)  # ince = küçük
        tall_enough = (h0/float(H) >= 0.30) or (w0/float(W) >= 0.30)
        if thinness < thinness_max and tall_enough:
            return True

    return False

# =========================
# 4) KOMŞU KUTU İSİM ARAMA
# =========================
def nearest_name_from_neighbors(i: int,
                                boxes_xywh: List[Tuple[int,int,int,int]],
                                texts_u: List[str],
                                same_row_tol: int = 20,
                                dx_max_factor: float = 1.7) -> Tuple[Optional[str], Optional[int]]:
    xi, yi, wi, hi = boxes_xywh[i]
    row_y_min = yi - same_row_tol
    row_y_max = yi + hi + same_row_tol
    dx_max = int(wi * dx_max_factor)

    cands=[]
    for j,(xj,yj,wj,hj) in enumerate(boxes_xywh):
        if j==i: continue
        if not (row_y_min <= yj <= row_y_max): continue
        if xj <= xi or (xj-xi) > dx_max: continue
        cands.append((j, xj-xi))
    cands.sort(key=lambda t:t[1])

    if not cands:
        below=[]
        for j,(xj,yj,wj,hj) in enumerate(boxes_xywh):
            if j==i: continue
            gap = yj - (yi+hi)
            if 0 < gap < int(1.2*hi):
                below.append((j, abs(xj-xi)))
        below.sort(key=lambda t:t[1])
        cands = below

    for j,_ in cands:
        name = _extract_name_general(texts_u[j])
        if name:
            return name, j
    return None, None

# =========================
# 5) DEBUG: BOX İNCELEME
# =========================
def inspect_boxes(lower_img: np.ndarray,
                  boxes: List[Any],
                  NEW_URL: str,
                  role_threshold: float = 0.8,
                  debug: bool=True) -> Tuple[np.ndarray, pd.DataFrame]:
    """
    Dönüş:
      vis_img  : kutular + indexler çizilmiş overlay (BGR)
      per_box_df: her kutu için OCR, imza, rol, isim, önizleme
    """
    boxes_xywh = normalize_boxes(boxes)
    vis_img = draw_boxes_with_ids(lower_img, boxes_xywh)

    rows = []
    for i,b in enumerate(boxes_xywh):
        txt = ocr_text_from_box_remote(lower_img, b, NEW_URL).strip()
        txt_u = _norm_text(txt)
        sig  = has_signature(lower_img, b)

        rk, score = best_role_for_text(txt_u, role_threshold=role_threshold)
        name_here = None
        if rk:
            name_here = (_extract_name_after_label(txt, ROLE_ALIASES[rk])
                         or _extract_name_general(txt_u))
        if name_here:
            name_here = cleanup_name(name_here)

        rows.append({
            "i": i,
            "bbox": b,
            "sig": bool(sig),
            "role_best": rk if rk else None,
            "role_score": round(score, 3),
            "name_in_box": name_here,
            "text_preview": re.sub(r"\s+", " ", txt_u)[:160]
        })

    per_box_df = pd.DataFrame(rows, columns=["i","bbox","sig","role_best","role_score","name_in_box","text_preview"])
    if debug:
        print(f"[INFO] {len(boxes_xywh)} box")
        display(per_box_df)

    return vis_img, per_box_df

# =========================
# 6) RAPOR → bottom_df
# =========================
def build_bottom_df_from_report(lower_img: np.ndarray,
                                boxes: List[Any],
                                per_box_df: pd.DataFrame) -> pd.DataFrame:
    boxes_xywh = normalize_boxes(boxes)
    n = len(boxes_xywh)

    # kutu bazlı OCR ve imza dizileri (inspect_boxes çıktısından)
    texts_u = [""]*n
    sigs    = [False]*n
    roles   = [None]*n
    names   = [None]*n
    for _,r in per_box_df.iterrows():
        i = int(r["i"])
        texts_u[i] = str(r.get("text_preview") or "")
        sigs[i]    = bool(r.get("sig", False))
        roles[i]   = r.get("role_best")
        nm        = r.get("name_in_box")
        names[i]   = str(nm) if nm else None

    # --- Sermaye arama ---
    def _parse_tl(text: str) -> Optional[float]:
        TL_NUM = re.compile(r"(\d{1,3}(?:\.\d{3})*(?:,\d{2})?|\d+)\s*(TL|₺)?", re.IGNORECASE)
        best=None
        for m in TL_NUM.finditer(text or ""):
            raw = m.group(1)
            v = raw.replace(".", "").replace(" ", "").replace(",", ".")
            try:
                val = float(v)
                best = val if (best is None or val>best) else best
            except: pass
        return best

    cap_keys = ["ŞİRKETİN SERMAYESİ","SERMAYESİ VE PAYLARIN TOPLAMI","SERMAYE","TOPLAM İTİBARİ DEĞERİ"]
    idxs = sorted([(sum(k in (t or "") for k in cap_keys), i) for i,t in enumerate(texts_u)], reverse=True)
    sermaye = None
    for score,i in idxs[:3]:
        if score==0: break
        for j in [i-1,i,i+1]:
            if 0 <= j < n:
                v = _parse_tl(texts_u[j] or "")
                if v is not None: sermaye=v; break
        if sermaye is not None: break
    if sermaye is None:
        vals = [_parse_tl(t or "") for t in texts_u]
        sermaye = max([v for v in vals if v is not None], default=None)

    out = {
        "sermaye_toplam_tl": sermaye,
        "toplanti_baskani_ad_soyad": None, "toplanti_baskani_imza_var_mi": None,
        "tutanak_yazmani_ad_soyad": None,  "tutanak_yazmani_imza_var_mi": None,
        "bakanlik_temsilcisi_ad_soyad": None, "bakanlik_temsilcisi_imza_var_mi": None,
        "yk_uyesi_ad_soyad": None, "yk_uyesi_imza_var_mi": None,
        "yk_baskani_ad_soyad": None, "yk_baskani_imza_var_mi": None,
        "katip_ad_soyad": None, "katip_imza_var_mi": None,
        "divan_baskani_ad_soyad": None, "divan_baskani_imza_var_mi": None,
    }

    def _set(role_key: str, name_val: Optional[str], sig_val: Optional[bool]):
        key_map = {
            "toplanti_baskani": ("toplanti_baskani_ad_soyad","toplanti_baskani_imza_var_mi"),
            "tutanak_yazmani":  ("tutanak_yazmani_ad_soyad","tutanak_yazmani_imza_var_mi"),
            "bakanlik_temsilcisi": ("bakanlik_temsilcisi_ad_soyad","bakanlik_temsilcisi_imza_var_mi"),
            "yk_uyesi":         ("yk_uyesi_ad_soyad","yk_uyesi_imza_var_mi"),
            "yk_baskani":       ("yk_baskani_ad_soyad","yk_baskani_imza_var_mi"),
            "katip":            ("katip_ad_soyad","katip_imza_var_mi"),
            "divan_baskani":    ("divan_baskani_ad_soyad","divan_baskani_imza_var_mi"),
        }
        if role_key not in key_map:
            return
        k_name, k_sig = key_map[role_key]
        if name_val and out[k_name] is None:
            out[k_name] = cleanup_name(name_val)
        if sig_val is not None and out[k_sig] is None:
            out[k_sig] = bool(sig_val)

    # Rol → alan doldurma
    for i, rk in enumerate(roles):
        if not rk:
            continue
        nm = names[i]
        sg = sigs[i]  # imza SADECE kendi kutusundan gelir
        if not nm:
            nn, _ = nearest_name_from_neighbors(i, boxes_xywh, texts_u)
            if nn:
                nm = nn  # imza taşınmaz
        _set(rk, nm, sg)

    return pd.DataFrame([out])