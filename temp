import cv2
import numpy as np
from typing import Tuple, Dict, Any

# ---------- Yardımcılar ----------

def normalize_black_white_safely(gray: np.ndarray,
                                 black_thresh: int = 130,
                                 white_thresh: int = 220) -> np.ndarray:
    """
    Siyaha yakınları 0, beyaza yakınları 255 yap.
    Arada kalanları yakın olduğu tarafa doğru iter; siyah strokları korur.
    """
    g = gray.astype(np.uint8)
    res = g.copy()
    res[g <= black_thresh] = 0
    res[g >= white_thresh] = 255
    mid_mask = (g > black_thresh) & (g < white_thresh)
    # orta griyi yakın olana yönlendir (eşiklerin ortası pivot)
    pivot = (black_thresh + white_thresh) // 2
    res[mid_mask] = np.where(g[mid_mask] < pivot, 0, 255).astype(np.uint8)
    return res

def otsu_with_bias(gray: np.ndarray, bias: int = -10) -> np.ndarray:
    """
    Otsu + küçük negatif bias: koyu gri yazıları da al.
    """
    thr, _ = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    thr = np.clip(thr + bias, 0, 255)
    _, bin_img = cv2.threshold(gray, thr, 255, cv2.THRESH_BINARY)
    return bin_img

def fast_deskew(binary: np.ndarray, max_dim: int = 3000) -> Tuple[np.ndarray, float]:
    """
    Hızlı açı tahmini: downscale ile minAreaRect; orijinale uygula.
    """
    if binary.ndim == 3:
        binary = cv2.cvtColor(binary, cv2.COLOR_BGR2GRAY)
    b = binary
    # downscale
    h, w = b.shape[:2]
    scale = 1.0
    if max(h, w) > max_dim:
        scale = max_dim / max(h, w)
        b = cv2.resize(b, None, fx=scale, fy=scale, interpolation=cv2.INTER_LINEAR)
    coords = cv2.findNonZero(255 - b)  # siyah (yazı) piksel koordinatları
    if coords is None:
        return binary, 0.0
    rect = cv2.minAreaRect(coords)
    angle = rect[-1]
    # OpenCV minAreaRect açı düzeltmesi
    if angle < -45:
        angle = 90 + angle
    # orijinal boyuta göre açı
    rot_angle = float(angle)

    # orijinale uygula
    center = (w // 2, h // 2)
    M = cv2.getRotationMatrix2D(center, rot_angle, 1.0)
    rotated = cv2.warpAffine(binary, M, (w, h), flags=cv2.INTER_LINEAR, borderValue=255)
    return rotated, rot_angle

def close_gaps_preserve_strokes(binary: np.ndarray) -> np.ndarray:
    """
    İnce yazıları öldürmeden harf içi boşlukları kapat.
    Küçük yatay + dikey closing ve hafif eğimli line kernel kombinasyonu.
    """
    # küçük boşluklar (1-2 px)
    k1 = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 1))
    k2 = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 2))
    closed = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, k1, iterations=1)
    closed = cv2.morphologyEx(closed, cv2.MORPH_CLOSE, k2, iterations=1)

    # 15° civarı eğimli kırık harf boşluklarını toparla (yaklaşık)
    k_diag = np.array([[0,1,1],
                       [0,1,1],
                       [0,0,1]], dtype=np.uint8)
    closed = cv2.morphologyEx(closed, cv2.MORPH_CLOSE, k_diag, iterations=1)
    return closed

def remove_isolated_specks(binary: np.ndarray,
                           min_area: int = 8,
                           max_area: int = 3000,
                           isolation_distance: int = 10,
                           roundness_max: float = 0.6) -> np.ndarray:
    """
    İzole siyah nokta/lekeleri sil (yazıya yakın olanı bırak).
    roundness_max: 1'e yakınsa dairesel; <0.6 yazıya benzerliği artırır.
    """
    inv = 255 - binary
    num, labels, stats, centroids = cv2.connectedComponentsWithStats(inv, connectivity=8)
    cleaned = inv.copy()

    h, w = inv.shape
    for i in range(1, num):
        x, y, bw, bh, area = stats[i]
        if area < min_area or area > max_area:
            continue
        # dairelilik (4πA / P^2)
        cnt = np.array(np.where(labels == i)).T[:, ::-1]
        # perimeter yaklaşık: dikdörtgen çevresi yerine kontur daha iyi, ama hızlı olsun:
        perim = 2 * (bw + bh)
        if perim == 0:
            continue
        roundness = 4 * np.pi * area / (perim * perim)

        if roundness > roundness_max:
            # komşulukta başka yazı var mı?
            x0 = max(x - isolation_distance, 0)
            y0 = max(y - isolation_distance, 0)
            x1 = min(x + bw + isolation_distance, w)
            y1 = min(y + bh + isolation_distance, h)
            roi = inv[y0:y1, x0:x1]
            # kendi dışında siyah piksel var mı?
            own = (labels[y0:y1, x0:x1] == i).sum()
            total = (roi > 0).sum()
            if total - own <= 2:  # neredeyse tek başına
                cleaned[labels == i] = 0  # sil
    return 255 - cleaned

def build_foreground_mask(binary: np.ndarray, bottom_strip: int = 10) -> np.ndarray:
    """
    Foreground maskesi: yazı=255, arka plan=0. Alt şeritteki küçük siyah lekeyi bastırır.
    """
    mask = 255 - binary  # siyah yazı -> 255
    # alt 10px temizle
    h, w = mask.shape
    strip = mask[h-bottom_strip:h, :]
    if np.count_nonzero(strip) < 0.05 * strip.size:
        mask[h-bottom_strip:h, :] = 0
    return mask

def crop_to_content(image: np.ndarray, mask: np.ndarray, margin: int = 10) -> np.ndarray:
    coords = cv2.findNonZero(mask)
    if coords is None:
        return image
    x, y, w, h = cv2.boundingRect(coords)
    h_img, w_img = image.shape[:2]
    x0 = max(x - margin, 0)
    y0 = max(y - margin, 0)
    x1 = min(x + w + margin, w_img)
    y1 = min(y + h + margin, h_img)
    return image[y0:y1, x0:x1]

# ---------- Boru hattı ----------

def enhance_document(img_bgr: np.ndarray,
                     gamma: float = 2.7,
                     black_thresh: int = 130,
                     white_thresh: int = 220,
                     otsu_bias: int = -10,
                     do_sharpen: bool = True,
                     debug: bool = False) -> Dict[str, Any]:
    """
    Verilen görüntüyü OCR için düzeltir: normalize → binarize → deskew → gap close →
    speck removal → crop. Ara çıktıları isterse döndürür.
    Returns dict: {"final", "gray", "normalized", "binary", "deskewed", "closed", "cleaned", "cropped"}
    """
    out: Dict[str, Any] = {}

    # 1) Grayscale + siyahı koruyan normalize
    if img_bgr.ndim == 3:
        gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)
    else:
        gray = img_bgr.copy()
    # hafif gamma, siyaha ağırlık
    gray_f = np.clip((gray / 255.0) ** (1.0 / gamma) * 255.0, 0, 255).astype(np.uint8)
    normalized = normalize_black_white_safely(gray_f, black_thresh, white_thresh)

    # 2) Binarize (Otsu + bias)
    binary0 = otsu_with_bias(normalized, bias=otsu_bias)

    # 3) Deskew (binariden)
    deskewed, angle = fast_deskew(binary0)

    # 4) Harf içi boşlukları doldur (ince strokları koruyarak)
    closed = close_gaps_preserve_strokes(deskewed)

    # 5) İzole leke temizliği
    cleaned = remove_isolated_specks(closed,
                                     min_area=8,
                                     max_area=3000,
                                     isolation_distance=12,
                                     roundness_max=0.7)

    # 6) Foreground maskesi ve crop
    mask = build_foreground_mask(cleaned, bottom_strip=10)
    cropped_bin = crop_to_content(cleaned, mask, margin=10)

    # 7) Opsiyonel hafif keskinleştirme (yalnızca binari değil, gri üzerinde)
    if do_sharpen:
        # Unsharp mask: gaussian + fark
        g = cv2.GaussianBlur(cropped_bin, (0, 0), 1.0)
        sharpened = cv2.addWeighted(cropped_bin, 1.5, g, -0.5, 0)
    else:
        sharpened = cropped_bin

    out["gray"] = gray
    out["normalized"] = normalized
    out["binary"] = binary0
    out["deskewed"] = deskewed
    out["closed"] = closed
    out["cleaned"] = cleaned
    out["cropped"] = cropped_bin
    out["final"] = sharpened
    out["deskew_angle_deg"] = angle
    return out

# img_bgr = cv2.imread("input.jpg")
result = enhance_document(img_bgr, debug=False)
final = result["final"]
# Kaydet:
# cv2.imwrite("enhanced.png", final)