def run_role_pipeline(
    detected_boxes,
    ocr_texts,
    *,
    sig_boxes=None,
    sermaye_boxes=None,
    lower_img=None,
    # augment (dikey birleştirme) ayarları
    x_policy="max",                 # "max" | "role"
    min_x_overlap_ratio=0.10,
    min_dy_px=0,
    max_dy_px=165,
    require_name_below=True,
    # split (çoklu rol ayırma) ayarları
    ROLE_ALIASES=None,
    gap_px=8,
    min_piece_w=14,
    fuzzy_enable=True,
    fuzzy_score_thr=86,
    small_space_policy="drop",      # "drop" | "keep_unsplit" | "shrink_gap"
    min_char_gap_between_roles=2,
    require_separator_for_split=True,
    dbg=False
):
    """
    Tek çağrıda: rol tespiti -> dikey ad-soyad birleştirme -> (gerekirse) çoklu rol split -> filtre.
    Girdi:
      - detected_boxes: x,y,w,h alanları olan kutular (attr ya da dict); ocr_texts ile bire bir sıralı.
      - ocr_texts: her kutunun OCR metni.
      - sig_boxes/sermaye_boxes: varsa, aynı tipte kutu listeleri.
    Çıkış:
      - [{'x','y','w','h','txt','role'}, ...] listesi.
    """
    # ----------------
    # Imports & helpers (içeride tut)
    # ----------------
    import re, copy, unicodedata

    try:
        from rapidfuzz import fuzz
        _FUZZY_OK = True
    except Exception:
        _FUZZY_OK = False
        class _F:
            @staticmethod
            def partial_ratio(a,b): return 0
            @staticmethod
            def token_set_ratio(a,b): return 0
        fuzz = _F()

    def _get(b, k, d=None):
        if isinstance(b, dict): return b.get(k, d)
        return getattr(b, k, d)

    def _set(b, k, v):
        if isinstance(b, dict): b[k] = v
        else: setattr(b, k, v)

    def _as_box_tuple(b):
        return int(_get(b,"x")), int(_get(b,"y")), int(_get(b,"w")), int(_get(b,"h"))

    def _xyxy(b):
        x,y,w,h = _as_box_tuple(b)
        return x, y, x+w, y+h

    def _y_gap(top, bottom):
        _, _, _, ty2 = _xyxy(top)
        _, by1, _, _ = _xyxy(bottom)
        return by1 - ty2

    def _x_overlap_ratio(a,b):
        ax1,_,ax2,_ = _xyxy(a)
        bx1,_,bx2,_ = _xyxy(b)
        inter = max(0, min(ax2,bx2) - max(ax1,bx1))
        base  = max(1, min(_get(a,"w"), _get(b,"w")))
        return inter / base

    def _iou(a,b):
        ax1,ay1,ax2,ay2 = _xyxy(a)
        bx1,by1,bx2,by2 = _xyxy(b)
        ix1,iy1 = max(ax1,bx1), max(ay1,by1)
        ix2,iy2 = min(ax2,bx2), min(ay2,by2)
        if ix2<=ix1 or iy2<=iy1: return 0.0
        inter = (ix2-ix1)*(iy2-iy1)
        area  = (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) - inter
        return inter / max(area,1)

    def _overlaps_any_iou(candidate, boxes, thr=0.03):
        if not boxes: return False
        for b in boxes:
            if _iou(candidate, b) >= thr:
                return True
        return False

    def _rect(x,y,w,h, txt="", role=None):
        return {"x":int(x),"y":int(y),"w":int(w),"h":int(h),"txt":txt,"role":role}

    # --- text utils
    def tr_upper(s):
        return (s or "").replace("i","İ").replace("ı","I").upper()

    def strip_diac(s):
        return "".join(c for c in unicodedata.normalize("NFKD", s) if not unicodedata.combining(c))

    def canon(s):
        import re as _re
        return _re.sub(r"\s+"," ", tr_upper(strip_diac(s))).strip()

    TR = "A-Za-zÇĞİÖŞÜçğıöşü"
    NAME_LINE_RE = re.compile(rf"\b[{TR}][{TR}'-]+\s+[{TR}][{TR}'-]+(\s+[{TR}][{TR}'-]+)?\b")
    AD_SOYAD_HINT_RE = re.compile(r"\bad\s*[-:]?\s*soyad[ıi]?\b", re.I)
    def looks_like_person_line(t):
        if not t: return False
        if sum(ch.isdigit() for ch in t) > 2 and "T.C" not in t and "TC" not in t:
            return False
        t_clean = " ".join(t.split())
        if AD_SOYAD_HINT_RE.search(t_clean): 
            return True
        return bool(NAME_LINE_RE.search(t_clean))

    def has_inline_name(txt):
        if not txt: return False
        letters = re.findall(rf"[{TR}]", txt)
        if len("".join(letters)) < 4: return False
        return bool(re.compile(rf"(?i)\b[{TR}]{{2,}}\b(?:[\s\W]+?\b[{TR}]{{2,}}\b)+").search(txt))

    # --- aliases
    ROLE_ALIASES_DEFAULT = {
        "toplanti_baskani":    ["TOPLANTI BAŞKANI", "TOPLANTI BASKANI"],
        "tutanak_yazmani":     ["TUTANAK YAZMANI", "YAZMAN"],
        "bakanlik_temsilcisi": ["BAKANLIK TEMSİLCİSİ", "TİCARET BAKANLIĞI TEMSİLCİSİ", "TICARET BAKANLIGI TEMSILCISI"],
        "yk_baskani":          ["YÖNETİM KURULU BAŞKANI", "YONETİM KURULU BASKANI", "YK BAŞKANI", "YK BASKANI"],
        "yk_uyesi":            ["YÖNETİM KURULU ÜYESİ", "YONETİM KURULU ÜYELERİ", "YONETIM KURULU UYESI", "YK ÜYESİ", "YK UYESI"],
        "katip":               ["KÂTİP", "KATİP", "OY TOPLAMA MEMURU", "OY TOPLAYICI"],
        "divan_baskani":       ["DİVAN BAŞKANI", "DIVAN BASKANI"],
        # "baskan":            ["BAŞKAN"],  # çok genel, gerekirse eklenir.
    }

    def prepare_aliases(ROLE_ALIASES):
        if ROLE_ALIASES is None: ROLE_ALIASES = ROLE_ALIASES_DEFAULT
        ALIASES = [(fam, canon(v)) for fam, vals in ROLE_ALIASES.items() for v in vals]
        ALIASES.sort(key=lambda t: len(t[1]), reverse=True)
        return ROLE_ALIASES, ALIASES

    ROLE_ALIASES, ALIASES = prepare_aliases(ROLE_ALIASES)

    # ----------------
    # 0) detected -> internal copy with text
    # ----------------
    det_boxes = []
    for b, t in zip(detected_boxes, ocr_texts):
        x,y,w,h = _as_box_tuple(b)
        det_boxes.append({"x":x,"y":y,"w":w,"h":h,"txt":(t or ""), "role":None, "inline_name":has_inline_name(t or "")})
    if dbg: print(f"[INIT] {len(det_boxes)} boxes.")

    # ----------------
    # 1) detect roles
    # ----------------
    ALL_KEY_STR = {v for vals in ROLE_ALIASES.values() for v in vals}
    role_boxes = []
    for b in det_boxes:
        T = (b["txt"] or "").upper()
        hit = next((k for k in ALL_KEY_STR if k in T), None)
        if hit:
            b["role"] = hit
            role_boxes.append(b)
            if dbg: print(f"[ROLE] {hit} @({b['x']},{b['y']},{b['w']},{b['h']}) :: {b['txt'][:80]}")

    # ----------------
    # 2) dikey birleştirme (sadece alttan + isim satırı şartı opsiyonel)
    # ----------------
    pool = [b for b in det_boxes if b not in role_boxes]
    merged_blocks = []
    taken_ids = set()

    for rb in sorted(role_boxes, key=lambda b: (b["y"], b["x"])):
        best, best_score = None, None
        for cb in pool:
            if id(cb) in taken_ids: 
                continue
            dy = _y_gap(rb, cb)
            if dy < -min_dy_px: continue
            if max_dy_px is not None and dy > max_dy_px: continue
            xov = _x_overlap_ratio(rb, cb)
            if xov < min_x_overlap_ratio: continue
            if require_name_below and not (looks_like_person_line(cb["txt"]) or has_inline_name(cb["txt"])):
                continue
            if sig_boxes:
                if _overlaps_any_iou(cb, sig_boxes, thr=0.02): 
                    if dbg: print("[SKIP] candidate hits signature"); 
                    continue
                # birleştirme önizleme
                rx1,ry1,rx2,ry2 = _xyxy(rb); cx1,cy1,cx2,cy2 = _xyxy(cb)
                if x_policy == "role":
                    mx1, mx2 = rx1, rx2
                else:
                    mx1, mx2 = min(rx1,cx1), max(rx2,cx2)
                my1, my2 = min(ry1,cy1), max(ry2,cy2)
                if _overlaps_any_iou({"x":mx1,"y":my1,"w":mx2-mx1,"h":my2-my1}, sig_boxes, thr=0.02):
                    if dbg: print("[SKIP] merged hits signature"); 
                    continue
            score = (-abs(dy), xov)
            if best_score is None or score > best_score:
                best, best_score = cb, score

        if best is not None:
            rx1,ry1,rx2,ry2 = _xyxy(rb)
            cx1,cy1,cx2,cy2 = _xyxy(best)
            ny1, ny2 = ry1, max(ry2, cy2)
            if x_policy == "max":
                nx1, nx2 = min(rx1, cx1), max(rx2, cx2)
            elif x_policy == "role":
                nx1, nx2 = rx1, rx2
            else:
                raise ValueError("x_policy must be 'max' or 'role'")
            merged_blocks.append(_rect(nx1, ny1, nx2-nx1, ny2-ny1, txt=f"{rb['txt']} + {best['txt']}", role=rb["role"]))
            taken_ids.add(id(best))
            if dbg: print(f"[ROLE+NAME] {rb['role']} -> {best['txt'][:60]}")
        else:
            # rol tek başına kalsın
            merged_blocks.append(_rect(rb["x"],rb["y"],rb["w"],rb["h"], txt=rb["txt"], role=rb["role"]))

    # inline name içeren saf rol satırlarını da ekle
    for b in role_boxes:
        if b.get("inline_name"):
            merged_blocks.append(_rect(b["x"],b["y"],b["w"],b["h"], txt=b["txt"], role=b["role"]))

    # aynı role için role-only kutuyu, role+name ile büyük oranda çakışıyorsa sil
    cleaned = []
    for b in merged_blocks:
        is_role_only = not (looks_like_person_line(b["txt"]) or has_inline_name(b["txt"]))
        if not is_role_only:
            cleaned.append(b); continue
        keep = True
        for c in merged_blocks:
            if c is b: continue
            if c["role"] == b["role"] and _iou(b,c) > 0.5:
                keep = False; break
        if keep: cleaned.append(b)
    merged_blocks = cleaned

    # ----------------
    # 3) çoklu rol split (konservatif)
    # ----------------
    SEP_RE = re.compile(r"(?:\s*[;,/|]\s*|\s+\bVE\b\s+|\s*/\s*)", re.I)

    def detect_roles_with_positions(text):
        t = canon(text)
        taken = [False]*len(t)
        spans = []

        # exact
        for fam, cv in ALIASES:
            start = 0
            while True:
                idx = t.find(cv, start)
                if idx == -1: break
                rng = range(idx, idx+len(cv))
                if any(taken[i] for i in rng):
                    start = idx + 1; continue
                for i in rng: taken[i] = True
                spans.append((fam, (idx, idx+len(cv))))
                start = idx + len(cv)

        # fuzzy (gerekirse)
        if fuzzy_enable and _FUZZY_OK and len(spans) <= 1:
            cands = []
            for fam, cv in ALIASES:
                s1 = fuzz.partial_ratio(t, cv)
                s2 = fuzz.token_set_ratio(t, cv)
                sc = max(s1, s2)
                if sc >= fuzzy_score_thr:
                    key = cv.split()[0]
                    pos = t.find(key)
                    if pos == -1: pos = len(t) + 10
                    cands.append((fam, pos, sc, cv))
            cands.sort(key=lambda x: (-x[2], x[1]))
            for fam, pos, _, cv in cands:
                if any(f==fam for f,_ in spans): 
                    continue
                spans.append((fam, (max(0,pos), min(len(t), pos+len(cv)))))

        # genel "BAŞKAN" varsa ve spesifikler de varsa, geneli at
        fams = [f for f,_ in spans]
        if any(f in fams for f in ("divan_baskani","toplanti_baskani","yk_baskani")):
            spans = [(f,xy) for f,xy in spans if f!="baskan"]

        spans.sort(key=lambda kv: kv[1][0])
        return spans

    splitted = []
    for b in merged_blocks:
        txt = b["txt"] or ""
        spans = detect_roles_with_positions(txt)
        fams = [fam for fam,_ in spans]

        if dbg:
            print(f"[roles?] {fams} :: {txt[:80]!r}")

        # tek/0 rol: bölme yok
        if len(fams) <= 1:
            nb = copy.deepcopy(b)
            if fams: nb["role"] = fams[0]
            splitted.append(nb)
            continue

        # split kararı: ayraç + alias pozisyonları arasında boşluk kontrolü
        t_canon = canon(txt)
        has_sep = bool(SEP_RE.search(t_canon))
        spans_ok = True
        for (_, (s1,e1)), (_, (s2,e2)) in zip(spans, spans[1:]):
            if s2 - e1 < min_char_gap_between_roles:
                spans_ok = False; break
        if require_separator_for_split and not has_sep:
            spans_ok = False

        if not spans_ok:
            nb = copy.deepcopy(b)
            nb["role"] = fams[0]
            splitted.append(nb)
            if dbg: print("[no-split] weak evidence; kept unsplit.")
            continue

        # parçalara böl (genişlik paylaştır)
        N = len(fams)
        x,y,x2,y2 = _xyxy(b)
        W = x2 - x
        needed = N*min_piece_w + (N-1)*gap_px
        if needed > W:
            if small_space_policy == "drop":
                if dbg: print(f"[drop] W={W} < needed={needed} (N={N})")
                continue
            elif small_space_policy == "keep_unsplit":
                nb = copy.deepcopy(b); nb["role"]=fams[0]; splitted.append(nb); continue
            else:
                possible_gap = max(0, (W - N*min_piece_w)) // max(1,(N-1))
                gap = possible_gap
        else:
            gap = gap_px

        usable = W - gap*(N-1)
        base = usable // N
        rem  = usable % N
        cur_x = x
        for i in range(N):
            w_piece = max(min_piece_w, base + (1 if i < rem else 0))
            nb = _rect(cur_x, y, w_piece, y2-y, txt=b["txt"], role=fams[i])
            splitted.append(nb)
            if i < N-1:
                cur_x += w_piece + gap

    # ----------------
    # 4) sermaye çakışmalarını ele
    # ----------------
    if sermaye_boxes:
        sb = [{"x":_get(s,"x"),"y":_get(s,"y"),"w":_get(s,"w"),"h":_get(s,"h")} for s in sermaye_boxes]
        keep = []
        for b in splitted:
            if any(_iou(b, s) >= 0.08 for s in sb):
                continue
            keep.append(b)
        splitted = keep

    # ----------------
    # (opsiyonel) çizim
    # ----------------
    if lower_img is not None:
        try:
            import cv2
            vis = lower_img.copy()
            for b in splitted:
                x,y,w,h = b["x"],b["y"],b["w"],b["h"]
                cv2.rectangle(vis, (x,y), (x+w,y+h), (0,255,0), 2)
            # geri döndürmüyoruz; dışarıda göster
        except Exception:
            pass

    return splitted