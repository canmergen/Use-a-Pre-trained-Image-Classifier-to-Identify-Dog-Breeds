def _find_company(
    lines: List[str],
    *,
    fuzzy_type_thresh: float = 0.82,
    fuzzy_join_lines: bool = True,
) -> Tuple[Optional[str], Optional[str]]:
    """
    Tip anahtar kelimesi (A.Ş., LTD. ŞTİ., ANONİM ŞİRKETİ vb.) bulunan satırda,
    tipin SOLUNDA kalan parçayı şirket adı kabul eder. Bu parça kısaysa veya
    'AN/VE/TİC/SAN' gibi kötü bitiyorsa **bir önceki satır** da eklenir.
    """

    # --- küçük yardımcılar ---
    def _q(name: str) -> float:
        if not name: return 0.0
        s = unicodedata.normalize("NFKC", name)
        letters = sum(ch.isalpha() for ch in s)
        digits  = sum(ch.isdigit() for ch in s)
        if letters < 3 or letters <= digits: return 0.0
        toks = [t for t in re.split(r"\s+", s.strip()) if t]
        return 0.6*min(len(s)/80.0, 1.0) + 0.3*min(len(toks)/8.0, 1.0) + 0.1*(letters/(letters+digits+1e-6))

    def _fix_breaks(t: str) -> str:
        # “s AN” → “SAN”, “T I C/T İ C” → “TİC”, boşluk sadeleştirme
        t = re.sub(r"\bS\s+AN\b", "SAN", t, flags=re.IGNORECASE)
        t = re.sub(r"\bT\s*İ?\s*C\b", "TİC", t, flags=re.IGNORECASE)
        t = re.sub(r"\s+([.,:;])", r"\1", t)
        t = re.sub(r"\s+", " ", t)
        return t.strip()

    BAD_ENDS = {"AN","VE","TIC","TİC","SAN","VE.","VE,","TIC.","TİC.","SAN."}

    # Tip anchor’ları: (mevcut kodundakiyle uyumlu)
    _TYPE_ANCHORS = [
        r"A\.?\s*Ş\.?", r"AŞ",
        r"ANON[İI]M\s+Ş[İI]RKET[İI]?",
        r"LTD\.?\s*ŞT[İI]", r"LTD\.?\s*ST[İI]",
        r"L[İI]M[İI]TED\s+Ş[İI]RKET[İI]?",
        r"Ş[İI]RKET[İI]?", r"HOLD[İI]NG",
        r"KOOPERAT[İI]F",
        r"KOLEKT[İI]F\s+Ş[İI]RKET[İI]?",
        r"AD[İI]\s+KOMAND[İI]T\s+Ş[İI]RKET[İI]?",
        r"SERMAYES[İI]\s+PAYLARA\s+BÖLÜNMÜŞ\s+KOMAND[İI]T\s+Ş[İI]RKET[İI]?",
        r"KOMAND[İI]T\s+Ş[İI]RKET[İI]?",
        r"VAK(I|İ)F", r"DERNEK"
    ]
    # Soldaki şirket adını yakalamak için: satır başından anchor’a kadar olan kısım (group 1)
    RAW_CUT_RE = re.compile(rf"^\s*(?P<left>.*?)\s*(?:{'|'.join(_TYPE_ANCHORS)})\b.*$", re.IGNORECASE)

    def _map_type_label(segment: str) -> Optional[str]:
        up = _normalize_line(segment)
        for creg, label in TYPE_REGEX:
            if creg.search(up):
                return label
        return None

    # ---- giriş satırlarını sadeleştir ----
    src = [s for s in (lines or []) if isinstance(s, str)]
    src = [s.strip() for s in src if s.strip()]
    if not src:
        return None, None

    best = None  # (score, cname_raw, ctype)

    for i, raw in enumerate(src):
        m = RAW_CUT_RE.match(raw)
        if not m:
            continue

        left = _fix_breaks(m.group("left").strip())

        # Sol parça boş ya da kötü/çok kısa ise bir önceki satırı ekle
        if (not left) or (len(left) < 8) or (re.sub(r".*\s", "", left).upper() in BAD_ENDS):
            if i > 0:
                left = _fix_breaks(src[i-1].strip() + " " + left).strip()

        # Hâlâ kötü son varsa bir öncekiyi bir kez daha eklemeyi dene
        tail = re.sub(r".*\s", "", left).upper()
        if tail in BAD_ENDS and i > 1:
            left = _fix_breaks(src[i-2].strip() + " " + left).strip()

        q = _q(left)
        if q <= 0:
            continue

        ctype = _map_type_label(raw[m.start():m.end()])  # bu satırdaki tip metni üzerinden etiketle
        sc = q + 0.05*min(len(left)/60.0, 1.0)
        if (best is None) or (sc > best[0]):
            best = (sc, left, ctype)

    if best:
        return best[1], best[2]

    # ---- fallback: mevcut eski mantıklarını koru (bozulmasın) ----
    # REGEX satır bazlı
    best_regex = None
    for i, raw in enumerate(src):
        norm = _normalize_line(raw)
        for creg, label in TYPE_REGEX:
            mm = creg.search(norm)
            if not mm:
                continue
            cand = raw.strip() if mm.start() == 0 else raw[:mm.start()].strip()
            q = _q(cand)
            if q > 0 and ((best_regex is None) or (q > best_regex[0]) or (q == best_regex[0] and i < best_regex[1])):
                best_regex = (q, i, str(cand), label)
    if best_regex:
        return best_regex[2], best_regex[3]

    # FUZZY satır bazlı
    best_fuzzy = None
    for i, raw in enumerate(src):
        norm = _normalize_line(raw)
        best_label, best_score = None, 0.0
        for canonical, variants in CANON_TYPES.items():
            sc = max(_fuzzy_ratio(v, norm) for v in variants)
            if sc > best_score:
                best_score, best_label = sc, canonical
        if best_label and best_score >= fuzzy_type_thresh:
            cand = _fix_breaks(raw.strip())
            q = _q(cand)
            if q > 0:
                rank = 0.7*best_score + 0.3*min(q, 1.0)
                if (best_fuzzy is None) or (rank > best_fuzzy[0]) or (rank == best_fuzzy[0] and i < best_fuzzy[1]):
                    best_fuzzy = (rank, i, str(cand), best_label)
    if best_fuzzy:
        return best_fuzzy[2], best_fuzzy[3]

    # FUZZY join
    if fuzzy_join_lines and src:
        joined_raw = _fix_breaks(" ".join(src[:3] if len(src) >= 3 else src))
        joined_norm = _normalize_line(joined_raw)
        best_label, best_score = None, 0.0
        for canonical, variants in CANON_TYPES.items():
            sc = max(_fuzzy_ratio(v, joined_norm) for v in variants)
            if sc > best_score:
                best_score, best_label = sc, canonical
        if best_label and best_score >= fuzzy_type_thresh and _q(joined_raw) > 0:
            return joined_raw, best_label

    return None, None