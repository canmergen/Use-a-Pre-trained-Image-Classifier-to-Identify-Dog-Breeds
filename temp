import cv2
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, Optional

def return_binary_mask(
    table: np.ndarray,
    ver_kernels: Optional[Tuple[int, int]] = None,
    hor_kernels: Optional[Tuple[int, int]] = None,
    hor_erode_iter: int = 2,
    ver_erode_iter: int = 1,
    handle_inv: bool = True,
    min_cov_h: float = 0.4,
    min_cov_v: float = 0.4,
    min_gap_frac: float = 0.015,
    compact_ratio: float = 0.5,   # imza sütunundaki sık çizgileri birleştirme şiddeti
    debug: bool = False,
):
    """
    Çıktı:
      binary_lines      : yatay+dikey çizgi maskesi
      binary_horizontal : yatay çizgi maskesi
      binary_vertical   : dikey çizgi maskesi
      rows_y            : grid yatay eksenleri (üst+ara+alt)
      cols_x            : grid dikey eksenleri (sol+ara+sağ)
    """

    # ----------------- yardımcı fonksiyonlar -----------------

    def add_borders(img: np.ndarray, border: int = 2) -> np.ndarray:
        img[:border, :] = 255
        img[-border:, :] = 255
        img[:, :border] = 255
        img[:, -border:] = 255
        return img

    def extract_axes_from_mask(mask: np.ndarray,
                               axis: str,
                               min_coverage: float,
                               min_gap_px: int,
                               title: str = "",
                               dbg: bool = False) -> np.ndarray:
        """
        1D projeksiyon ile eksen merkezlerini bulur.
        axis = 'h' -> satır eksenleri (y)
        axis = 'v' -> sütun eksenleri (x)
        """
        H, W = mask.shape

        if axis == "h":
            proj = mask.sum(axis=1) / (255.0 * max(1, W))
            length = H
        else:
            proj = mask.sum(axis=0) / (255.0 * max(1, H))
            length = W

        is_line = proj > min_coverage

        centers = []
        i = 0
        while i < length:
            if not is_line[i]:
                i += 1
                continue
            j = i + 1
            while j < length and is_line[j]:
                j += 1
            c = (i + j - 1) // 2
            centers.append(c)
            i = j

        merged = []
        for c in centers:
            if not merged or c - merged[-1] >= min_gap_px:
                merged.append(c)
            else:
                merged[-1] = int((merged[-1] + c) / 2)

        merged = np.array(merged, dtype=int)

        if dbg:
            xs = np.arange(length)
            plt.figure(figsize=(10, 3))
            plt.plot(xs, proj, label="projection")
            if len(merged) > 0:
                plt.scatter(merged, proj[merged], c="red", s=30, label="axes")
            plt.title(title)
            plt.legend()
            plt.tight_layout()
            plt.show()

        return merged

    def merge_dense_axes(axes: np.ndarray,
                         ratio: float) -> np.ndarray:
        """
        Çok yakın eksenleri, gap dağılımına göre birleştirir.
        Sadece *aşırı küçük* gap'leri merge eder (imza içi çizgiler).
        Gerçek kolon aralıklarına dokunmaz.
        """
        if axes is None or len(axes) <= 2:
            return axes

        gaps = np.diff(axes).astype(float)
        valid = gaps[gaps > 0]
        if len(valid) == 0:
            return axes

        q1 = np.percentile(valid, 25)     # küçük gap'lerin tipik değeri
        median = np.median(valid)         # gerçek kolon aralığı tipik değeri

        # sadece en küçük aralıklara dokun: thresh = min(q1, median * ratio)
        thresh = min(q1, median * ratio)

        merged = [axes[0]]
        for dx, x in zip(gaps, axes[1:]):
            if dx < thresh:
                # aynı kolon içindeki iç çizgiler → ortalama al
                merged[-1] = int((merged[-1] + x) / 2)
            else:
                merged.append(x)

        return np.array(merged, dtype=int)

    # ----------------- 1) gri + threshold -----------------

    if table.ndim == 3:
        gray = cv2.cvtColor(table, cv2.COLOR_BGR2GRAY)
    else:
        gray = table.copy()

    _, binary = cv2.threshold(gray, 240, 255, cv2.THRESH_BINARY_INV)
    binary = add_borders(binary)

    H, W = binary.shape[:2]

    # ----------------- 2) kernel boyutlarını dinamik seç -----------------

    if hor_kernels is None:
        kw = max(25, W // 20)
        hor_kernels = (kw, 1)

    if ver_kernels is None:
        kh = max(25, H // 20)
        ver_kernels = (1, kh)

    kernel_hor = cv2.getStructuringElement(cv2.MORPH_RECT, hor_kernels)
    kernel_ver = cv2.getStructuringElement(cv2.MORPH_RECT, ver_kernels)

    # ----------------- 3) yatay / dikey çizgiler -----------------

    binary_horizontal = cv2.erode(binary, kernel_hor, iterations=hor_erode_iter)
    binary_horizontal = cv2.dilate(binary_horizontal, kernel_hor, iterations=20)

    binary_vertical = cv2.erode(binary, kernel_ver, iterations=ver_erode_iter)
    binary_vertical = cv2.dilate(binary_vertical, kernel_ver, iterations=20)

    # ----------------- 4) sağ taraftaki anomalik kolon kırpma -----------------

    if handle_inv:
        inv_x_range = 0
        for x in range(W):
            if np.mean(binary_vertical[:, x]) == 0:
                inv_x_range = x
                break

        if inv_x_range >= W * 0.15:
            binary_vertical[:, :max(0, 2 * inv_x_range - 2)] = 0

    # ----------------- 5) birleşik maske -----------------

    binary_lines = cv2.addWeighted(binary_vertical, 0.5,
                                   binary_horizontal, 0.5, 0.0)

    # ----------------- 6) grid eksenleri -----------------

    min_gap_h = max(3, int(H * min_gap_frac))
    min_gap_v = max(3, int(W * min_gap_frac))

    rows_y = extract_axes_from_mask(
        binary_horizontal,
        axis="h",
        min_coverage=min_cov_h,
        min_gap_px=min_gap_h,
        title="Row projection",
        dbg=debug,
    )

    cols_x_raw = extract_axes_from_mask(
        binary_vertical,
        axis="v",
        min_coverage=min_cov_v,
        min_gap_px=min_gap_v,
        title="Column projection (raw)",
        dbg=debug,
    )

    cols_x = merge_dense_axes(cols_x_raw, ratio=compact_ratio)

    # ----------------- 7) DEBUG görselleştirme (kalın, parlak çizgiler) -----------------

    if debug:
        print(f"rows_y (len={len(rows_y)}): {rows_y}")
        print(f"cols_x_raw (len={len(cols_x_raw)}): {cols_x_raw}")
        print(f"cols_x_merged (len={len(cols_x)}): {cols_x}")

        # orijinal griyi parlak arka plan olarak kullan
        vis = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
        # biraz açalım
        vis = cv2.normalize(vis, None, 200, 255, cv2.NORM_MINMAX)

        # yatay eksenler: parlak yeşil, kalın
        for y in rows_y:
            cv2.line(vis, (0, y), (W - 1, y), (0, 255, 0), 3)

        # dikey eksenler: parlak kırmızı, kalın
        for x in cols_x:
            cv2.line(vis, (x, 0), (x, H - 1), (255, 0, 0), 3)

        plt.figure(figsize=(8, 8))
        plt.title("Detected grid axes (bright)")
        # BGR -> RGB
        plt.imshow(vis[:, :, ::-1])
        plt.axis('off')
        plt.tight_layout()
        plt.show()

    return binary_lines, binary_horizontal, binary_vertical, rows_y, cols_x

bin_lines, hmask, vmask, rows_y, cols_x = return_binary_mask(
    binarized_tables[i],
    debug=True
)

n_rows = len(rows_y) - 1
n_cols = len(cols_x) - 1
print(f"Page {i}: rows={n_rows}, cols={n_cols}")