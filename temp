import cv2
import math
import numpy as np
import matplotlib.pyplot as plt
from collections import defaultdict

def visualize_role_boxes(
    final_lower_imgs,
    role_boxes,
    ocr_sizes=None,          # Optional: [(h,w) per page used during OCR]. If None, no scaling.
    label_font_scale=0.6,
    box_thickness=2,
    label_bg=True,
    return_images=False,     # If True, returns list of annotated images
):
    """
    Draw role boxes on each page image.

    Parameters
    ----------
    final_lower_imgs : List[np.ndarray]
        Page images (BGR or RGB).
    role_boxes : List[Dict]
        Output list from extract_role_boxes(). Must contain 'page_index' and 'bbox'.
        bbox expected keys: x_min, y_min, width, height (in OCR coordinate space).
    ocr_sizes : Optional[List[Tuple[int,int]]]
        (height, width) for each page that produced the bboxes (e.g., 1048x1048).
        If provided and differs from the current image shape, boxes are scaled.
    return_images : bool
        If True, returns the annotated images list.

    Notes
    -----
    - If your OCR and images are same resolution, set ocr_sizes=None.
    - If OCR used fixed size (e.g., 1048,1048) for all pages, pass
      ocr_sizes=[(1048,1048)] * len(final_lower_imgs)
    """
    # group detections by page
    by_page = defaultdict(list)
    for r in role_boxes:
        by_page[int(r["page_index"])].append(r)

    annotated = []
    for pi, img in enumerate(final_lower_imgs):
        if img is None:
            annotated.append(None)
            continue

        # ensure BGR for cv2 drawing
        draw_img = img.copy()
        if draw_img.ndim == 2:
            draw_img = cv2.cvtColor(draw_img, cv2.COLOR_GRAY2BGR)
        elif draw_img.shape[2] == 4:
            draw_img = cv2.cvtColor(draw_img, cv2.COLOR_BGRA2BGR)

        H, W = draw_img.shape[:2]

        # scale factors if OCR size provided
        if ocr_sizes is not None and len(ocr_sizes) > pi and ocr_sizes[pi] is not None:
            oH, oW = ocr_sizes[pi]
            sx = W / float(oW)
            sy = H / float(oH)
        else:
            sx = sy = 1.0

        for r in by_page.get(pi, []):
            b = r["bbox"]
            x1 = int(round(b.get("x_min", 0) * sx))
            y1 = int(round(b.get("y_min", 0) * sy))
            x2 = int(round((b.get("x_min", 0) + b.get("width", 0)) * sx))
            y2 = int(round((b.get("y_min", 0) + b.get("height", 0)) * sy))

            # clip to image
            x1 = max(0, min(W - 1, x1)); x2 = max(0, min(W - 1, x2))
            y1 = max(0, min(H - 1, y1)); y2 = max(0, min(H - 1, y2))

            # draw rectangle
            cv2.rectangle(draw_img, (x1, y1), (x2, y2), (0, 255, 0), box_thickness)

            # label
            role = r.get("role", "")
            score = r.get("score", None)
            label = role if score is None else f"{role} ({score:.0f})"
            # compute label box
            t_size, _ = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, label_font_scale, 1)
            tx2 = min(W - 1, x1 + t_size[0] + 8)
            ty2 = max(0, y1 - t_size[1] - 8)
            if label_bg:
                cv2.rectangle(draw_img, (x1, y1 - t_size[1] - 10), (tx2, y1), (0, 255, 0), -1)
                cv2.putText(draw_img, label, (x1 + 4, y1 - 6),
                            cv2.FONT_HERSHEY_SIMPLEX, label_font_scale, (0, 0, 0), 1, cv2.LINE_AA)
            else:
                cv2.putText(draw_img, label, (x1, max(12, y1 - 4)),
                            cv2.FONT_HERSHEY_SIMPLEX, label_font_scale, (0, 255, 0), 2, cv2.LINE_AA)

        annotated.append(draw_img)

        # show per page with matplotlib (expects RGB)
        plt.figure(figsize=(10, 10))
        plt.title(f"Page {pi}")
        plt.imshow(cv2.cvtColor(draw_img, cv2.COLOR_BGR2RGB))
        plt.axis('off')
        plt.show()

    if return_images:
        return annotated

role_boxes = extract_role_boxes(pages_scaled)
visualize_role_boxes(final_lower_imgs, role_boxes, ocr_sizes=None)



def extract_role_boxes(
    pages_scaled,
    fuzzy_cutoff: int = 86,
    use_fuzzy: bool = True,
):
    """
    OCR metinlerinden rol yakalar ve bbox ile döner.

    Parameters
    ----------
    pages_scaled : List[Dict] | Dict
        Her sayfa için OCR item listesi. Her item en azından:
        {
          "text": str,
          "bbox": {"x_min": int, "y_min": int, "width": int, "height": int},
          "confidence": float | int | None
        }
    fuzzy_cutoff : int
        Fuzzy skor eşiği (0-100). RapidFuzz yoksa kullanılmaz.
    use_fuzzy : bool
        RapidFuzz mevcutsa partial_ratio ile eşleşmeye izin ver.

    Returns
    -------
    List[Dict]
        [
          {
            "page_index": int,
            "role": str,              # KANONIK (UPPER)
            "matched_text": str,      # OCR ham metin
            "bbox": {"x_min": int, "y_min": int, "width": int, "height": int},
            "confidence": float | None,
            "score": float,           # 0-100
            "matched_variant": str    # normalize edilmiş eşleşen varyant
          },
          ...
        ]
    """
    # --- opsiyonel RapidFuzz ---
    _HAS_RF = False
    if use_fuzzy:
        try:
            from rapidfuzz import fuzz  # type: ignore
            _HAS_RF = True
        except Exception:
            _HAS_RF = False

    import re

    # --- 1) Kanonik roller ve varyantları (geniş tut) ---
    ROLE_ALIASES_DEFAULT = {
        "toplantı başkanı": [
            "toplantı başkanı", "toplanti baskani", "topl bsk", "topl bşk",
            "toplanti bsk", "topl bşkan", "divan başkanı", "divan baskani"
        ],
        "tutanak yazmanı": [
            "tutanak yazmanı", "tutanak yazmani", "yazman", "yazmanı"
        ],
        "bakanlık temsilcisi": [
            "bakanlık temsilcisi", "bakanlik temsilcisi", "ticaret bakanligi temsilcisi",
            "ticaret bakanlığı temsilcisi"
        ],
        "yönetim kurulu başkanı": [
            "yönetim kurulu başkanı", "yonetim kurulu baskani", "yk başkanı", "yk baskani",
            "yk bşk", "yk bsk"
        ],
        "yönetim kurulu üyesi": [
            "yönetim kurulu üyesi", "yonetim kurulu uyesi", "yk üyesi", "yk uyesi",
            "yk üye", "yk uye"
        ],
        "katip": ["katip", "kâtip", "ka tip"],
        "divan başkanı": ["divan başkanı", "divan baskani", "divan bşk", "divan bsk"],
        "oy toplama memuru": [
            "oy toplama memuru", "oy sayım memuru", "oy sayim memuru",
            "oy toplama görevlisi", "oy toplama gorevlisi"
        ],
        "noter": ["noter", "noterce", "noter onaylı", "noter onayli"],
    }

    # --- 2) Normalize yardımcıları ---
    def fold(s: str) -> str:
        s = (s or "").lower()
        s = (s.replace("â", "a").replace("î", "i").replace("û", "u")
                 .replace("ş", "s").replace("ç", "c").replace("ğ", "g")
                 .replace("ö", "o").replace("ü", "u")
                 .replace("ı", "i"))
        s = re.sub(r"[^a-z0-9\s]", " ", s)
        s = re.sub(r"\s+", " ", s).strip()
        return s

    # tüm varyantları normalize + uzunları önce dene
    all_variants = []  # [(variant_norm, canon)]
    for canon, vars_ in ROLE_ALIASES_DEFAULT.items():
        for v in vars_:
            all_variants.append((fold(v), canon))
    all_variants.sort(key=lambda t: len(t[0]), reverse=True)

    # --- 3) Girdi normalizasyonu ---
    def ensure_pages(obj):
        if not obj:
            return []
        # tek sayfa dict'i gelmiş olabilir -> listele
        if isinstance(obj, dict):
            # tek sayfa ise "items" bekler; değilse doğrudan item listesi
            if "items" in obj and isinstance(obj["items"], list):
                return [obj]
            return [{"items": obj if isinstance(obj, list) else []}]
        # zaten liste
        pages = []
        for p in obj:
            if isinstance(p, dict) and "items" in p:
                pages.append(p)
            elif isinstance(p, list):
                pages.append({"items": p})
        return pages

    pages = ensure_pages(pages_scaled)

    # --- 4) Anchor & Ambiguity kuralları ---
    TOPLAM_RE = re.compile(r"\btoplam[a-z]*\b")
    OY_RE = re.compile(r"\boy\b")
    SAYIM_RE = re.compile(r"\bsayi?m\b")  # sayım/sayim
    TOPLANTI_RE = re.compile(r"\btoplanti\w*\b")

    def passes_anchor_rules(canon_norm: str, raw_norm: str) -> bool:
        toplam_alone = bool(TOPLAM_RE.search(raw_norm) and not OY_RE.search(raw_norm))
        if canon_norm == "oy toplama memuru":
            if toplam_alone:
                return False
            return bool(OY_RE.search(raw_norm) or SAYIM_RE.search(raw_norm))
        if canon_norm == "toplanti baskani" or canon_norm == "toplanti başkanı":
            if toplam_alone:
                return False
            return bool(TOPLANTI_RE.search(raw_norm))
        # diğer roller için kural yok
        return True

    # --- 5) Eşleme ---
    out = []
    for pi, page in enumerate(pages):
        for it in page.get("items", []):
            txt = it.get("text") or ""
            if not txt.strip():
                continue
            bbox = it.get("bbox") or {}
            conf = it.get("confidence")

            raw_norm = fold(txt)
            raw_ns = raw_norm.replace(" ", "")

            best = None  # (canon, matched_variant_norm, score)

            # Özel durum: 'yönetim kurulu' sinyali
            if ("yonetimkurulubaskan" in raw_ns) or ("yönetimkurulubaskan" in raw_ns) or ("ykbask" in raw_ns):
                best = ("yönetim kurulu başkanı", "yönetim kurulu başkanı", 100.0)
            else:
                for v_norm, canon in all_variants:
                    hit = False
                    score = 0.0

                    if v_norm in raw_norm:
                        hit = True
                        score = 100.0
                    elif _HAS_RF:
                        score = float(fuzz.partial_ratio(v_norm, raw_norm))
                        hit = score >= float(fuzzy_cutoff)

                    if hit:
                        # anchor kuralları
                        if not passes_anchor_rules(fold(canon), raw_norm):
                            continue
                        # skor iyileştirme: uzun eşleşmeye küçük bonus
                        score += min(5.0, len(v_norm) * 0.2)
                        if (best is None) or (score > best[2]):
                            best = (canon, v_norm, score)

            if best:
                canon, matched_variant, score = best

                # 'yönetim kurulu üyesi' vs 'başkanı' düzeltmesi:
                if canon == "yönetim kurulu üyesi":
                    if ("yönetim kurulu baskan" in raw_norm) or ("yk bask" in raw_norm):
                        canon = "yönetim kurulu başkanı"

                out.append({
                    "page_index": pi,
                    "role": canon.upper(),
                    "matched_text": txt,
                    "bbox": {
                        "x_min": int(bbox.get("x_min", bbox.get("x", 0))),
                        "y_min": int(bbox.get("y_min", bbox.get("y", 0))),
                        "width": int(bbox.get("width", bbox.get("w", 0))),
                        "height": int(bbox.get("height", bbox.get("h", 0))),
                    },
                    "confidence": float(conf) if isinstance(conf, (int, float)) else None,
                    "score": float(score),
                    "matched_variant": fold(matched_variant),
                })

    # --- 6) Aynı bbox için en yüksek skoru tut ---
    def _k(r):
        b = r["bbox"]
        return (r["page_index"], b["x_min"], b["y_min"], b["width"], b["height"])

    best_by_box = {}
    for r in out:
        k = _k(r)
        if k not in best_by_box or r["score"] > best_by_box[k]["score"]:
            best_by_box[k] = r

    return list(best_by_box.values())

