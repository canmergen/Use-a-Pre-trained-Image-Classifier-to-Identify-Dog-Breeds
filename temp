def _extract_company(text: str, lines: List[str]) -> Tuple[Optional[str], Optional[str], Dict]:
    dbg: Dict = {}
    T = unicodedata.normalize("NFKC", text or "")
    if not T.strip():
        return None, None, {"reason":"empty_text"}

    # --- tür desenleri (konum bulma için) ---
    GEN = r"(?:\s*[’'`´\"“”]?\s*(?:NIN|NİN|NUN|NÜN|IN|İN|UN|ÜN))?"
    TYPE_CORE = (
        rf"(ANON[İI]M\s+{_spaced_token('ŞİRKET')}"
        rf"|A\.?\s*Ş|AŞ"
        rf"|LTD\s*\.?\s*ŞT[İI]|LTD\s*\.?\s*ST[İI]"
        rf"|L[İI]M[İI]TED\s+{_spaced_token('ŞİRKET')}){GEN}"
    )
    type_iter = list(re.finditer(TYPE_CORE, T, flags=re.IGNORECASE | re.DOTALL))
    if not type_iter:
        # Metnin tamamından tip çıkar (en azından tür boş kalmasın)
        ctype_any = _map_type_to_canonical(T)
        return None, ctype_any, {"reason":"no_type_anchor"}

    # En sondaki (genelde başlık/ünvan satırına en yakın) eşleşmeyi kullan
    m = type_iter[-1]
    raw_type = m.group(1)
    ctype = _map_type_to_canonical(raw_type) or _map_type_to_canonical(m.group(0))

    # --- geriye doğru pencere ---
    LEFT_WIN = 700
    left = T[max(0, m.start()-LEFT_WIN):m.start()]

    # Pencereyi satırlara böl; boşları at
    cand_lines = [ln.strip(" ,.-:;’'") for ln in left.splitlines() if ln.strip()]
    if not cand_lines:
        return None, ctype, {"reason":"no_left_segment", "type":ctype}

    # Gürültü başlık kelimeleri
    NOISE = {
        "GENEL","KURUL","TOPLANTISI","TOPLANTISINDA","HAZIR","BULUNANLAR","LİSTESİ","ÖRNEĞİ",
        "TARİHLİ","OLAĞAN","OLAĞANÜSTÜ","GÜNDEM","TUTANAK","LİSTE","EK-","SAYILI"
    }
    # Anlamsız kuyruklar
    STOPTAIL = {"AN","VE","TIC","TİC","SAN","VE.","TIC.","TİC.","SAN.","DE","DA","VEYA","İLE"}

    def clean_name(s: str) -> str:
        s = re.sub(r"\s+", " ", s)
        # tür kelimelerini ve varyantlarını ad içinden sök
        s = re.sub(r"\b(ANONIM|ANONİM|LIMITED|LİMİTED|LTD\.?\s*ŞTİ|LTD\.?\s*STİ|A\.?\s*Ş|AŞ|Ş\s*İ\s*R\s*K\s*E\s*T[İI])\b",
                   "", s, flags=re.IGNORECASE)
        toks = [t for t in s.split() if t.upper() not in NOISE]
        while toks and (toks[-1].upper() in STOPTAIL or len(toks[-1]) < 2):
            toks.pop()
        while toks and len(toks[0]) < 2:
            toks.pop(0)
        return " ".join(toks).strip(" ,.-:;’'")

    # Son anlamlı satırı al; yetmezse bir üst satırla birleştir
    name_candidates: List[str] = []
    for i in range(len(cand_lines)-1, -1, -1):
        base = clean_name(cand_lines[i])
        if base:
            name_candidates.append(base)
            # bir üst satır çoğu dokümanda şirket adının ilk kısmıdır
            if i-1 >= 0:
                combo = clean_name(cand_lines[i-1] + " " + cand_lines[i])
                if combo: name_candidates.append(combo)
            break

    # Skorla en iyisini seç
    best = None
    for nm in name_candidates:
        sc = _score_name(nm)
        if best is None or sc > best[0]:
            best = (sc, nm)
    if best and best[0] > 0:
        return _upper_tr(best[1]), ctype, {"reason":"back_window", "best_name":best[1], "type":ctype, "score":best[0]}

    # --- satır bazlı yedek: tür geçen satır ve bir üst satır ---
    T_lines = [ln.strip() for ln in T.splitlines()]
    for k, ln in enumerate(T_lines):
        if re.search(TYPE_CORE, ln, flags=re.IGNORECASE):
            left_inline = ln.split(re.search(TYPE_CORE, ln, flags=re.IGNORECASE).group(0))[0].strip(" ,.-:;’'")
            left_inline = clean_name(left_inline)
            if _score_name(left_inline) > 0:
                return _upper_tr(left_inline), ctype, {"reason":"same_line_left", "type":ctype}
            if k > 0:
                prev = clean_name(T_lines[k-1])
                if _score_name(prev) > 0:
                    return _upper_tr(prev), ctype, {"reason":"prev_line", "type":ctype}

    # Hâlâ yoksa: türü döndür, adı None bırak
    return None, ctype, {"reason":"exhausted", "type":ctype}