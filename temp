from typing import List, Tuple, Optional, Set, Dict

# Tek fonksiyon: role + imza + (opsiyonel) sermaye kutularını nihai hale getirir.
# "Rolü aşağı imza ile birleştirirken union başka bir ROL'ü de içine alıyorsa merge İPTAL" kuralı dahil.

def build_final_boxes_onceall(
    role_blocks: List[Tuple[int,int,int,int]],       # [(x,y,w,h)]
    sig_boxes:   List[Tuple[int,int,int,int]],       # [(x,y,w,h)]
    sermaye_boxes: Optional[List[Tuple[int,int,int,int]]] = None,  # [(x,y,w,h)]
    *,
    include_unpaired_roles: bool = True,             # eşleşmeyen role kutularını da ekle
    include_unpaired_sigs:  bool = True,             # eşleşmeyen imza kutularını da ekle
    dedup_near_px: int = 2,                          # final set için yakın kutu tekilleştirme
    near_px: int = 2,                                # yakınlık (touch) için px toleransı
    require_x_overlap: float = 0.10,                 # role & imza yatay projeksiyon min kesişim oranı
    max_vertical_gap: Optional[int] = None,          # None: sınırsız; aksi halde role.bottom→sig.top azami boşluk
    block_mode: str = "center",                      # "center" | "iou" | "full" (başka rol içerirse merge iptal)
    iou_block_th: float = 0.10                       # block_mode="iou" için eşik
) -> Dict[str, List]:
    """
    Çıktı:
      {
        "final":   List[(x,y,w,h)],    # birleşmiş/tekilleşmiş tüm kutular
        "pairs":   List[(role_idx, sig_idx)],  # eşleşen role-imza indeksleri
        "roles":   List[(x,y,w,h)],    # (nihai sette görünen role kutuları; union olanlar dahil)
        "sigs":    List[(x,y,w,h)],    # (nihai sette görünen imza kutuları; union olanlar dahil)
        "sermaye": List[(x,y,w,h)],    # aynen eklenir (varsa)
      }
    """

    # ---------- helpers (tamamı fonksiyon içinde, self-contained) ----------
    BoxXYWH = Tuple[int,int,int,int]
    BoxLTRB = Tuple[int,int,int,int]

    def to_ltrb(b: BoxXYWH) -> BoxLTRB:
        x,y,w,h = b; return (int(x), int(y), int(x+w), int(y+h))

    def to_xywh(b: BoxLTRB) -> BoxXYWH:
        l,t,r,bm = b; return (int(l), int(t), int(r-l), int(bm-t))

    def union(a: BoxLTRB, b: BoxLTRB) -> BoxLTRB:
        return (min(a[0],b[0]), min(a[1],b[1]), max(a[2],b[2]), max(a[3],b[3]))

    def intersects(a: BoxLTRB, b: BoxLTRB) -> bool:
        return not (a[2] <= b[0] or b[2] <= a[0] or a[3] <= b[1] or b[3] <= a[1])

    def contains(big: BoxLTRB, small: BoxLTRB) -> bool:
        return (big[0] <= small[0]) and (big[1] <= small[1]) and (big[2] >= small[2]) and (big[3] >= small[3])

    def area(bb: BoxLTRB) -> int:
        return max(0, bb[2]-bb[0]) * max(0, bb[3]-bb[1])

    def inter_box(a: BoxLTRB, b: BoxLTRB) -> Optional[BoxLTRB]:
        l = max(a[0], b[0]); t = max(a[1], b[1]); r = min(a[2], b[2]); bm = min(a[3], b[3])
        if r > l and bm > t: return (l,t,r,bm)
        return None

    def iou(a: BoxLTRB, b: BoxLTRB) -> float:
        I = inter_box(a,b)
        if not I: return 0.0
        ai, bi = area(a), area(b)
        ii = area(I)
        return ii / float(ai + bi - ii + 1e-6)

    def x_overlap_ratio(a: BoxLTRB, b: BoxLTRB) -> float:
        # yatay projeksiyon kesişimi / min genişlik
        l = max(a[0], b[0]); r = min(a[2], b[2])
        if r <= l: return 0.0
        inter_w = r - l
        min_w = max(1, min(a[2]-a[0], b[2]-b[0]))
        return float(inter_w) / float(min_w)

    def center_inside(big: BoxLTRB, small: BoxLTRB) -> bool:
        cx = (small[0] + small[2]) // 2
        cy = (small[1] + small[3]) // 2
        return (big[0] <= cx <= big[2]) and (big[1] <= cy <= big[3])

    def is_below(role: BoxLTRB, sig: BoxLTRB) -> bool:
        return sig[1] >= role[3]

    def vgap(role: BoxLTRB, sig: BoxLTRB) -> int:
        return max(0, sig[1] - role[3])

    def touch_or_close(a: BoxLTRB, b: BoxLTRB, px: int) -> bool:
        # yakınlık toleransı ile temas / çakışma kontrolü
        return not (a[2] < b[0]-px or b[2] < a[0]-px or a[3] < b[1]-px or b[3] < a[1]-px)

    def dedup_merge_close(boxes_ltrb: List[BoxLTRB], px: int) -> List[BoxLTRB]:
        if not boxes_ltrb: return []
        boxes = boxes_ltrb[:]
        changed = True
        while changed:
            changed = False
            out: List[BoxLTRB] = []
            used = [False]*len(boxes)
            for i in range(len(boxes)):
                if used[i]: continue
                a = boxes[i]
                for j in range(i+1, len(boxes)):
                    if used[j]: continue
                    b = boxes[j]
                    if touch_or_close(a,b,px):
                        a = union(a,b)
                        used[j] = True
                        changed = True
                out.append(a)
                used[i] = True
            boxes = out
        return boxes

    # ---------- normalize inputs ----------
    roles_l: List[BoxLTRB] = [to_ltrb(b) for b in (role_blocks or [])]
    sigs_l:  List[BoxLTRB] = [to_ltrb(b) for b in (sig_boxes or [])]
    serm_l:  List[BoxLTRB] = [to_ltrb(b) for b in (sermaye_boxes or [])]

    used_roles: Set[int] = set()
    used_sigs:  Set[int] = set()
    pairs: List[Tuple[int,int]] = []

    roles_out_l: List[BoxLTRB] = []
    sigs_out_l:  List[BoxLTRB] = []

    # ---------- 1) ROL → aşağı İMZA ile güvenli birleştirme ----------
    for ri, r in enumerate(roles_l):
        # imza adayları
        cands: List[Tuple[Tuple[float,int,int], int, BoxLTRB, BoxLTRB]] = []
        for si, s in enumerate(sigs_l):
            if si in used_sigs: 
                continue
            if not is_below(r, s): 
                continue
            if max_vertical_gap is not None and vgap(r,s) > max_vertical_gap:
                continue
            xo = x_overlap_ratio(r, s)
            if xo < require_x_overlap:
                continue
            score = (xo, -(vgap(r,s)), -(s[3]-s[1]))  # daha çok xo, daha az gap, büyük kutu
            cands.append((score, si, s, union(r,s)))

        if not cands:
            continue

        cands.sort(reverse=True)
        _, best_si, best_s, best_union = cands[0]

        # ---- BLOK KONTROLÜ: union başka bir ROL'ü de içine alıyor mu? ----
        blocks = False
        for rj, other in enumerate(roles_l):
            if rj == ri: 
                continue
            if block_mode == "center":
                if center_inside(best_union, other):
                    blocks = True; break
            elif block_mode == "iou":
                if iou(best_union, other) > iou_block_th:
                    blocks = True; break
            else:  # "full"
                if contains(best_union, other):
                    blocks = True; break

        if blocks:
            # Bu rol için merge iptal. Rol, ileride tekli olarak eklenecek.
            continue

        # Merge serbest
        roles_out_l.append(best_union)   # union role-sig tek kutu
        used_roles.add(ri)
        used_sigs.add(best_si)
        pairs.append((ri, best_si))

    # ---------- 2) Eşleşmeyenleri (isteğe bağlı) ekle ----------
    if include_unpaired_roles:
        for ri, r in enumerate(roles_l):
            if ri not in used_roles:
                roles_out_l.append(r)

    if include_unpaired_sigs:
        for si, s in enumerate(sigs_l):
            if si not in used_sigs:
                sigs_out_l.append(s)

    # ---------- 3) Sermaye kutularını aynen ekle ----------
    sermaye_out_l = serm_l[:] if serm_l else []

    # ---------- 4) Nihai seti oluştur + tekilleştir ----------
    final_l = roles_out_l + sigs_out_l + sermaye_out_l
    final_l = dedup_merge_close(final_l, dedup_near_px)

    final_xywh = [to_xywh(b) for b in final_l]
    roles_xywh = [to_xywh(b) for b in roles_out_l]
    sigs_xywh  = [to_xywh(b) for b in sigs_out_l]
    serm_xywh  = [to_xywh(b) for b in sermaye_out_l]

    return {
        "final":   final_xywh,
        "pairs":   pairs,
        "roles":   roles_xywh,
        "sigs":    sigs_xywh,
        "sermaye": serm_xywh,
    }