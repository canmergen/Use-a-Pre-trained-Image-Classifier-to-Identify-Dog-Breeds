from typing import Any, Dict, Iterable, List, Tuple
import copy

REQ_KEYS = ("x_min", "y_min", "x_max", "y_max")

def _iter_bbox_containers(obj: Any) -> Iterable[Tuple[Dict[str, Any], str | None]]:
    """
    Yields (container, key) pairs for every bbox found.
    - If bbox is nested like {"bbox": {...}}, yields (container, "bbox")
    - If bbox is flat like {"x_min":..., ...}, yields (container, None)
    Traverses dicts, lists, and tuples.
    """
    if isinstance(obj, dict):
        if "bbox" in obj and isinstance(obj["bbox"], dict) and all(k in obj["bbox"] for k in REQ_KEYS):
            yield obj, "bbox"
        elif all(k in obj for k in REQ_KEYS):
            yield obj, None
        else:
            for v in obj.values():
                yield from _iter_bbox_containers(v)
    elif isinstance(obj, (list, tuple)):
        for v in obj:
            yield from _iter_bbox_containers(v)

def rescale_paddleocr_bboxes_iso(
    pages: List[Any],
    orig_shapes: List[Tuple[int, int]],   # [(H, W), ...] for final_lower_imgs
    small_max: int = 1024,
    in_place: bool = False,
    clamp: bool = True,
) -> List[Any]:
    """
    For each page i:
      - compute s = max(H, W) / small_max
      - multiply every bbox coord by s (x_min, x_max, y_min, y_max)
      - optionally clamp to image bounds and refresh width/height
    Only bbox values are changed. Structure and non-bbox fields stay intact.
    """
    if not in_place:
        pages = copy.deepcopy(pages)

    assert len(pages) == len(orig_shapes), "pages and orig_shapes length mismatch"

    for i, (H, W) in enumerate(orig_shapes):
        s = max(H, W) / float(small_max)

        for container, key in _iter_bbox_containers(pages[i]):
            b = container["bbox"] if key == "bbox" else container

            # scale
            x_min = int(round(b["x_min"] * s))
            y_min = int(round(b["y_min"] * s))
            x_max = int(round(b["x_max"] * s))
            y_max = int(round(b["y_max"] * s))

            if clamp:
                # clamp to image bounds and ensure min<=max
                x_min = max(0, min(x_min, W - 1))
                y_min = max(0, min(y_min, H - 1))
                x_max = max(x_min, min(x_max, W - 1))
                y_max = max(y_min, min(y_max, H - 1))

            b["x_min"], b["y_min"], b["x_max"], b["y_max"] = x_min, y_min, x_max, y_max
            b["width"]  = x_max - x_min
            b["height"] = y_max - y_min

    return pages

# --- helper to visualize on final_lower_imgs (OpenCV) ---
def visualize_boxes(img, regions, thickness: int = 3):
    import cv2
    vis = img.copy()
    for container, key in _iter_bbox_containers(regions):
        b = container["bbox"] if key == "bbox" else container
        cv2.rectangle(vis, (b["x_min"], b["y_min"]), (b["x_max"], b["y_max"]), (0, 255, 0), thickness)
    return vis

# 1) Make per-page shapes from original final_lower_imgs
orig_shapes = [ (img.shape[0], img.shape[1]) for img in final_lower_imgs ]  # (H, W)

# 2) Ensure 'pages' is a list-of-pages structure
#    If your OCR is already list-of-pages, use it directly. If it's a single page, wrap it.
pages = paddleocr_regions_aligned if isinstance(paddleocr_regions_aligned, list) else [paddleocr_regions_aligned]

# 3) Rescale assuming the SMALL side was derived from max_dim=1024
pages_scaled = rescale_paddleocr_bboxes_iso(pages, orig_shapes, small_max=1024, in_place=False, clamp=True)

# 4) (Optional) visualize per page
#    Example for page 0:
overlay0 = visualize_boxes(final_lower_imgs[0], pages_scaled[0])
# show with matplotlib
import matplotlib.pyplot as plt
plt.imshow(overlay0[..., ::-1])  # if img is BGR; remove this slice if it's already RGB
plt.axis('off')
plt.show()