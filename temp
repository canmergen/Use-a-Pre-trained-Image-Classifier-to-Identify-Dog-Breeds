def fix_bboxes_inplace(paddle_ocr_regions_aligned):
    """
    In-place: region['bbox'] -> {'x': int, 'y': int, 'w': int, 'h': int, 'x2': int, 'y2': int}
    Accepts polygon-style (x1..x4/y1..y4), min-max, left-top-wh, or list-of-points dicts.
    """

    def _num(v):
        # cast strings like "141", "141.0", "141px" safely to int
        if isinstance(v, (int, float)):
            return int(round(float(v)))
        if isinstance(v, str):
            s = "".join(ch for ch in v if (ch.isdigit() or ch in ".-"))
            if s in ("", "-", ".", "-."):
                return 0
            return int(round(float(s)))
        return 0

    def _rect_from_bbox(b):
        # Case A: polygon x1..x4 / y1..y4
        xs = [b[k] for k in b.keys() if k.lower().startswith("x")]
        ys = [b[k] for k in b.keys() if k.lower().startswith("y")]
        if len(xs) >= 2 and len(ys) >= 2:
            xs = [_num(v) for v in xs]
            ys = [_num(v) for v in ys]
            x_min, x_max = min(xs), max(xs)
            y_min, y_max = min(ys), max(ys)
            return x_min, y_min, x_max - x_min, y_max - y_min

        # Case B: explicit min/max
        keys = {k.lower(): k for k in b.keys()}
        if {"x_min","y_min","x_max","y_max"}.issubset(keys):
            x_min = _num(b[keys["x_min"]]); y_min = _num(b[keys["y_min"]])
            x_max = _num(b[keys["x_max"]]); y_max = _num(b[keys["y_max"]])
            return x_min, y_min, x_max - x_min, y_max - y_min

        # Case C: left/top/width/height
        if {"left","top","width","height"}.issubset(keys):
            x = _num(b[keys["left"]]); y = _num(b[keys["top"]])
            w = _num(b[keys["width"]]); h = _num(b[keys["height"]])
            return x, y, w, h

        # Case D: list of points under 'points'/'poly'
        for name in ("points", "poly", "vertices"):
            if name in b and isinstance(b[name], (list, tuple)) and b[name]:
                pts = b[name]
                # pts like [(x,y), ...] or [{'x':..,'y':..}, ...]
                xs, ys = [], []
                for p in pts:
                    if isinstance(p, (list, tuple)) and len(p) >= 2:
                        xs.append(_num(p[0])); ys.append(_num(p[1]))
                    elif isinstance(p, dict):
                        xs.append(_num(p.get("x", 0))); ys.append(_num(p.get("y", 0)))
                if xs and ys:
                    x_min, x_max = min(xs), max(xs)
                    y_min, y_max = min(ys), max(ys)
                    return x_min, y_min, x_max - x_min, y_max - y_min

        # Fallback: nothing usable
        return 0, 0, 0, 0

    for region in paddle_ocr_regions_aligned:
        b = region.get("bbox", None)
        if isinstance(b, dict):
            x, y, w, h = _rect_from_bbox(b)
            region["bbox"] = {"x": x, "y": y, "w": w, "h": h, "x2": x + w, "y2": y + h}

    return paddle_ocr_regions_aligned

paddle_ocr_regions_aligned = fix_bboxes_inplace(paddle_ocr_regions_aligned)
# ArtÄ±k region['bbox'] -> {'x','y','w','h','x2','y2'} standardÄ±nda.