def _find_company(
    lines: List[str],
    *,
    fuzzy_type_thresh: float = 0.82,
    fuzzy_join_lines: bool = True,
) -> Tuple[Optional[str], Optional[str]]:
    """
    Satır bazlı OCR çıktısında şirket tipini (A.Ş., LTD. ŞTİ., ANONİM ŞİRKETİ, vb.)
    ararken; tek satır + (prev+curr), (curr+next), (prev+curr+next) kombinasyonlarında
    tarar. Tipin SOLUNU şirket adı olarak alır. Sol taraf çok kısaysa veya
    'AN/VE/TİC/SAN' ile bitiyorsa otomatik genişletir.
    """

    # ---- yardımcılar ----
    def _quality_score(name: str) -> float:
        if not name: return 0.0
        s = unicodedata.normalize("NFKC", name)
        letters = sum(ch.isalpha() for ch in s)
        digits  = sum(ch.isdigit() for ch in s)
        if letters < 3 or letters <= digits:
            return 0.0
        toks = [t for t in re.split(r"\s+", s.strip()) if t]
        return 0.6*min(len(s)/80.0, 1.0) + 0.3*min(len(toks)/8.0, 1.0) + 0.1*(letters/(letters+digits+1e-6))

    def _map_type_to_label(type_text: str) -> Optional[str]:
        up = _normalize_line(type_text)
        for creg, label in TYPE_REGEX:
            if creg.search(up):
                return label
        return None

    def _fix_breaks(t: str) -> str:
        # "S AN"->"SAN", "T I C"->"TIC", fazla boşluk ve noktalama boşluklarını düzelt
        t = re.sub(r"\bS\s+AN\b", "SAN", t, flags=re.IGNORECASE)
        t = re.sub(r"\bT\s*İ?\s*C\b", "TİC", t, flags=re.IGNORECASE)
        t = re.sub(r"\s+([.,:;])", r"\1", t)
        t = re.sub(r"\s+", " ", t)
        return t.strip()

    BAD_ENDS = {"AN","VE","TIC","TİC","SAN","VE.", "VE,", "TIC.", "TİC.", "SAN."}

    # TYPE_ANY: eldeki tip regex'lerinin birleşimi (en son eşleşmeyi almak için finditer kullanacağız)
    TYPE_ANY = re.compile("|".join(p.pattern for p, _ in TYPE_REGEX), re.IGNORECASE)

    src = [s for s in (lines or []) if isinstance(s, str)]
    src = [s.strip() for s in src if s and not re.fullmatch(r"[^\wÇĞİÖŞÜçğıöşü]+|[A-Za-zÇĞİÖŞÜçğıöşü]", s)]
    if not src:
        return None, None

    # Aday kombinasyonları: tek satır, prev+curr, curr+next, prev+curr+next
    def _concat(parts: List[str]) -> str:
        return _fix_breaks(" ".join([p for p in parts if p]))

    candidates: List[Tuple[str, int, Tuple[int, ...]]] = []
    n = len(src)
    for i in range(n):
        candidates.append( ( _concat([src[i]]), i, (i,) ) )
        if i > 0:
            candidates.append( ( _concat([src[i-1], src[i]]), i, (i-1,i) ) )
        if i+1 < n:
            candidates.append( ( _concat([src[i], src[i+1]]), i, (i,i+1) ) )
        if 0 < i < n-1:
            candidates.append( ( _concat([src[i-1], src[i], src[i+1]]), i, (i-1,i,i+1) ) )

    best: Optional[Tuple[float, str, str]] = None  # (score, name, type_label)

    for text, i, span in candidates:
        # tipin SON eşleşmesi (genelde isimden sonra gelir)
        last_m = None
        for m in TYPE_ANY.finditer(text):
            last_m = m
        if not last_m:
            continue

        left = text[:last_m.start()].strip()
        # çok kısaysa: bir satır daha sola genişlet (mümkünse)
        if len(left) < 8 or re.sub(r".*\s", "", left).upper() in BAD_ENDS:
            # prev satır varsa ekle
            prev_idx = span[0]-1
            if prev_idx >= 0:
                left = _concat([src[prev_idx], left])

        # hâlâ kötü son ise bir kelime daha eklemeyi dene (çok agresif olmayalım)
        tail = re.sub(r".*\s", "", left).upper()
        if tail in BAD_ENDS and span[0]-2 >= 0:
            left = _concat([src[span[0]-2], left])

        q = _quality_score(left)
        if q <= 0:
            continue

        type_label = _map_type_to_label(last_m.group(0)) or None
        score = q + 0.05*min(len(left)/60.0, 1.0)  # biraz da uzunluk ek puanı

        if (best is None) or (score > best[0]):
            best = (score, left, type_label)

    if best:
        return best[1], best[2]

    # Fallback: eski mantık (satır bazlı REGEX/FUZZY)
    # --- REGEX ---
    best_regex = None
    for i, raw in enumerate(src):
        norm = _normalize_line(raw)
        for creg, label in TYPE_REGEX:
            m = creg.search(norm)
            if not m:
                continue
            cand = raw.strip() if m.start() == 0 else raw[:m.start()].strip()
            q = _quality_score(cand)
            if q > 0 and ((best_regex is None) or (q > best_regex[0]) or (q == best_regex[0] and i < best_regex[1])):
                best_regex = (q, i, str(cand), label)
    if best_regex:
        return best_regex[2], best_regex[3]

    # --- FUZZY ---
    best_fuzzy = None
    for i, raw in enumerate(src):
        norm = _normalize_line(raw)
        best_label, best_score = None, 0.0
        for canonical, variants in CANON_TYPES.items():
            sc = max(_fuzzy_ratio(v, norm) for v in variants)
            if sc > best_score:
                best_score, best_label = sc, canonical
        if best_label and best_score >= fuzzy_type_thresh:
            cand = _fix_breaks(raw.strip())
            q = _quality_score(cand)
            if q > 0:
                rank = 0.7*best_score + 0.3*min(q, 1.0)
                if (best_fuzzy is None) or (rank > best_fuzzy[0]) or (rank == best_fuzzy[0] and i < best_fuzzy[1]):
                    best_fuzzy = (rank, i, str(cand), best_label)
    if best_fuzzy:
        return best_fuzzy[2], best_fuzzy[3]

    if fuzzy_join_lines and src:
        joined_raw = _concat(src[:3]) if len(src) >= 3 else _concat(src)
        joined_norm = _normalize_line(joined_raw)
        best_label, best_score = None, 0.0
        for canonical, variants in CANON_TYPES.items():
            sc = max(_fuzzy_ratio(v, joined_norm) for v in variants)
            if sc > best_score:
                best_score, best_label = sc, canonical
        if best_label and best_score >= fuzzy_type_thresh and _quality_score(joined_raw) > 0:
            return joined_raw, best_label

    return None, None