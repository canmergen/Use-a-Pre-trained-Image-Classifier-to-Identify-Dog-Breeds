import cv2
import numpy as np
from typing import List, Dict, Any, Tuple, Optional

def extract_tables_bw(
    pages: List[np.ndarray],
    threshold: int = 225,
    min_area_ratio: float = 0.005,   # tablo en az %0.5 alan kaplasın
    margin_px: int = 6,              # kırpıma küçük pay
    debug: bool = False
) -> List[Dict[str, Any]]:
    """
    Girdi:
      - pages: [np.ndarray], her biri (H,W,3) veya (H,W), dtype=uint8
    Çıktı (list of dict):
      {
        'image_index': int,
        'status': 'ok'|'fallback'|'error',
        'bbox': (x0,y0,x1,y1),            # binarize üzerinde kırpım
        'table_bw': np.ndarray(Hc,Wc),    # sadece siyah-beyaz tablo
        'debug': { ... } | None
      }
    Notlar:
      - Eşik: gray >= 225 → 255 (beyaz), <225 → 0 (siyah)
      - Eğri/bombeli çizgiler morfolojik kapanış ile tek bileşene bağlanır.
      - Tespit yoksa tüm sayfa binarize edilip döndürülür ('fallback').
    """
    results: List[Dict[str, Any]] = []

    for idx, img in enumerate(pages):
        try:
            # --- 1) GRAY'e çevir ---
            if img.ndim == 2:
                gray = img.copy()
            elif img.ndim == 3 and img.shape[2] == 3:
                # BGR/RGB farkını önemsemiyoruz; her iki durumda da griye dönüşüm makul
                try:
                    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
                except Exception:
                    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
            else:
                raise ValueError("Unsupported image shape")

            H, W = gray.shape[:2]

            # --- 2) Net eşik: 225 ve üstü BEYAZ, altı SİYAH ---
            # THRESH_BINARY: src > thresh → maxVal
            _, bw = cv2.threshold(gray, threshold, 255, cv2.THRESH_BINARY)

            # --- 3) Tablo maskesi: siyah içeriği birleştir ---
            # Siyah içerik = 255 - bw (yani yazı/çizgiler = beyaz piksel)
            ink = cv2.subtract(255, bw)

            # Gürültüyü hafifçe bastır
            ink = cv2.medianBlur(ink, 3)

            # Kernel boyutlarını resme göre ölçekle (eğri/bozuk çizgileri bile bağlamak için geniş tut)
            kx = max(15, W // 60)   # yatay yönde birleştirme
            ky = max(15, H // 60)   # dikey  yönde birleştirme
            ker = cv2.getStructuringElement(cv2.MORPH_RECT, (kx, ky))

            # Kapanış: boşlukları kapat, parçaları tek kütle yap
            mask = cv2.morphologyEx(ink, cv2.MORPH_CLOSE, ker, iterations=1)

            # Kenarları biraz kalınlaştır (büyük tek bileşen istiyoruz)
            ker2 = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
            mask = cv2.dilate(mask, ker2, iterations=1)

            # --- 4) En büyük dış konturu seç ---
            cnts = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-2]

            table_bbox: Optional[Tuple[int,int,int,int]] = None
            status = "fallback"

            if cnts:
                # Alan filtresi
                area_img = H * W
                cand = []
                for c in cnts:
                    a = cv2.contourArea(c)
                    if a >= min_area_ratio * area_img:
                        cand.append((a, c))

                if cand:
                    cand.sort(key=lambda z: z[0], reverse=True)
                    best = cand[0][1]
                    x, y, w, h = cv2.boundingRect(best)

                    # Küçük güvenlik marjı
                    x0 = max(0, x - margin_px)
                    y0 = max(0, y - margin_px)
                    x1 = min(W, x + w + margin_px)
                    y1 = min(H, y + h + margin_px)
                    table_bbox = (x0, y0, x1, y1)
                    status = "ok"

            # --- 5) Kırpımı üret ---
            if table_bbox is None:
                # Tespit yoksa tüm sayfa
                x0, y0, x1, y1 = 0, 0, W, H
                table_bbox = (x0, y0, x1, y1)
                status = "fallback"

            table_bw = bw[table_bbox[1]:table_bbox[3], table_bbox[0]:table_bbox[2]].copy()

            # Çıktı
            out = {
                "image_index": idx,
                "status": status,
                "bbox": table_bbox,
                "table_bw": table_bw,
                "debug": None
            }

            if debug:
                dbg = {
                    "bw": bw,           # tam sayfa binarize
                    "ink": ink,         # siyah içerik maskesi (beyaz=ink)
                    "mask": mask,       # kapanış sonrası
                    "kernel": (kx, ky),
                }
                out["debug"] = dbg

            results.append(out)

        except Exception as e:
            results.append({
                "image_index": idx,
                "status": "error",
                "error": str(e),
                "bbox": None,
                "table_bw": None,
                "debug": None
            })

    return results

# pages = [np_img0, np_img1, ...]  # (H,W,[3]) uint8
res = extract_tables_bw(pages, threshold=225, min_area_ratio=0.005, margin_px=6, debug=False)

# İlk başarılı tablo kırpımı:
for r in res:
    if r["status"] in ("ok", "fallback") and r["table_bw"] is not None:
        table = r["table_bw"]  # sadece siyah(0)/beyaz(255)
        # örn. kaydet: cv2.imwrite(f"table_{r['image_index']}.png", table)