import cv2
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, Optional

# ---------------------------------------------------------
# 1) Çizgi kopukluklarını kapatan fonksiyon
# ---------------------------------------------------------
def close_line_gaps(binary: np.ndarray,
                    horiz_scale: int = 40,
                    vert_scale: int = 40,
                    close_iters: int = 1,
                    dilate_iters: int = 1
                    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    binary: 0-255 tek kanallı görüntü (tablo bölgesi).
            Çizgiler siyah, arka plan beyaz varsayılıyor.
    Çıktı:
        grid_lines      : yatay+dikey çizgi maskesi
        horiz_lines     : yatay çizgi maskesi
        vert_lines      : dikey çizgi maskesi
    """
    if len(binary.shape) == 3:
        gray = cv2.cvtColor(binary, cv2.COLOR_BGR2GRAY)
    else:
        gray = binary.copy()

    # Otsu ile yeniden binarize
    _, bw = cv2.threshold(gray, 0, 255,
                          cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # Arka plan beyaz değilse ters çevir
    if np.mean(bw) < 127:
        bw = 255 - bw

    # Çizgileri 255, arka planı 0 yap
    inv = 255 - bw

    H, W = inv.shape

    # Dinamik kernel boyları
    kh = max(10, W // horiz_scale)
    kv = max(10, H // vert_scale)

    horiz_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (kh, 1))
    vert_kernel  = cv2.getStructuringElement(cv2.MORPH_RECT, (1, kv))

    # Yatay çizgiler
    horiz = cv2.erode(inv, horiz_kernel, iterations=1)
    horiz = cv2.dilate(horiz, horiz_kernel, iterations=1)
    horiz = cv2.morphologyEx(horiz, cv2.MORPH_CLOSE, horiz_kernel, iterations=close_iters)
    horiz = cv2.dilate(horiz, horiz_kernel, iterations=dilate_iters)

    # Dikey çizgiler
    vert = cv2.erode(inv, vert_kernel, iterations=1)
    vert = cv2.dilate(vert, vert_kernel, iterations=1)
    vert = cv2.morphologyEx(vert, cv2.MORPH_CLOSE, vert_kernel, iterations=close_iters)
    vert = cv2.dilate(vert, vert_kernel, iterations=dilate_iters)

    # Birleşik grid
    grid = cv2.bitwise_or(horiz, vert)

    grid = np.clip(grid, 0, 255).astype(np.uint8)
    horiz = np.clip(horiz, 0, 255).astype(np.uint8)
    vert  = np.clip(vert, 0, 255).astype(np.uint8)

    return grid, horiz, vert


# ---------------------------------------------------------
# 2) Eski add_borders sende zaten varsa tekrar tanımlaman sorun değil
# ---------------------------------------------------------
def add_borders(img: np.ndarray, border: int = 2) -> np.ndarray:
    img = img.copy()
    img[:border, :] = 255
    img[-border:, :] = 255
    img[:, :border] = 255
    img[:, -border:] = 255
    return img


# ---------------------------------------------------------
# 3) Güncellenmiş return_binary_mask
#    (extract_axes_from_mask ve merge_dense_axes SENDEKİ gibi kalsın)
# ---------------------------------------------------------
def return_binary_mask(
    table: np.ndarray,
    ver_kernels: Optional[Tuple[int, int]] = None,
    hor_kernels: Optional[Tuple[int, int]] = None,
    hor_erode_iter: int = 2,
    ver_erode_iter: int = 2,
    handle_inv: bool = True,
    min_cov_h: float = 0.4,
    min_cov_v: float = 0.4,
    min_gap_frac: float = 0.015,
    v_proj_top_frac: float = 0.2,
    compact_ratio: float = 0.2,
    more_debug: bool = False,
    debug: bool = False,
) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """
    Çıktı:
        binary_lines     : yatay + dikey çizgi maskesi
        binary_horizontal: yatay çizgi maskesi
        binary_vertical  : dikey çizgi maskesi
        rows_y           : grid yatay eksenleri (üst+ara+alt)
        cols_x           : grid dikey eksenleri (sol+ara+sağ)
    """

    # ---- 1) Gri + threshold + border ----
    if table.ndim == 3:
        gray = cv2.cvtColor(table, cv2.COLOR_BGR2GRAY)
    else:
        gray = table.copy()

    _, binary = cv2.threshold(gray, 0, 255,
                              cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    binary = add_borders(binary)
    H, W = binary.shape

    # ---- 2) Çizgi kopukluklarını kapat ----
    binary_lines, binary_horizontal, binary_vertical = close_line_gaps(
        binary,
        horiz_scale=40,
        vert_scale=40,
        close_iters=1,
        dilate_iters=1,
    )

    # ---- 3) Sağ taraftaki ters kolon / imza anomalisi fix (mevcut logic) ----
    if handle_inv:
        inv_x_range = 0
        for x in range(W):
            if np.mean(binary_vertical[:, x]) == 0:
                inv_x_range = x
            if inv_x_range >= W * 0.15:
                binary_vertical[:, max(0, x - inv_x_range - 2):x] = 0
                break

    # ---- 4) Grid eksenleri (satır + sütun) ----
    min_gap_h = max(3, int(min_gap_frac * H))
    min_gap_v = max(3, int(min_gap_frac * W))

    # Satırlar
    rows_y = extract_axes_from_mask(
        mask=binary_horizontal,
        axis="h",
        min_coverage=min_cov_h,
        min_gap_px=min_gap_h,
        title="Row projection",
        dbg=more_debug,
    )

    # Sütunlar: üst bandı kullan (imza etkisini azaltmak için)
    top_h = int(H * v_proj_top_frac)
    vert_for_proj = binary_vertical[:top_h, :]

    cols_x_raw = extract_axes_from_mask(
        mask=vert_for_proj,
        axis="v",
        min_coverage=min_cov_v,
        min_gap_px=min_gap_v,
        title="Column projection (top band)",
        dbg=more_debug,
    )

    cols_x = merge_dense_axes(
        axes=cols_x_raw,
        ratio=compact_ratio,
        full_length=W,
    )

    # ---- 5) Debug görselleştirme ----
    if debug:
        print(f"rows_y (n={len(rows_y)}):", rows_y)
        print(f"cols_x_raw (n={len(cols_x_raw)}):", cols_x_raw)
        print(f"cols_x_merged (n={len(cols_x)}):", cols_x)

        bg = cv2.normalize(gray, None, 200, 255, cv2.NORM_MINMAX)
        vis = cv2.cvtColor(bg, cv2.COLOR_GRAY2BGR)

        # Satır çizgileri
        for y in rows_y:
            cv2.line(vis, (0, y), (W - 1, y), (0, 255, 0), 2)

        # Sütun çizgileri
        for x in cols_x:
            cv2.line(vis, (x, 0), (x, H - 1), (255, 0, 0), 2)

        plt.figure(figsize=(8, 8))
        plt.title("Detected grid axes (over original)")
        plt.imshow(vis)
        plt.axis("off")
        plt.tight_layout()
        plt.show()

    return binary_lines, binary_horizontal, binary_vertical, rows_y, cols_x


# ---------------------------------------------------------
# 4) Tüm tablolar için çalışma + closed_line_masks
# ---------------------------------------------------------
all_bin_lines = []
all_hmask = []
all_vmask = []
all_rows_y = []
all_cols_x = []
grid_info = []
closed_line_masks = []  # özellikle istediğin liste

for i, tbl in enumerate(binarized_tables):
    bin_lines, hmask, vmask, rows_y, cols_x = return_binary_mask(
        tbl,
        debug=True,          # istersen False yaparsın
        more_debug=False,
    )

    n_rows = len(rows_y) - 1
    n_cols = len(cols_x) - 1

    print(f"Page {i}: rows={n_rows}, cols={n_cols}")

    all_bin_lines.append(bin_lines)
    all_hmask.append(hmask)
    all_vmask.append(vmask)
    all_rows_y.append(rows_y)
    all_cols_x.append(cols_x)
    grid_info.append({
        "page_index": i,
        "rows_y": rows_y,
        "cols_x": cols_x,
        "n_rows": n_rows,
        "n_cols": n_cols,
    })

    # Kapalı çizgi maskelerini ayrıca sakla
    closed_line_masks.append(bin_lines)





import cv2
import numpy as np

def close_table_line_gaps(table_bin: np.ndarray,
                          horiz_scale: int = 40,
                          vert_scale: int = 40,
                          close_iters: int = 1,
                          dilate_iters: int = 1) -> np.ndarray:
    """
    table_bin: 0-255, tek kanallı, sadece tablo görüntüsü (binarize edilmiş).
               Çizgiler ve yazılar siyah, arka plan beyaz varsayılıyor.

    Çıktı: çizgi kopuklukları kapatılmış, sadece grid maskesi (0/255).
    """

    # Gri hale getir ve tekrar binarize et (garanti olsun)
    if len(table_bin.shape) == 3:
        gray = cv2.cvtColor(table_bin, cv2.COLOR_BGR2GRAY)
    else:
        gray = table_bin.copy()

    _, bw = cv2.threshold(gray, 0, 255,
                          cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # Arka plan beyaz, çizgiler siyah mı kontrol et; değilse invert et
    if np.mean(bw) < 127:
        bw = 255 - bw

    # Çizgileri 1, arka plan 0 olacak şekilde invert (morfoloji için daha rahat)
    inv = 255 - bw

    h, w = inv.shape

    # Kernel boylarını imaj boyutuna göre dinamik ayarla
    # (tablonun genişliğinin /40'ı kadar bir uzunluk genelde iyi çalışıyor)
    horiz_kernel_len = max(10, w // horiz_scale)
    vert_kernel_len  = max(10, h // vert_scale)

    horiz_kernel = cv2.getStructuringElement(
        cv2.MORPH_RECT, (horiz_kernel_len, 1)
    )
    vert_kernel = cv2.getStructuringElement(
        cv2.MORPH_RECT, (1, vert_kernel_len)
    )

    # 1) Yatay çizgi maskesi çıkar
    horiz_lines = cv2.erode(inv, horiz_kernel, iterations=1)
    horiz_lines = cv2.dilate(horiz_lines, horiz_kernel, iterations=1)

    # Kopuklukları kapat (closing)
    horiz_lines = cv2.morphologyEx(
        horiz_lines, cv2.MORPH_CLOSE, horiz_kernel, iterations=close_iters
    )
    horiz_lines = cv2.dilate(horiz_lines, horiz_kernel, iterations=dilate_iters)

    # 2) Dikey çizgi maskesi çıkar
    vert_lines = cv2.erode(inv, vert_kernel, iterations=1)
    vert_lines = cv2.dilate(vert_lines, vert_kernel, iterations=1)

    vert_lines = cv2.morphologyEx(
        vert_lines, cv2.MORPH_CLOSE, vert_kernel, iterations=close_iters
    )
    vert_lines = cv2.dilate(vert_lines, vert_kernel, iterations=dilate_iters)

    # 3) Grid maskesi: yatay + dikey
    grid = cv2.bitwise_or(horiz_lines, vert_lines)

    # 4) 0-255'e çevir (mask: çizgi 255, arka plan 0)
    grid = np.clip(grid, 0, 255).astype(np.uint8)

    return grid

closed_line_masks = []
for img in binarized_tables:
    grid_mask = close_table_line_gaps(img,
                                      horiz_scale=40,
                                      vert_scale=40,
                                      close_iters=1,
                                      dilate_iters=1)
    closed_line_masks.append(grid_mask)