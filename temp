def build_final_boxes_onecall(
    role_blocks,          # List[(x,y,w,h)]
    sig_boxes,            # List[(x,y,w,h)]
    sermaye_boxes=None,   # Optional[List[(x,y,w,h)]]
    *,
    include_unpaired_roles=True,
    include_unpaired_sigs=True,
    dedup_iou=0.90,       # final set için katı tekilleştirme
    near_px=3,            # ~yakın kutuları da tekilleştir (opsiyonel)
    require_x_overlap=True # "aynı boylam" tanımı: yatay projeksiyonlar kesişsin
):
    """
    Çıktı:
      {
        "final":   List[(x,y,w,h)]   # birleşmiş+tekilleşmiş tüm kutular
        "pairs":   List[(role_idx, sig_idx)]
        "roles":   List[(x,y,w,h)]
        "sigs":    List[(x,y,w,h)]
        "sermaye": List[(x,y,w,h)]
      }
    """
    # ---- import & type hints (fonksiyon içi, self-contained) ----
    from typing import List, Tuple, Optional, Set
    import math

    BOXXYWH = Tuple[int,int,int,int]
    BOXLTRB = Tuple[int,int,int,int]

    # -------------- helpers (tamamı fonksiyon içinde) --------------
    def to_ltrb(b: BOXXYWH) -> BOXLTRB:
        x,y,w,h = b
        return (int(x), int(y), int(x+w), int(y+h))

    def to_xywh(b: BOXLTRB) -> BOXXYWH:
        l,t,r,bm = b
        return (int(l), int(t), max(0, int(r-l)), max(0, int(bm-t)))

    def union(a: BOXLTRB, b: BOXLTRB) -> BOXLTRB:
        return (min(a[0],b[0]), min(a[1],b[1]), max(a[2],b[2]), max(a[3],b[3]))

    def expand(bb: BOXLTRB, pad: int) -> BOXLTRB:
        l,t,r,bm = bb
        return (l-pad, t-pad, r+pad, bm+pad)

    def intersects(a: BOXLTRB, b: BOXLTRB) -> bool:
        return not (a[2] <= b[0] or b[2] <= a[0] or a[3] <= b[1] or b[3] <= a[1])

    def contains(a: BOXLTRB, b: BOXLTRB) -> bool:
        # a b'yi tamamen kapsıyor mu?
        return (a[0] <= b[0]) and (a[1] <= b[1]) and (a[2] >= b[2]) and (a[3] >= b[3])

    def area(bb: BOXLTRB) -> int:
        l,t,r,bm = bb
        return max(0, r-l) * max(0, bm-t)

    def iou(a: BOXLTRB, b: BOXLTRB) -> float:
        if not intersects(a,b):
            return 0.0
        l = max(a[0], b[0]); t = max(a[1], b[1])
        r = min(a[2], b[2]); bm = min(a[3], b[3])
        inter = max(0, r-l) * max(0, bm-t)
        return inter / float(area(a) + area(b) - inter + 1e-6)

    def horiz_overlap_ratio(a: BOXLTRB, b: BOXLTRB) -> float:
        # yatay eksende projeksiyon kesişiminin min(genişlik) oranı
        l = max(a[0], b[0]); r = min(a[2], b[2])
        inter_w = max(0, r-l)
        min_w = max(1, min(a[2]-a[0], b[2]-b[0]))
        return inter_w / float(min_w)

    def dedup_merge_close(boxes_xywh: List[BOXXYWH]) -> List[BOXXYWH]:
        """IoU >= dedup_iou olanları veya near_px ile temas edenleri tekilleştirir."""
        rects = [to_ltrb(b) for b in boxes_xywh]
        changed = True
        while changed:
            changed = False
            rects.sort(key=lambda r: (r[0], r[1], r[2]-r[0], r[3]-r[1]))
            used = [False]*len(rects)
            merged: List[BOXLTRB] = []
            for i in range(len(rects)):
                if used[i]: continue
                cur = rects[i]; used[i] = True
                j = 0
                while j < len(rects):
                    if not used[j]:
                        a = expand(cur, near_px)
                        b = expand(rects[j], near_px)
                        if intersects(a,b) or iou(cur, rects[j]) >= dedup_iou:
                            cur = union(cur, rects[j])
                            used[j] = True
                            changed = True
                            j = 0
                            continue
                    j += 1
                merged.append(cur)
            rects = merged
        return [to_xywh(r) for r in rects]

    # ---------------- normalize inputs ----------------
    roles_ltrb   = [to_ltrb(b) for b in (role_blocks or [])]
    sigs_ltrb    = [to_ltrb(b) for b in (sig_boxes or [])]
    sermaye_ltrb = [to_ltrb(b) for b in (sermaye_boxes or [])]

    used_roles: Set[int] = set()
    used_sigs:  Set[int] = set()
    pairs: List[Tuple[int,int]] = []

    # ---------------- pairing (rol + imza) ----------------
    # KURAL (senin talebin):
    # 1) İmza rol kutusunun İÇİNDE ise zaten birleşik sayılır (ek kural yok).
    # 2) İmza rolün ALTINDA ise (sig.top >= role.bottom) VE
    #    "Aynı boylam": yatay projeksiyonlar kesişiyorsa -> MESAFE ÖNEMSİZ, MUTLAKA BİRLEŞ.
    # Çoklu imza varsa deterministik olmak için en çok yatay-örtüşen (bağıl) ve sonra en küçük dikey boşluk seçilir.

    for ri, rb in enumerate(roles_ltrb):
        if ri in used_roles:
            continue
        rl,rt,rr,rbm = rb

        # 0) Eğer herhangi bir imza role TAMAMEN içerideyse onu tercih et (doğal birleşik durum)
        inside_best = None
        for si, sb in enumerate(sigs_ltrb):
            if si in used_sigs: 
                continue
            if contains(rb, sb):
                # içeridekilerden en büyük alanı seçelim
                score = area(sb)
                if (inside_best is None) or (score > inside_best[0]):
                    inside_best = (score, si)
        if inside_best is not None:
            si = inside_best[1]
            pairs.append((ri, si))
            used_roles.add(ri)
            used_sigs.add(si)
            continue

        # 1) Role ALTTA ve "aynı boylam" (yatay projeksiyon kesişimi > 0) olan tüm imzaları aday yap
        cands = []
        for si, sb in enumerate(sigs_ltrb):
            if si in used_sigs: 
                continue
            sl,st,sr,sb2 = sb
            # altta mı?
            if st < rbm:
                continue
            # aynı boylam mı?
            if require_x_overlap:
                xo = horiz_overlap_ratio(rb, sb)
                if xo <= 0.0:
                    continue
            else:
                xo = 1.0  # kapalıysa merkez farkı vb. kullanabilirdik; gerek yok.

            # MESAFE ÖNEMSİZ -> sadece seçim kriterinde (tie-breaker) kullan
            vgap = st - rbm  # küçük olanı tercih ederiz ama şart değildir
            cands.append((xo, -vgap, si))  # daha fazla yatay örtüşme, daha az gap

        if not cands:
            continue

        cands.sort(reverse=True)          # (xo büyük, gap küçük) öncelik
        best_si = cands[0][2]

        pairs.append((ri, best_si))
        used_roles.add(ri)
        used_sigs.add(best_si)

    # ---------------- compose final set ----------------
    final_ltrb: List[BOXLTRB] = []

    # 1) Eşleşen rol+imza -> TEK KUTU (union)
    for ri, si in pairs:
        final_ltrb.append( union(roles_ltrb[ri], sigs_ltrb[si]) )

    # 2) Sermaye kutularını direkt ekle
    final_ltrb.extend(sermaye_ltrb)

    # 3) İsteğe bağlı: eşleşmemiş rol/sig kutuları
    if include_unpaired_roles:
        for ri, rb in enumerate(roles_ltrb):
            if ri not in used_roles:
                final_ltrb.append(rb)
    if include_unpaired_sigs:
        for si, sb in enumerate(sigs_ltrb):
            if si not in used_sigs:
                final_ltrb.append(sb)

    # 4) Dedup/tekilleştirme
    final_xywh = dedup_merge_close([to_xywh(bb) for bb in final_ltrb])

    return {
        "final":   final_xywh,
        "pairs":   pairs,
        "roles":   [to_xywh(b) for b in roles_ltrb],
        "sigs":    [to_xywh(b) for b in sigs_ltrb],
        "sermaye": [to_xywh(b) for b in sermaye_ltrb],
    }