import cv2, numpy as np, matplotlib.pyplot as plt
from typing import Union, Sequence

def clean_doc_images_locationwise(
    doc_images: Union[np.ndarray, Sequence[np.ndarray]],
    *,
    return_gray: bool = True,
    debug: bool = False
):
    """
    Local contrast cleaner for OCR.
    Converts near-black pixels to black and near-white to white
    based on neighborhood intensity, preserving edges and readability.
    """

    def _ensure_list(x):
        if isinstance(x, np.ndarray): return [x], True
        return list(x), False

    def _to_gray(img):
        return cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if img.ndim == 3 else img.copy()

    def _local_contrast_clean(gray):
        # 1. Smooth slightly to reduce noise
        blur = cv2.GaussianBlur(gray, (3,3), 0)

        # 2. Compute local mean using a larger window
        mean = cv2.blur(blur, (25,25))

        # 3. Difference from local mean
        diff = cv2.subtract(blur, mean)
        enhanced = cv2.addWeighted(blur, 1.5, diff, 1.5, 0)

        # 4. Push near-black / near-white extremes
        result = enhanced.copy()
        low_mask = (enhanced < 100)
        high_mask = (enhanced > 180)
        result[low_mask] = 0
        result[high_mask] = 255

        # 5. Final smoothing for readability
        result = cv2.medianBlur(result, 3)
        return result

    imgs, was_single = _ensure_list(doc_images)
    outs = []
    for i, im in enumerate(imgs):
        gray = _to_gray(im)
        cleaned = _local_contrast_clean(gray)

        if debug:
            plt.figure(figsize=(12,5))
            plt.subplot(1,2,1); plt.imshow(gray, cmap='gray'); plt.title(f'Before (page {i})'); plt.axis('off')
            plt.subplot(1,2,2); plt.imshow(cleaned, cmap='gray'); plt.title(f'After (page {i})'); plt.axis('off')
            plt.show()

        outs.append(cleaned if return_gray else cv2.cvtColor(cleaned, cv2.COLOR_GRAY2BGR))

    return outs[0] if was_single else outs