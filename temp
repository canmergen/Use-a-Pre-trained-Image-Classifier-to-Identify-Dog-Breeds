def _extract_company(text: str, lines: List[str]) -> Tuple[Optional[str], Optional[str], Dict]:
    dbg = {}
    T_norm = _norm_spaces(text)
    T_raw  = _nfkc(text)
    L = [_norm_spaces(ln) for ln in lines if isinstance(ln,str) and ln.strip()]

    # === 1. AYNı SATIRDA GEÇEN ŞİRKET ADI + TÜRÜNÜ DOĞRUDAN YAKALA ===
    inline_match = re.search(
        r"([A-ZÇĞİÖŞÜ0-9\s\.\-\/&’']{3,})\s+(ANON[İI]M\s+Ş[İI]RKET[İI]|A\.?\s*Ş|AŞ|LTD\.?\s*ŞT[İI]|LTD|LİMİTED\s+Ş[İI]RKET[İI])",
        T_norm
    )
    if inline_match:
        cname = re.sub(r"\s+", " ", inline_match.group(1)).strip(" ,.-:;’'")
        cname = re.sub(r"\b(ANONIM|LIMITED|ŞİRKET[Iİ]|AŞ|A\.Ş)\b", "", cname, flags=re.IGNORECASE).strip(" ,.-:;’'")
        ctype = _map_type_to_canonical(inline_match.group(2))
        return _upper_tr(cname), ctype, {
            "reason": "inline_match",
            "best_score": 1.0,
            "best_name": cname,
            "type": ctype
        }

    # === 2. NORMAL ESKİ YAKINLIK-TEMİZLEME SÜRECİ ===
    GEN = r"(?:\s*[’'`´\"“”]?\s*(?:NIN|NİN|NUN|NÜN|IN|İN|UN|ÜN))?"
    AS   = r"(?:A\.?\s*Ş|A\.?\s*S|AŞ|AS)"+GEN
    ANON = r"ANON[İI]M\s+"+_spaced_token("ŞİRKET")+GEN
    LTD  = r"(?:LTD\s*\.?\s*ŞT[İI]|LTD\s*\.?\s*ST[İI]|L[İI]M[İI]TED\s+"+_spaced_token("ŞİRKET")+r")"+GEN
    SIRK = _spaced_token("ŞİRKET")+GEN
    CORE = rf"(?:{AS}|{ANON}|{LTD}|KOLEKT[İI]F\s+{SIRK}|AD[İI]\s+KOMAND[İI]T\s+{SIRK}|SERMAYES[İI]\s+PAYLARA\s+BÖLÜNMÜŞ\s+KOMAND[İI]T\s+{SIRK}|KOMAND[İI]T\s+{SIRK}|HOLD[İI]NG|KOOPERAT[İI]F|VAKF[Iİ]|VAKIF|DERNEK)"
    TYPE_RE = re.compile(CORE, re.IGNORECASE)
    matches = list(TYPE_RE.finditer(T_norm))
    if not matches:
        dbg["reason"] = "no_type_match"
        return None, None, dbg

    STOPWORDS = {
        "GENEL","KURUL","TOPLANTISI","TOPLANTISINDA","HAZIR","BULUNANLAR","LİSTESİ","GÜNDEM",
        "TARİHLİ","OLAĞAN","OLAĞANÜSTÜ","YILLIK","TUTANAK","PAY","PAYLARIN","PAYLAR",
        "HİNDE","HİNDEYE","KİMLİK","VERGİ","SAHİBİNİN","SAHİPLERİNİN","TEMSİLCİ",
        "TEMSİLEN","KATILIM","KATILAN","TOPLAM","EDEN","SAYILI","SIRA","AD/SOYAD",
        "NUMARA","ADRESİ","MERKEZİ","ŞUBE","ÜNVANI","YÖNETİM","GÖREV","LİSTE","EK-",
    }
    STOPTAIL = {"AN","VE","TIC","TİC","SAN","VE.","TIC.","TİC.","SAN."}

    def _clean_name(s: str) -> str:
        s = re.sub(r"[^\w\s\.\-\/&’'ÇĞİÖŞÜçğıöşü]", " ", s)
        s = re.sub(r"\s+", " ", s).strip(" ,.-:;’'")
        tail = re.sub(r".*\s", "", s).upper()
        if tail in STOPTAIL:
            s = re.sub(r"\s+\S+$", "", s).strip(" ,.-:;’'")
        toks = [t for t in s.split() if t.upper() not in STOPWORDS]
        return " ".join(toks).strip(" ,.-:;’'")

    def _compact_right(tokens: List[str], min_tok=2, max_tok=12) -> str:
        tokens = tokens[-max_tok:]
        for start in range(max(0, len(tokens)-min_tok), -1, -1):
            cand = " ".join(tokens[start:])
            if _score_name(cand) > 0:
                return cand
        return " ".join(tokens[-min_tok:])

    candidates = []
    for m in matches:
        ctype = _map_type_to_canonical(m.group(0))
        at = m.start()
        left_raw = T_raw[max(0, at-700):at]
        boundary = max(left_raw.rfind("\n"), left_raw.rfind(";"), left_raw.rfind(":"),
                       left_raw.rfind("."), left_raw.rfind("—"), left_raw.rfind("–"))
        seg = left_raw[boundary+1:] if boundary >= 0 else left_raw
        seg = _clean_name(seg)
        seg = _compact_right(seg.split(), 2, 12)
        if seg:
            dist = len(left_raw) - (boundary+1 if boundary>=0 else 0)
            prox = max(0.0, 1.0 - dist/650.0)
            sc = 0.75*_score_name(seg) + 0.25*prox
            candidates.append((sc, seg, ctype or ""))

    if not candidates:
        dbg["reason"] = "no_candidates"
        return None, _map_type_to_canonical(matches[-1].group(0)), dbg

    best = max(candidates, key=lambda x: x[0])
    cname = best[1]
    ctype = best[2] or _map_type_to_canonical(matches[-1].group(0))
    dbg["best_score"] = best[0]
    dbg["best_name"] = cname
    dbg["type"] = ctype
    return _upper_tr(cname), ctype, dbg