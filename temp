def _extract_company_from_text(text: str) -> Tuple[Optional[str], Optional[str]]:
    """
    Tip demirinden önceki en yakın 'şirket adı' öbeğini alır.
    Başlık kelimelerini (GENEL KURUL... vb.) sol parçadan temizler.
    """
    if not isinstance(text, str) or not text.strip():
        return None, None

    def U(s: str) -> str:
        mp = {"i":"İ","ı":"I","ş":"Ş","ğ":"Ğ","ü":"Ü","ö":"Ö","ç":"Ç"}
        return "".join(mp.get(ch, ch.upper()) for ch in s or "")

    def norm(s: str) -> str:
        s = unicodedata.normalize("NFKC", s or "")
        s = s.replace("\u200b"," ").replace("\xa0"," ")
        return re.sub(r"\s+", " ", s).strip()

    def map_type(raw: str) -> Optional[str]:
        # mevcut _map_type_to_canonical ile aynı mantıkta kısaltılmış
        R = norm(raw).upper()
        Rf = (R.replace("İ","I").replace("Ş","S").replace("Ğ","G")
               .replace("Ü","U").replace("Ö","O").replace("Ç","C"))
        flat = re.sub(r"[\s\.\-_/’'`´]+","", Rf)
        if re.search(r"(AS|AŞ|ANONIMSIRKET)", flat): return "ANONİM ŞİRKETİ"
        if re.search(r"(LTDSTI|LIMITEDSIRKET)", flat): return "LİMİTED ŞİRKETİ"
        if "HOLDING" in flat: return "HOLDİNG"
        if "KOOPERATIF" in flat: return "KOOPERATİF"
        if re.search(r"KOLEKTIF.*SIRKET", flat): return "KOLEKTİF ŞİRKET"
        if re.search(r"ADIKOMANDIT.*SIRKET", flat): return "ADİ KOMANDİT ŞİRKET"
        if re.search(r"SERMAYESIPAYLARABOLUNMUSKOMANDIT.*SIRKET", flat): return "SERMAYESİ PAYLARA BÖLÜNMÜŞ KOMANDİT ŞİRKET"
        if re.search(r"KOMANDIT.*SIRKET", flat): return "KOMANDİT ŞİRKET"
        if "VAKIF" in flat: return "VAKIF"
        if "DERNEK" in flat: return "DERNEK"
        return None

    # --- Tip desenleri (eklere toleranslı)
    def spaced(tok: str) -> str: return r"\s*".join(re.escape(ch) for ch in tok)
    GEN = r"(?:\s*[’'`´\"“”]?\s*(?:NIN|NİN|NUN|NÜN|IN|İN|UN|ÜN))?"
    AS   = r"(?:A\.?\s*Ş|A\.?\s*S|AŞ|AS)"+GEN
    ANON = r"ANON[İI]M\s+"+spaced("ŞİRKET")+GEN
    LTD  = r"(?:LTD\s*\.?\s*ŞT[İI]|LTD\s*\.?\s*ST[İI]|L[İI]M[İI]TED\s+"+spaced("ŞİRKET")+r")"+GEN
    SIRK = spaced("ŞİRKET")+GEN
    CORE = rf"(?:{AS}|{ANON}|{LTD}|KOLEKT[İI]F\s+{SIRK}|AD[İI]\s+KOMAND[İI]T\s+{SIRK}|SERMAYES[İI]\s+PAYLARA\s+BÖLÜNMÜŞ\s+KOMAND[İI]T\s+{SIRK}|KOMAND[İI]T\s+{SIRK}|HOLD[İI]NG|KOOPERAT[İI]F|VAKF[Iİ]|VAKIF|DERNEK)"
    TYPE_RE = re.compile(CORE, re.IGNORECASE)

    # --- Başlık ve gürültü sözcükleri: sol parçadan atılacak
    HEADER_TOKS = [
        "GENEL","KURUL","TOPLANTISINDA","HAZIR","BULUNANLAR","LİSTESİ","GÜNDEM","TARİHLİ",
        "TOPLAM","KATILIM","KİMLİK","PAYDAŞ","VEKALET","TEMSİLCİ","TEMSİLCİNİN","SIRA"
    ]
    HEADER_RE = re.compile(rf"(?:^|[\s,:;-])(?:{'|'.join(HEADER_TOKS)})[\w\-]*", re.IGNORECASE)

    # --- Ad öbeği: büyük harf ağırlıklı ve makul uzunlukta
    NAME_BLOCK_RE = re.compile(
        r"([A-ZÇĞİÖŞÜ0-9][A-ZÇĞİÖŞÜ0-9\.\-\/&’']{1,}(?:\s+[A-ZÇĞİÖŞÜ0-9\.\-\/&’']{2,}){0,10})\s*$"
    )

    T = norm(text)
    matches = list(TYPE_RE.finditer(T))
    if not matches:
        return None, None

    # En yakın/düzgün adı bulana kadar, tipi sondan başa gez
    for m in reversed(matches):
        ctype = map_type(m.group(0))
        # 1) Sol pencereyi al
        left = T[max(0, m.start()-700):m.start()]
        # 2) Son başlık anahtarından SONRASINI al
        cuts = [p.end() for p in HEADER_RE.finditer(left)]
        if cuts:
            left = left[max(cuts):]
        left = left.strip(" ,.-:;’'")

        # 3) Sağdan en son büyük-harf bloğunu yakala
        b = NAME_BLOCK_RE.search(left)
        if not b:
            continue
        name = b.group(1).strip(" ,.-:;’'")
        # çok uzun paragrafı kırp: son noktalama/linebreak'ten sonra kalan kısmı al
        name = re.split(r"[\n\r]| {2,}| : | - ", name)[-1].strip(" ,.-:;’'")

        # Minimum kalite kontrolü
        letters = sum(ch.isalpha() for ch in name)
        if letters >= 6 and len(name.split()) >= 2:
            return U(name), ctype

    # Bulunamazsa: None
    return None, map_type(matches[-1].group(0))